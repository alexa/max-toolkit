diff --git a/ACL/src/Transport/MessageRouter.cpp b/ACL/src/Transport/MessageRouter.cpp
index 752ad20a..2d6e8eb4 100644
--- a/ACL/src/Transport/MessageRouter.cpp
+++ b/ACL/src/Transport/MessageRouter.cpp
@@ -316,7 +316,7 @@ void MessageRouter::notifyObserverOnConnectionStatusChanged(
             m_serverSideDisconnectNotificationPending = true;
             m_serverSideDisconnectTimer.start(m_serverSideReconnectGracePeriod, [this]() {
                 ACSDK_DEBUG0(LX("serverSideDisconectTimerPredicate"));
-                m_executor.submit([this]() {
+                m_executor.execute([this]() {
                     ACSDK_DEBUG0(
                         LX("serverSideDisconectTimerHandler")
                             .d("m_serverSideDisconnectNotificationPending", m_serverSideDisconnectNotificationPending));
@@ -335,7 +335,7 @@ void MessageRouter::notifyObserverOnConnectionStatusChanged(
             handleNotifyObserverOnConnectionStatusChanged(status, reason);
         }
     };
-    m_executor.submit(task);
+    m_executor.execute(task);
 }
 
 void MessageRouter::handleNotifyObserverOnConnectionStatusChanged(
@@ -360,7 +360,7 @@ void MessageRouter::notifyObserverOnReceive(const std::string& contextId, const
             temp->receive(contextId, message);
         }
     };
-    m_executor.submit(task);
+    m_executor.execute(task);
 }
 
 void MessageRouter::createActiveTransportLocked() {
@@ -428,7 +428,7 @@ void MessageRouter::safelyResetActiveTransportLocked() {
 void MessageRouter::safelyReleaseTransport(std::shared_ptr<TransportInterface> transport) {
     if (transport) {
         auto task = [transport]() { transport->shutdown(); };
-        m_executor.submit(task);
+        m_executor.execute(task);
     }
 }
 
diff --git a/AFML/include/AFML/Channel.h b/AFML/include/AFML/Channel.h
index 67b578c2..18e7f420 100644
--- a/AFML/include/AFML/Channel.h
+++ b/AFML/include/AFML/Channel.h
@@ -43,7 +43,7 @@ namespace afml {
  */
 class Channel {
 public:
-    /*
+    /**
      * This class contains the states of the @c Channel.
      */
     struct State {
@@ -53,7 +53,7 @@ public:
         /// Constructor.
         State();
 
-        /*
+        /**
          * The channel's name.  Although the name is not dynamic, it is useful for identifying which channel the state
          * belongs to.
          */
@@ -97,7 +97,7 @@ public:
     /**
      * Updates the focus and notifies all activities associated with the @c Channel of the focus change. If @c
      * FocusState is FOREGROUND, then the most recent Activity added to the Channel will be moved to foreground state,
-     * and all other Activites will remain in background state. This method does not return until the
+     * and all other Activities will remain in background state. This method does not return until the
      * ChannelObserverInterface##onFocusChanged() callbacks to all the associated activities return. If the focus is @c
      * NONE, the Activity will be removed from the Channel.
      *
diff --git a/AFML/include/AFML/FocusManagementComponent.h b/AFML/include/AFML/FocusManagementComponent.h
index ded60926..d2eccb5f 100644
--- a/AFML/include/AFML/FocusManagementComponent.h
+++ b/AFML/include/AFML/FocusManagementComponent.h
@@ -39,6 +39,9 @@ namespace afml {
 using FocusManagementComponent = acsdkManufactory::Component<
     acsdkManufactory::
         Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::AudioFocusAnnotation,
+        avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
     acsdkManufactory::
         Annotated<avsCommon::sdkInterfaces::VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
@@ -46,7 +49,8 @@ using FocusManagementComponent = acsdkManufactory::Component<
     acsdkManufactory::Import<acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
         avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface>>,
-    acsdkManufactory::Import<std::shared_ptr<interruptModel::InterruptModel>>>;
+    acsdkManufactory::Import<std::shared_ptr<interruptModel::InterruptModel>>,
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>>>;
 
 /**
  * Creates an manufactory component that exports a shared pointer to @c Annotated @c FocusManagers.
diff --git a/AFML/include/AFML/FocusManager.h b/AFML/include/AFML/FocusManager.h
index d8131918..68088c9f 100644
--- a/AFML/include/AFML/FocusManager.h
+++ b/AFML/include/AFML/FocusManager.h
@@ -20,6 +20,7 @@
 #include <map>
 #include <mutex>
 #include <set>
+#include <string>
 #include <unordered_map>
 #include <unordered_set>
 #include <vector>
@@ -27,6 +28,8 @@
 #include <acsdkManufactory/Annotated.h>
 #include <AVSCommon/SDKInterfaces/AudioFocusAnnotation.h>
 #include <AVSCommon/SDKInterfaces/ChannelObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorCallbackInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/Utils/Threading/Executor.h>
 #include <InterruptModel/InterruptModel.h>
@@ -54,7 +57,10 @@ namespace afml {
  * ChannelObserverInterface##onFocusChanged() method, at which point the client should make a user observable change
  * based on the focus it receives.
  */
-class FocusManager : public avsCommon::sdkInterfaces::FocusManagerInterface {
+class FocusManager
+        : public avsCommon::sdkInterfaces::FocusManagerInterface
+        , public avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface
+        , public std::enable_shared_from_this<FocusManager> {
 public:
     /**
      * The configuration used by the FocusManager to create Channel objects. Each configuration object has a
@@ -94,7 +100,7 @@ public:
          *
          * @param channelTypeKey The key of the virtual channel configuration to get.
          * @param[out] virtualChannelConfiguration The @c ChannelConfiguration for the virtual channels as specified in
-         * @c channelTypeKey.  An empty vector if there is no such info on the configuration file.
+         * @c channelTypeKey. An empty vector if there is no such info in the configuration file.
          * @return true if there's no error, false otherwise.
          */
         static bool readChannelConfiguration(
@@ -103,7 +109,21 @@ public:
     };
 
     /**
-     * This constructor creates Channels based on the provided configurations.
+     * Retrieves the default @c ChannelConfiguration for AVS audio channels.
+     *
+     * @return The default @c ChannelConfiguration for AVS audio channels.
+     */
+    static const std::vector<FocusManager::ChannelConfiguration> getDefaultAudioChannels();
+
+    /**
+     * Retrieves the default @c ChannelConfiguration for AVS visual channels.
+     *
+     * @return The default @c ChannelConfiguration for AVS visual channels.
+     */
+    static const std::vector<FocusManager::ChannelConfiguration> getDefaultVisualChannels();
+
+    /**
+     * A factory function that creates a FocusManager.
      *
      * @param channelConfigurations A vector of @c channelConfiguration objects that will be used to create the
      * Channels. No two Channels should have the same name or priority. If there are multiple configurations with the
@@ -115,57 +135,57 @@ public:
      * with the same name or priority, the latter Channels with that name or priority will not be created.
      * @param interruptModel @c InterruptModel object that provides MixingBehavior inputs to ChannelObservers upon
      * Focus State Change.
+     * @param externalFocusMediator @c externalFocusMediator instance enables FocusManager to call and receive focus
+     * requests from an external focus mediator.
+     * @return A new FocusManager or nullptr if the operation fails.
      */
-    FocusManager(
+    static std::shared_ptr<FocusManager> create(
         const std::vector<ChannelConfiguration>& channelConfigurations,
         std::shared_ptr<ActivityTrackerInterface> activityTrackerInterface = nullptr,
         const std::vector<ChannelConfiguration>& virtualChannelConfigurations = std::vector<ChannelConfiguration>(),
-        std::shared_ptr<interruptModel::InterruptModel> interruptModel = nullptr);
+        std::shared_ptr<interruptModel::InterruptModel> interruptModel = nullptr,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface> externalFocusMediator = nullptr);
 
+    /// @name FocusManagerInterface methods.
+    /// @{
     bool acquireChannel(
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver,
         const std::string& interfaceName) override;
-
     bool acquireChannel(
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface::Activity> channelActivity) override;
-
     std::future<bool> releaseChannel(
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) override;
-
     void stopForegroundActivity() override;
-
     void stopAllActivities() override;
-
     void addObserver(const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>& observer) override;
-
     void removeObserver(
         const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>& observer) override;
-
     void modifyContentType(
         const std::string& channelName,
         const std::string& interfaceName,
         avsCommon::avs::ContentType contentType) override;
-
-    /**
-     * Retrieves the default @c ChannelConfiguration for AVS audio channels.
-     *
-     * @return the default @c ChannelConfiguration for AVS audio channels.
-     */
-    static const std::vector<FocusManager::ChannelConfiguration> getDefaultAudioChannels();
-
-    /**
-     * Retrieves the default @c ChannelConfiguration for AVS visual channels.
-     *
-     * @return the default @c ChannelConfiguration for AVS visual channels.
-     */
-    static const std::vector<FocusManager::ChannelConfiguration> getDefaultVisualChannels();
+    /// @}
+
+    /// @name ExternalFocusMediatorCallbackInterface methods.
+    /// @{
+    std::unordered_map<
+        std::string,
+        avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>
+    getActiveChannelStates() override;
+    avsCommon::utils::threading::Promise<void> changeFocusState(
+        const std::string& focusRequestId,
+        const avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus&
+            externalFocus) override;
+    avsCommon::utils::threading::Promise<void> mediatorReleaseFocus(const std::string& focusRequestId) override;
+    /// @}
 
 private:
     /// A Map for mapping a @c Channel to its owner.
     using ChannelsToInterfaceNamesMap = std::map<std::shared_ptr<Channel>, std::string>;
+
     /**
      * Functor so that we can compare Channel objects via shared_ptr.
      */
@@ -175,7 +195,6 @@ private:
          *
          * @param first The first Channel to compare.
          * @param second The second Channel to compare.
-         *
          * @return Returns @c true if the first Channel has a higher Channel priority than the second Channel.
          */
         bool operator()(const std::shared_ptr<Channel>& first, const std::shared_ptr<Channel>& second) const {
@@ -183,6 +202,36 @@ private:
         }
     };
 
+    /**
+     * This constructor creates Channels based on the provided configurations.
+     *
+     * @param channelConfigurations A vector of @c channelConfiguration objects that will be used to create the
+     * Channels. No two Channels should have the same name or priority. If there are multiple configurations with the
+     * same name or priority, the latter Channels with that name or priority will not be created.
+     * @param activityTrackerInterface The interface to notify the activity tracker a vector of channel states that has
+     * been updated.
+     * @param virtualChannelConfigurations A vector of @c channelConfiguration objects that will be used to create the
+     * Virtual Channels. No two Channels should have the same name or priority. If there are multiple configurations
+     * with the same name or priority, the latter Channels with that name or priority will not be created.
+     * @param interruptModel @c InterruptModel object that provides MixingBehavior inputs to ChannelObservers upon
+     * Focus State Change.
+     * @param externalFocusMediator @c externalFocusMediator instance enables FocusManager to call and receive focus
+     * requests from an external focus mediator.
+     */
+    FocusManager(
+        const std::vector<ChannelConfiguration>& channelConfigurations,
+        std::shared_ptr<ActivityTrackerInterface> activityTrackerInterface,
+        const std::vector<ChannelConfiguration>& virtualChannelConfigurations,
+        std::shared_ptr<interruptModel::InterruptModel> interruptModel,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface> externalFocusMediator);
+
+    /**
+     * Initializes the FocusManager.
+     *
+     * @return Whether initialization was successful.
+     */
+    bool initialize();
+
     /**
      * Helper function to read the @c ChannelConfiguration into @c m_allChannels.  This function also ensures the name
      * and priority for all channels are unique.
@@ -199,7 +248,7 @@ private:
      * @param focus The @c FocusState to set @c channel to.
      * @param behavior The @c MixingBehavior to set @c channel to.
      * @param forceUpdate optional, if set to true this function will update
-     *        activitytracker context (even if focus/behavior did not change).
+     * activitytracker context (even if focus/behavior did not change).
      */
     void setChannelFocus(
         const std::shared_ptr<Channel>& channel,
@@ -209,14 +258,18 @@ private:
 
     /**
      * Grants access to the Channel specified and updates other Channels as needed. This function provides the full
-     * implementation which the public method will call.
+     * implementation which the public method acquireChannel will call.
      *
      * @param channelToAcquire The Channel to acquire.
      * @param channelActivity The Activity to acquire.
+     * @param focusState The FocusState of the activity acquiring the channel.
+     * @param mixingBehavior The MixingBehavior of the activity acquiring the channel.
      */
     void acquireChannelHelper(
         std::shared_ptr<Channel> channelToAcquire,
-        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface::Activity> channelActivity);
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface::Activity> channelActivity,
+        avsCommon::avs::FocusState focusState = avsCommon::avs::FocusState::FOREGROUND,
+        avsCommon::avs::MixingBehavior mixingBehavior = avsCommon::avs::MixingBehavior::PRIMARY);
 
     /**
      * Releases the Channel specified and updates other Channels as needed. This function provides the full
@@ -225,13 +278,40 @@ private:
      * @param channelToRelease The Channel to release.
      * @param channelObserver The observer of the Channel to release.
      * @param releaseChannelSuccess The promise to satisfy.
-     * @param channelName The name of the Channel.
      */
     void releaseChannelHelper(
         std::shared_ptr<Channel> channelToRelease,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver,
-        std::shared_ptr<std::promise<bool>> releaseChannelSuccess,
-        const std::string& channelName);
+        std::shared_ptr<std::promise<bool>> releaseChannelSuccess);
+
+    /**
+     * Releases the focus of the active Channel specified regardless of however many activities may be on that Channel.
+     *
+     * @param channelToRelease The Channel to release.
+     * @return Whether the operation was successful, if unsuccessful, the Channel will not be released.
+     */
+    bool releaseFocusHelper(const std::shared_ptr<Channel>& channelToRelease);
+
+    /**
+     * Updates focus of the current Channel specified and updates other Channels as needed.
+     *
+     * @param channel The Channel to update focus state.
+     * @param highestPriorityChannel The highest priority Channel.
+     * @param focusState The desired focus state.
+     * @param mixingBehavior The desired mixing behavior.
+     */
+    void updateFocusStateHelper(
+        std::shared_ptr<Channel> channel,
+        std::shared_ptr<Channel> highestPriorityChannel,
+        avsCommon::avs::FocusState focusState,
+        avsCommon::avs::MixingBehavior mixingBehavior);
+
+    /**
+     * Removes Channel from active channels and updates other Channels as needed.
+     *
+     * @param channel The Channel to clean up.
+     */
+    void cleanupChannel(const std::shared_ptr<Channel>& channel);
 
     /**
      * Stops the Channel specified and updates other Channels as needed if the interface name passed in matches the
@@ -246,11 +326,9 @@ private:
         std::string foregroundChannelInterface);
 
     /**
-     *  Stops all channels specified in @c channelsOwnersMap.
-     * A channel will get stopped if it's currently owned by the interface  mapped to the channel
-     * in @c channelsOwnersMap.
-     * This function provides the full implementation which the public method will
-     * call.
+     * Stops all channels specified in @c channelsOwnersMap.
+     * A channel will get stopped if it's currently owned by the interface mapped to the channel in @c
+     * channelsOwnersMap. This function provides the full implementation which the public method will call.
      *
      * @param channelsOwnersMap Mapping of channel to owning interfaces
      */
@@ -265,25 +343,24 @@ private:
     std::shared_ptr<Channel> getChannel(const std::string& channelName) const;
 
     /**
-     * Gets the currently foregrounded Channel.
+     * Gets the highest priority Channel.
      *
      * @return Returns the highest priority active Channel if there is one and @c nullptr otherwise.
      */
     std::shared_ptr<Channel> getHighestPriorityActiveChannelLocked() const;
 
     /**
-     * Checks to see if the provided channel currently has foreground focus or not.
+     * Checks to see if the provided channel currently has the highest priority or not.
      *
      * @param channel The channel to check.
-     * @return Returns @c true if the @c Channel is foreground focused and @c false if it is not.
+     * @return Returns @c true if the @c Channel is the highest priority channel and @c false if it is not.
      */
-    bool isChannelForegroundedLocked(const std::shared_ptr<Channel>& channel) const;
+    bool isChannelHighestPriorityActiveChannelLocked(const std::shared_ptr<Channel>& channel) const;
 
     /**
      * Checks to see if the provided Channel name already exists.
      *
      * @param name The Channel name to check.
-     *
      * @return Returns @c true if the name is already associated with a Channel and @c false otherwise.
      */
     bool doesChannelNameExist(const std::string& name) const;
@@ -292,7 +369,6 @@ private:
      * Checks to see if the provided Channel priority already exists.
      *
      * @param priority The Channel priority to check.
-     *
      * @return Returns @c true if the priority is already associated with a Channel and @c false otherwise.
      */
     bool doesChannelPriorityExist(const unsigned int priority) const;
@@ -309,8 +385,8 @@ private:
     void notifyActivityTracker();
 
     /**
-     * Get the mixing behavior for ChannelObserver associated with a low priority channel , when a high priority channel
-     * barges in
+     * Get the mixing behavior for ChannelObserver associated with a low priority channel, when a high priority channel
+     * barges in.
      *
      * @param lowPrioChannel channel with the lower priority
      * @param highPrioChannel channel with the higher priority
@@ -341,9 +417,9 @@ private:
     /// The set of observers to notify about focus changes.
     std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>> m_observers;
 
-    /*
+    /**
      * A vector of channel's State that has been updated due to @c acquireChannel(), @c releaseChannel() or
-     * stopForegroundActivity().  This is accessed by functions in the @c m_executor worker thread, and do not require
+     * stopForegroundActivity(). This is accessed by functions in the @c m_executor worker thread, and do not require
      * any synchronization.
      */
     std::vector<Channel::State> m_activityUpdates;
@@ -354,11 +430,14 @@ private:
     /// The interrupt Model associated with the focus manager
     std::shared_ptr<interruptModel::InterruptModel> m_interruptModel;
 
+    /// The interface to communicate with an external focus system
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface> m_externalFocusMediator;
+
     /**
      * @c Executor which queues up operations from asynchronous API calls.
      *
      * @note This declaration needs to come *after* the Executor Thread Variables so that the thread shuts down
-     *     before the Executor Thread Variables are destroyed.
+     * before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
 };
diff --git a/AFML/src/AudioActivityTracker.cpp b/AFML/src/AudioActivityTracker.cpp
index b0ef2fd6..fe551497 100644
--- a/AFML/src/AudioActivityTracker.cpp
+++ b/AFML/src/AudioActivityTracker.cpp
@@ -113,12 +113,12 @@ void AudioActivityTracker::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     unsigned int stateRequestToken) {
     ACSDK_DEBUG5(LX("provideState"));
-    m_executor.submit([this, stateRequestToken]() { executeProvideState(stateRequestToken); });
+    m_executor.execute([this, stateRequestToken]() { executeProvideState(stateRequestToken); });
 }
 
 void AudioActivityTracker::notifyOfActivityUpdates(const std::vector<Channel::State>& channelStates) {
     ACSDK_DEBUG5(LX("notifyOfActivityUpdates"));
-    m_executor.submit([this, channelStates]() { executeNotifyOfActivityUpdates(channelStates); });
+    m_executor.execute([this, channelStates]() { executeNotifyOfActivityUpdates(channelStates); });
 }
 
 AudioActivityTracker::AudioActivityTracker(
diff --git a/AFML/src/FocusManagementComponent.cpp b/AFML/src/FocusManagementComponent.cpp
index f67235aa..663a28e9 100644
--- a/AFML/src/FocusManagementComponent.cpp
+++ b/AFML/src/FocusManagementComponent.cpp
@@ -42,11 +42,10 @@ static const std::string AUDIO_CHANNEL_CONFIG_KEY = "audioChannels";
 /// Key for visual channel array configurations in configuration node.
 static const std::string VISUAL_CHANNEL_CONFIG_KEY = "visualChannels";
 
-acsdkManufactory::Annotated<AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>
-createAudioFocusManager(
-    acsdkManufactory::Annotated<AudioFocusAnnotation, ActivityTrackerInterface> annotatedActivityTracker,
-    std::shared_ptr<interruptModel::InterruptModel> interruptModel) {
-    // Read audioChannels configuration from config file
+acsdkManufactory::Annotated<AudioFocusAnnotation, afml::FocusManager> createAudioFocusManager(
+    const acsdkManufactory::Annotated<AudioFocusAnnotation, ActivityTrackerInterface>& annotatedActivityTracker,
+    const std::shared_ptr<interruptModel::InterruptModel>& interruptModel,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator) {
     std::vector<afml::FocusManager::ChannelConfiguration> audioVirtualChannelConfiguration;
     if (!afml::FocusManager::ChannelConfiguration::readChannelConfiguration(
             AUDIO_CHANNEL_CONFIG_KEY, &audioVirtualChannelConfiguration)) {
@@ -56,21 +55,35 @@ createAudioFocusManager(
 
     std::shared_ptr<afml::ActivityTrackerInterface> activityTracker = annotatedActivityTracker;
 
-    auto focusManager = std::make_shared<afml::FocusManager>(
+    auto focusManager = afml::FocusManager::create(
         afml::FocusManager::getDefaultAudioChannels(),
         activityTracker,
         audioVirtualChannelConfiguration,
-        interruptModel);
+        interruptModel,
+        externalFocusMediator);
+
+    return acsdkManufactory::Annotated<AudioFocusAnnotation, afml::FocusManager>(focusManager);
+}
 
+acsdkManufactory::Annotated<AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>
+createAudioFocusManagerInterface(
+    const acsdkManufactory::Annotated<AudioFocusAnnotation, afml::FocusManager>& annotatedFocusManagerWrapper) {
     return acsdkManufactory::Annotated<AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>(
-        focusManager);
+        std::shared_ptr<afml::FocusManager>(annotatedFocusManagerWrapper));
+}
+
+acsdkManufactory::Annotated<AudioFocusAnnotation, avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>
+createExternalAudioFocusMediatorCallbackInterface(
+    const acsdkManufactory::Annotated<AudioFocusAnnotation, afml::FocusManager>& annotatedFocusManagerWrapper) {
+    return acsdkManufactory::
+        Annotated<AudioFocusAnnotation, avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>(
+            std::shared_ptr<afml::FocusManager>(annotatedFocusManagerWrapper));
 }
 
 acsdkManufactory::Annotated<VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>
 createVisualFocusManager(
     acsdkManufactory::Annotated<VisualFocusAnnotation, ActivityTrackerInterface> annotatedActivityTracker,
     std::shared_ptr<interruptModel::InterruptModel> interruptModel) {
-    // Read visualChannels configuration from config file
     std::vector<afml::FocusManager::ChannelConfiguration> visualVirtualChannelConfiguration;
     if (!afml::FocusManager::ChannelConfiguration::readChannelConfiguration(
             VISUAL_CHANNEL_CONFIG_KEY, &visualVirtualChannelConfiguration)) {
@@ -80,7 +93,7 @@ createVisualFocusManager(
 
     std::shared_ptr<afml::ActivityTrackerInterface> activityTracker = annotatedActivityTracker;
 
-    auto focusManager = std::make_shared<afml::FocusManager>(
+    auto focusManager = afml::FocusManager::create(
         afml::FocusManager::getDefaultVisualChannels(),
         activityTracker,
         visualVirtualChannelConfiguration,
@@ -94,7 +107,9 @@ FocusManagementComponent getComponent() {
     return acsdkManufactory::ComponentAccumulator<>()
         .addRetainedFactory(AudioActivityTracker::createAudioActivityTrackerInterface)
         .addRetainedFactory(VisualActivityTracker::createVisualActivityTrackerInterface)
-        .addRequiredFactory(createAudioFocusManager)
+        .addRetainedFactory(createAudioFocusManager)
+        .addRequiredFactory(createAudioFocusManagerInterface)
+        .addRetainedFactory(createExternalAudioFocusMediatorCallbackInterface)
         .addRetainedFactory(createVisualFocusManager);
 }
 
diff --git a/AFML/src/FocusManager.cpp b/AFML/src/FocusManager.cpp
index c7c7b6ec..b67079b8 100644
--- a/AFML/src/FocusManager.cpp
+++ b/AFML/src/FocusManager.cpp
@@ -15,7 +15,6 @@
 
 #include <algorithm>
 
-#include <AVSCommon/SDKInterfaces/AudioFocusAnnotation.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 #include "AFML/FocusManager.h"
@@ -47,19 +46,57 @@ static const std::string CHANNEL_PRIORITY_KEY = "priority";
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
+std::shared_ptr<FocusManager> FocusManager::create(
+    const std::vector<ChannelConfiguration>& channelConfigurations,
+    std::shared_ptr<ActivityTrackerInterface> activityTrackerInterface,
+    const std::vector<ChannelConfiguration>& virtualChannelConfigurations,
+    std::shared_ptr<interruptModel::InterruptModel> interruptModel,
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface> externalFocusMediator) {
+    auto focusManager = std::shared_ptr<FocusManager>(new FocusManager(
+        channelConfigurations,
+        std::move(activityTrackerInterface),
+        virtualChannelConfigurations,
+        std::move(interruptModel),
+        std::move(externalFocusMediator)));
+
+    if (!focusManager->initialize()) {
+        ACSDK_ERROR(LX(__func__).d("reason", "initialize failed"));
+        return nullptr;
+    }
+
+    return focusManager;
+}
+
 FocusManager::FocusManager(
     const std::vector<ChannelConfiguration>& channelConfigurations,
     std::shared_ptr<ActivityTrackerInterface> activityTrackerInterface,
     const std::vector<ChannelConfiguration>& virtualChannelConfigurations,
-    std::shared_ptr<InterruptModel> interruptModel) :
+    std::shared_ptr<InterruptModel> interruptModel,
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface> externalFocusMediator) :
         m_activityTracker{activityTrackerInterface},
-        m_interruptModel{interruptModel} {
-    // Read AVS channel configurations.
+        m_interruptModel{interruptModel},
+        m_externalFocusMediator{externalFocusMediator} {
     readChannelConfiguration(channelConfigurations, false);
-    // Read virtual channel configurations.
     readChannelConfiguration(virtualChannelConfigurations, true);
 }
 
+bool FocusManager::initialize() {
+    // TODO: Create Stub/Default for External Focus Mediator logic in AFML
+    if (m_externalFocusMediator) {
+        ACSDK_DEBUG5(LX(__func__).m("ExternalFocusMediator enabled"));
+        std::vector<ExternalFocusMediatorInterface::CallbackChannelConfiguration> callbackChannelConfigurations;
+        for (const auto& channel : m_allChannels) {
+            callbackChannelConfigurations.emplace_back(ExternalFocusMediatorInterface::CallbackChannelConfiguration(
+                channel.first, channel.second->getPriority()));
+        }
+        if (!m_externalFocusMediator->initialize(shared_from_this(), callbackChannelConfigurations)) {
+            ACSDK_ERROR(LX(__func__).m("Unable to initialize External Focus Mediator"));
+            return false;
+        }
+    }
+    return true;
+}
+
 bool FocusManager::acquireChannel(
     const std::string& channelName,
     std::shared_ptr<ChannelObserverInterface> channelObserver,
@@ -77,9 +114,7 @@ bool FocusManager::acquireChannel(
         return false;
     }
 
-    m_executor.submit(
-        [this, channelToAcquire, channelActivity]() { acquireChannelHelper(channelToAcquire, channelActivity); });
-    return true;
+    return acquireChannel(channelName, channelActivity);
 }
 
 bool FocusManager::acquireChannel(
@@ -97,8 +132,79 @@ bool FocusManager::acquireChannel(
         return false;
     }
 
-    m_executor.submit(
-        [this, channelToAcquire, channelActivity]() { acquireChannelHelper(channelToAcquire, channelActivity); });
+    auto isChannelInactiveOrKickoutPrimaryActivity = false;
+    if (!channelToAcquire->isActive()) {
+        isChannelInactiveOrKickoutPrimaryActivity = true;
+    }
+    if (channelToAcquire->isActive() && channelActivity->getPatienceDuration() == std::chrono::milliseconds::zero()) {
+        isChannelInactiveOrKickoutPrimaryActivity = true;
+    }
+
+    // TODO: Create Stub/Default for External Focus Mediator logic in AFML
+    if (m_externalFocusMediator && isChannelInactiveOrKickoutPrimaryActivity) {
+        auto focusRequestMetadata = FocusRequest::FocusRequestMetadata(
+            channelName,
+            channelToAcquire->getPriority(),
+            channelActivity->getAudioAttributes(),
+            channelActivity->getPatienceDuration(),
+            channelActivity->getContentType());
+        auto focusRequest = FocusRequest(channelName, focusRequestMetadata);
+        auto promise = m_externalFocusMediator->acquireFocus(focusRequest);
+
+        auto onSuccess = [this, channelToAcquire, channelActivity](
+                             const ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus& externalFocus) {
+            ACSDK_DEBUG1(LX("acquireChannel")
+                             .d("promiseFulfilled", "SUCCESS")
+                             .d("externalFocusState", externalFocus.externalFocusState)
+                             .d("externalMixingBehavior", externalFocus.externalMixingBehavior));
+
+            FocusState focusState;
+            if (!externalFocusStateToFocusState(externalFocus.externalFocusState, focusState)) {
+                ACSDK_ERROR(LX("acquireChannelFailed")
+                                .d("externalFocusStateToFocusStateError", "Cannot be converted to FocusState")
+                                .d("externalFocusState", externalFocus.externalFocusState));
+                setChannelFocus(channelToAcquire, FocusState::NONE, MixingBehavior::MUST_STOP, true);
+                // If no activities are present in the channel, explicitly notify the observer of the update.
+                if (!channelToAcquire->isActive()) {
+                    channelActivity->notifyObserver(FocusState::NONE, MixingBehavior::MUST_STOP);
+                }
+                notifyActivityTracker();
+                return;
+            }
+
+            MixingBehavior mixingBehavior;
+            if (!externalMixingBehaviorToMixingBehavior(externalFocus.externalMixingBehavior, mixingBehavior)) {
+                ACSDK_ERROR(
+                    LX("acquireChannelFailed")
+                        .d("externalMixingBehaviorToMixingBehaviorError", "Cannot be converted to MixingBehavior")
+                        .d("ExternalMixingBehavior", externalFocus.externalMixingBehavior));
+                setChannelFocus(channelToAcquire, FocusState::NONE, MixingBehavior::MUST_STOP, true);
+                // If no activities are present in the channel, explicitly notify the observer of the update.
+                if (!channelToAcquire->isActive()) {
+                    channelActivity->notifyObserver(FocusState::NONE, MixingBehavior::MUST_STOP);
+                }
+                notifyActivityTracker();
+                return;
+            }
+            acquireChannelHelper(channelToAcquire, channelActivity, focusState, mixingBehavior);
+        };
+
+        auto onError = [this, channelToAcquire, channelActivity](const std::error_condition& error) {
+            ACSDK_ERROR(LX("acquireChannel").d("promiseRejected", error.message()));
+            setChannelFocus(channelToAcquire, FocusState::NONE, MixingBehavior::MUST_STOP, true);
+            // If no activities are present in the channel, explicitly notify the observer of the update.
+            if (!channelToAcquire->isActive()) {
+                channelActivity->notifyObserver(FocusState::NONE, MixingBehavior::MUST_STOP);
+            }
+            notifyActivityTracker();
+        };
+
+        promise.finally(m_executor, onSuccess, onError);
+    } else {
+        m_executor.execute(
+            [this, channelToAcquire, channelActivity]() { acquireChannelHelper(channelToAcquire, channelActivity); });
+    }
+
     return true;
 }
 
@@ -117,27 +223,26 @@ std::future<bool> FocusManager::releaseChannel(
         return returnValue;
     }
 
-    m_executor.submit([this, channelToRelease, channelObserver, releaseChannelSuccess, channelName]() {
-        releaseChannelHelper(channelToRelease, channelObserver, releaseChannelSuccess, channelName);
+    m_executor.execute([this, channelToRelease, channelObserver, releaseChannelSuccess]() {
+        releaseChannelHelper(channelToRelease, channelObserver, releaseChannelSuccess);
     });
 
     return returnValue;
 }
 
 void FocusManager::stopForegroundActivity() {
-    // We lock these variables so that we can correctly capture the currently foregrounded channel and activity.
     std::unique_lock<std::mutex> lock(m_mutex);
-    std::shared_ptr<Channel> foregroundChannel = getHighestPriorityActiveChannelLocked();
-    if (!foregroundChannel) {
+    std::shared_ptr<Channel> highestPriorityActiveChannel = getHighestPriorityActiveChannelLocked();
+    if (!highestPriorityActiveChannel) {
         ACSDK_DEBUG(LX("stopForegroundActivityFailed").d("reason", "noForegroundActivity"));
         return;
     }
 
-    std::string foregroundChannelInterface = foregroundChannel->getInterface();
+    std::string highestPriorityActiveChannelInterface = highestPriorityActiveChannel->getInterface();
     lock.unlock();
 
-    m_executor.submitToFront([this, foregroundChannel, foregroundChannelInterface]() {
-        stopForegroundActivityHelper(foregroundChannel, foregroundChannelInterface);
+    m_executor.submitToFront([this, highestPriorityActiveChannel, highestPriorityActiveChannelInterface]() {
+        stopForegroundActivityHelper(highestPriorityActiveChannel, highestPriorityActiveChannelInterface);
     });
 }
 
@@ -173,6 +278,102 @@ void FocusManager::removeObserver(const std::shared_ptr<FocusManagerObserverInte
     m_observers.erase(observer);
 }
 
+std::unordered_map<std::string, ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus> FocusManager::
+    getActiveChannelStates() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    std::unordered_map<std::string, ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>
+        activeChannelStateMap;
+    auto activeChannels = m_activeChannels;
+    auto foregroundChannel = getHighestPriorityActiveChannelLocked();
+
+    for (const auto& channel : activeChannels) {
+        ExternalFocusState externalFocusState;
+        if (!externalFocusStateFromFocusState(channel->getState().focusState, externalFocusState)) {
+            ACSDK_ERROR(LX(__func__)
+                            .d("externalFocusStateFromStateError", "Cannot be converted to ExternalFocusState")
+                            .d("focusState", channel->getState().focusState));
+            activeChannelStateMap.clear();
+            return activeChannelStateMap;
+        }
+
+        auto mixingBehavior = getMixingBehavior(channel, foregroundChannel);
+        ExternalMixingBehavior externalMixingBehavior;
+        if (!externalMixingBehaviorFromMixingBehavior(mixingBehavior, externalMixingBehavior)) {
+            ACSDK_WARN(LX(__func__)
+                           .d("externalMixingBehaviorFromMixingBehaviorWarning",
+                              "Cannot be converted to ExternalMixingBehavior")
+                           .d("MixingBehavior", mixingBehavior)
+                           .d("externalMixingBehaviorFallback", externalMixingBehavior));
+        }
+
+        activeChannelStateMap.insert({channel->getName(),
+                                      ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                                          externalFocusState, externalMixingBehavior)});
+    }
+
+    return activeChannelStateMap;
+}
+
+avsCommon::utils::threading::Promise<void> FocusManager::changeFocusState(
+    const std::string& focusRequestId,
+    const ExternalFocusMediatorFocus& externalFocus) {
+    ACSDK_DEBUG5(LX(__func__).d("focusRequestId", focusRequestId));
+    auto channel = getChannel(focusRequestId);
+    if (!channel) {
+        ACSDK_ERROR(LX(__func__).d("reason", "channelNotFound").d("focusRequestId", focusRequestId));
+        return avsCommon::utils::threading::Promise<void>::reject(std::errc::invalid_argument);
+    }
+
+    if (!channel->isActive()) {
+        ACSDK_ERROR(LX(__func__).d("reason", "channelNotActive").d("focusRequestId", focusRequestId));
+        return avsCommon::utils::threading::Promise<void>::reject(std::errc::invalid_argument);
+    }
+
+    FocusState focusState;
+    if (!externalFocusStateToFocusState(externalFocus.externalFocusState, focusState)) {
+        ACSDK_ERROR(LX(__func__)
+                        .d("externalFocusStateToStateError", "Cannot be converted to FocusState")
+                        .d("externalFocusState", externalFocus.externalFocusState));
+        return avsCommon::utils::threading::Promise<void>::reject(std::errc::invalid_argument);
+    }
+
+    MixingBehavior mixingBehavior;
+    if (!externalMixingBehaviorToMixingBehavior(externalFocus.externalMixingBehavior, mixingBehavior)) {
+        ACSDK_ERROR(LX(__func__)
+                        .d("externalMixingBehaviorToMixingBehaviorError", "Cannot be converted to MixingBehavior")
+                        .d("ExternalMixingBehavior", externalFocus.externalMixingBehavior));
+        return avsCommon::utils::threading::Promise<void>::reject(std::errc::invalid_argument);
+    }
+
+    return avsCommon::utils::threading::Promise<void>{
+        m_executor,
+        [this, channel, focusState, mixingBehavior](avsCommon::utils::threading::PromiseResolver<void> resolver) {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            auto highestPriorityChannel = getHighestPriorityActiveChannelLocked();
+            lock.unlock();
+            updateFocusStateHelper(channel, highestPriorityChannel, focusState, mixingBehavior);
+            resolver.resolve();
+        }};
+}
+
+avsCommon::utils::threading::Promise<void> FocusManager::mediatorReleaseFocus(const std::string& focusRequestId) {
+    ACSDK_DEBUG5(LX(__func__).d("focusRequestId", focusRequestId));
+    auto channelToRelease = getChannel(focusRequestId);
+    if (!channelToRelease) {
+        ACSDK_ERROR(LX(__func__).d("reason", "channelNotFound").d("focusRequestId", focusRequestId));
+        return avsCommon::utils::threading::Promise<void>::reject(std::errc::invalid_argument);
+    }
+
+    return avsCommon::utils::threading::Promise<void>{
+        m_executor, [this, channelToRelease](avsCommon::utils::threading::PromiseResolver<void> resolver) {
+            if (releaseFocusHelper(channelToRelease)) {
+                resolver.resolve();
+            } else {
+                resolver.reject(std::errc::operation_canceled);
+            }
+        }};
+}
+
 void FocusManager::readChannelConfiguration(
     const std::vector<ChannelConfiguration>& channelConfigurations,
     bool isVirtual) {
@@ -257,11 +458,11 @@ MixingBehavior FocusManager::getMixingBehavior(
 
 void FocusManager::acquireChannelHelper(
     std::shared_ptr<Channel> channelToAcquire,
-    std::shared_ptr<FocusManagerInterface::Activity> channelActivity) {
-    // Lock here to update internal state which stopForegroundActivity may concurrently access.
+    std::shared_ptr<FocusManagerInterface::Activity> channelActivity,
+    FocusState focusState,
+    MixingBehavior mixingBehavior) {
     std::unique_lock<std::mutex> lock(m_mutex);
-    std::shared_ptr<Channel> foregroundChannel = getHighestPriorityActiveChannelLocked();
-    // insert the incoming channel
+    std::shared_ptr<Channel> highestPriorityChannel = getHighestPriorityActiveChannelLocked();
     m_activeChannels.insert(channelToAcquire);
     lock.unlock();
 
@@ -269,87 +470,163 @@ void FocusManager::acquireChannelHelper(
                      .d("incomingChannel", channelToAcquire->getName())
                      .d("incomingInterface", channelActivity->getInterface()));
 
-    // attach Activity to the Channel
     channelToAcquire->setPrimaryActivity(std::move(channelActivity));
+    updateFocusStateHelper(channelToAcquire, highestPriorityChannel, focusState, mixingBehavior);
+}
+
+void FocusManager::updateFocusStateHelper(
+    std::shared_ptr<Channel> channel,
+    std::shared_ptr<Channel> highestPriorityChannel,
+    avsCommon::avs::FocusState focusState,
+    avsCommon::avs::MixingBehavior mixingBehavior) {
+    ACSDK_DEBUG5(LX(__func__)
+                     .d("channel", channel->getName())
+                     .d("incomingFocusState", focusState)
+                     .d("incomingMixingBehavior", mixingBehavior));
+
+    if (focusState == FocusState::FOREGROUND) {
+        mixingBehavior = MixingBehavior::PRIMARY;
+    }
+
+    if (m_externalFocusMediator) {
+        if (FocusState::BACKGROUND == focusState && MixingBehavior::MUST_PAUSE != mixingBehavior) {
+            mixingBehavior = getMixingBehavior(channel, highestPriorityChannel);
+            if (MixingBehavior::UNDEFINED == mixingBehavior) {
+                mixingBehavior = MixingBehavior::MAY_DUCK;
+            }
+        }
+    }
 
-    if (!foregroundChannel) {
+    if (!highestPriorityChannel) {
         // channelToAcquire is the only active channel
-        setChannelFocus(channelToAcquire, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
-    } else if (foregroundChannel == channelToAcquire) {
-        // acquireChannel request is for the same channel as the current foreground channel
-        // NOTE : the primaryActivity interface may change , even though focus state has not changed for the channel
-        setChannelFocus(channelToAcquire, FocusState::FOREGROUND, MixingBehavior::PRIMARY, true);
-    } else if (*channelToAcquire > *foregroundChannel) {
-        // channelToAcquire will now become the foreground channel, other channels shall be backgrounded
-        // For each background channel : consult interrupt model to determine the mixability
-        setBackgroundChannelMixingBehavior(channelToAcquire);
-
-        // set channelToAcquire as Foreground
-        setChannelFocus(channelToAcquire, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+        // NOTE: The External Focus Mediator may return BACKGROUND focus.
+        setChannelFocus(channel, focusState, mixingBehavior);
+    } else if (highestPriorityChannel == channel) {
+        // acquireChannel request is for the same channel as the current foreground channel.
+        // NOTE: the primaryActivity interface may change, even though focus state has not changed for the channel.
+        setChannelFocus(channel, focusState, mixingBehavior, true);
+    } else if (*channel > *highestPriorityChannel) {
+        // channelToAcquire will now become the FOREGROUND/BACKGROUND channel, other channels shall be set BACKGROUND
+        // focus. For each BACKGROUND channel: consult interrupt model to determine the mixability.
+        setBackgroundChannelMixingBehavior(channel);
+        setChannelFocus(channel, focusState, mixingBehavior);
     } else {
-        // channelToAcquire is to be backgrounded
-        auto mixingBehavior = getMixingBehavior(channelToAcquire, foregroundChannel);
-        setChannelFocus(channelToAcquire, FocusState::BACKGROUND, mixingBehavior);
+        // channelToAcquire is to be set BACKGROUND focus.
+        // Must respect the policy, so even if the External Focus Mediator grants FOREGROUND focus, we must still set
+        // the focus to BACKGROUND. Consult the interrupt model to determine the mixability, since it would not be
+        // provided.
+        if (!m_externalFocusMediator || focusState == FocusState::FOREGROUND) {
+            mixingBehavior = getMixingBehavior(channel, highestPriorityChannel);
+        }
+        setChannelFocus(channel, FocusState::BACKGROUND, mixingBehavior);
     }
-
     notifyActivityTracker();
 }
 
 void FocusManager::releaseChannelHelper(
     std::shared_ptr<Channel> channelToRelease,
     std::shared_ptr<ChannelObserverInterface> channelObserver,
-    std::shared_ptr<std::promise<bool>> releaseChannelSuccess,
-    const std::string& name) {
+    std::shared_ptr<std::promise<bool>> releaseChannelSuccess) {
     ACSDK_DEBUG5(LX(__func__).d("channelToRelease", channelToRelease->getName()));
-
     bool success = channelToRelease->releaseActivity(std::move(channelObserver));
     releaseChannelSuccess->set_value(success);
 
     if (!success) {
         ACSDK_ERROR(LX(__func__)
                         .d("reason", "releaseActivityFailed")
-                        .d("channel", channelToRelease)
+                        .d("channel", channelToRelease->getName())
                         .d("interface", channelToRelease->getInterface()));
         return;
     }
 
-    // Only release and set entire channel focus to NONE if there are no active Activity remaining.
-    if (!channelToRelease->isActive()) {
-        // Lock here to update internal state which stopForegroundActivity may concurrently access.
-        std::unique_lock<std::mutex> lock(m_mutex);
-        m_activeChannels.erase(channelToRelease);
-        lock.unlock();
-        setChannelFocus(channelToRelease, FocusState::NONE, MixingBehavior::MUST_STOP);
+    // Do not FOREGROUND the next highest priority active channel if external focus mediator is enabled.
+    // When the external focus mediator is enabled, only multi-activity channels are auto-promoted if they are the
+    // highest priority channel and previously held FOREGROUND focus. Otherwise, it is expected that the external focus
+    // mediator will signal that a channel must be set to FOREGROUND.
+    // TODO: Create Stub/Default for External Focus Mediator logic in AFML
+    if (m_externalFocusMediator) {
+        if (!channelToRelease->isActive()) {
+            cleanupChannel(channelToRelease);
+            m_externalFocusMediator->onFocusRelease(channelToRelease->getName());
+        } else {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            auto isChannelHighestPriority = isChannelHighestPriorityActiveChannelLocked(channelToRelease);
+            lock.unlock();
+            auto prevFocusState = channelToRelease->getState().focusState;
+            if (prevFocusState == FocusState::FOREGROUND && isChannelHighestPriority) {
+                foregroundHighestPriorityActiveChannel();
+            }
+        }
+    } else {
+        if (!channelToRelease->isActive()) {
+            cleanupChannel(channelToRelease);
+        }
+        foregroundHighestPriorityActiveChannel();
     }
-    foregroundHighestPriorityActiveChannel();
     notifyActivityTracker();
 }
 
+bool FocusManager::releaseFocusHelper(const std::shared_ptr<Channel>& channelToRelease) {
+    ACSDK_DEBUG5(LX(__func__).d("channelToRelease", channelToRelease->getName()));
+    if (!channelToRelease->releaseActivity(std::move(channelToRelease->getInterface()))) {
+        ACSDK_ERROR(LX(__func__)
+                        .d("reason", "releaseActivityFailed")
+                        .d("channel", channelToRelease)
+                        .d("interface", channelToRelease->getInterface()));
+        return false;
+    }
+    cleanupChannel(channelToRelease);
+    notifyActivityTracker();
+    return true;
+}
+
+void FocusManager::cleanupChannel(const std::shared_ptr<Channel>& channel) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    m_activeChannels.erase(channel);
+    lock.unlock();
+    setChannelFocus(channel, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
 void FocusManager::stopForegroundActivityHelper(
     std::shared_ptr<Channel> foregroundChannel,
     std::string foregroundChannelInterface) {
     if (foregroundChannelInterface != foregroundChannel->getInterface()) {
         return;
     }
+
     ACSDK_DEBUG5(LX(__func__).d("interface", foregroundChannelInterface));
-    bool success = foregroundChannel->releaseActivity(foregroundChannel->getInterface());
+    bool success = foregroundChannel->releaseActivity(foregroundChannelInterface);
     if (!success) {
         ACSDK_ERROR(LX(__func__)
                         .d("reason", "releaseActivityFailed")
-                        .d("channel", foregroundChannel)
+                        .d("channel", foregroundChannel->getName())
                         .d("interface", foregroundChannel->getInterface()));
     }
 
-    // Only release and set entire channel focus to NONE if there are no active Activity remaining.
-    if (!foregroundChannel->isActive()) {
-        ACSDK_DEBUG1(LX(__func__).m("Channel is not active ... releasing"));
-        // Lock here to update internal state which stopForegroundActivity may concurrently access.
-        std::unique_lock<std::mutex> lock(m_mutex);
-        m_activeChannels.erase(foregroundChannel);
-        lock.unlock();
-        setChannelFocus(foregroundChannel, FocusState::NONE, MixingBehavior::MUST_STOP);
+    // Do not FOREGROUND the next highest priority active channel if external focus mediator is enabled.
+    // When the external focus mediator is enabled, only multi-activity channels are auto-promoted if they are the
+    // highest priority channel and previously held FOREGROUND focus. Otherwise, it is expected that the external focus
+    // mediator will signal that a channel must be set to FOREGROUND.
+    // TODO: Create Stub/Default for External Focus Mediator logic in AFML
+    if (m_externalFocusMediator) {
+        if (!foregroundChannel->isActive()) {
+            cleanupChannel(foregroundChannel);
+            m_externalFocusMediator->onFocusRelease(foregroundChannel->getName());
+        } else {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            auto isChannelHighestPriority = isChannelHighestPriorityActiveChannelLocked(foregroundChannel);
+            lock.unlock();
+            auto prevFocusState = foregroundChannel->getState().focusState;
+            if (prevFocusState == FocusState::FOREGROUND && isChannelHighestPriority) {
+                foregroundHighestPriorityActiveChannel();
+            }
+        }
+    } else {
+        if (!foregroundChannel->isActive()) {
+            cleanupChannel(foregroundChannel);
+        }
+        foregroundHighestPriorityActiveChannel();
     }
-    foregroundHighestPriorityActiveChannel();
     notifyActivityTracker();
 }
 
@@ -376,16 +653,31 @@ void FocusManager::stopAllActivitiesHelper(const ChannelsToInterfaceNamesMap& ch
     lock.unlock();
 
     for (const auto& channel : channelsToClear) {
-        // Only release and set entire channel focus to NONE if there are no active Activity remaining.
-        if (!channel->isActive()) {
-            // Lock here to update internal state which stopForegroundActivity may concurrently access.
-            std::unique_lock<std::mutex> lock(m_mutex);
-            m_activeChannels.erase(channel);
-            lock.unlock();
-            setChannelFocus(channel, FocusState::NONE, MixingBehavior::MUST_STOP);
+        // Do not FOREGROUND the next highest priority active channel if external focus mediator is enabled.
+        // When the external focus mediator is enabled, only multi-activity channels are auto-promoted if they are the
+        // highest priority channel and previously held FOREGROUND focus. Otherwise, it is expected that the external
+        // focus mediator will signal that a channel must be set to FOREGROUND.
+        // TODO: Create Stub/Default for External Focus Mediator logic in AFML
+        if (m_externalFocusMediator) {
+            if (!channel->isActive()) {
+                cleanupChannel(channel);
+                m_externalFocusMediator->onFocusRelease(channel->getName());
+            } else {
+                lock.lock();
+                auto isChannelHighestPriority = isChannelHighestPriorityActiveChannelLocked(channel);
+                lock.unlock();
+                auto prevFocusState = channel->getState().focusState;
+                if (prevFocusState == FocusState::FOREGROUND && isChannelHighestPriority) {
+                    foregroundHighestPriorityActiveChannel();
+                }
+            }
+        } else {
+            if (!channel->isActive()) {
+                cleanupChannel(channel);
+            }
+            foregroundHighestPriorityActiveChannel();
         }
     }
-    foregroundHighestPriorityActiveChannel();
     notifyActivityTracker();
 }
 
@@ -404,7 +696,7 @@ std::shared_ptr<Channel> FocusManager::getHighestPriorityActiveChannelLocked() c
     return *m_activeChannels.begin();
 }
 
-bool FocusManager::isChannelForegroundedLocked(const std::shared_ptr<Channel>& channel) const {
+bool FocusManager::isChannelHighestPriorityActiveChannelLocked(const std::shared_ptr<Channel>& channel) const {
     return getHighestPriorityActiveChannelLocked() == channel;
 }
 
@@ -425,14 +717,12 @@ void FocusManager::modifyContentType(
     const std::string& channelName,
     const std::string& interfaceName,
     ContentType contentType) {
-    // find the channel
     auto channel = getChannel(channelName);
     if (!channel) {
         ACSDK_ERROR(LX("modifyContentTypeFailed").d("reason", "channelNotFound").d("channel", channelName));
         return;
     }
 
-    // find the activity associated with the interfacename in the channel
     auto activity = channel->getActivity(interfaceName);
     if (!activity) {
         ACSDK_ERROR(LX("modifyContentTypeFailed").d("no activity found associated with interfaceName", interfaceName));
@@ -444,10 +734,8 @@ void FocusManager::modifyContentType(
         return;
     }
 
-    // modify the contentType associated with the activity
     activity->setContentType(contentType);
 
-    // reconsult the InterruptModel and set the new MixingBehaviors for all backgrounded channelobservers
     std::unique_lock<std::mutex> lock(m_mutex);
     std::shared_ptr<Channel> foregroundChannel = getHighestPriorityActiveChannelLocked();
     lock.unlock();
@@ -467,7 +755,6 @@ void FocusManager::setBackgroundChannelMixingBehavior(std::shared_ptr<Channel> f
     channelIter++;
 
     for (; channelIter != m_activeChannels.end(); channelIter++) {
-        // determine mixingBehavior for each background channel
         auto mixingBehavior = getMixingBehavior(*channelIter, foregroundChannel);
         lock.unlock();
         setChannelFocus(*channelIter, FocusState::BACKGROUND, mixingBehavior);
diff --git a/AFML/src/VisualActivityTracker.cpp b/AFML/src/VisualActivityTracker.cpp
index bf12c73f..e121a442 100644
--- a/AFML/src/VisualActivityTracker.cpp
+++ b/AFML/src/VisualActivityTracker.cpp
@@ -110,7 +110,7 @@ void VisualActivityTracker::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     unsigned int stateRequestToken) {
     ACSDK_DEBUG5(LX("provideState"));
-    m_executor.submit([this, stateRequestToken]() { executeProvideState(stateRequestToken); });
+    m_executor.execute([this, stateRequestToken]() { executeProvideState(stateRequestToken); });
 }
 
 void VisualActivityTracker::notifyOfActivityUpdates(const std::vector<Channel::State>& channels) {
@@ -132,7 +132,7 @@ void VisualActivityTracker::notifyOfActivityUpdates(const std::vector<Channel::S
         }
     }
 
-    m_executor.submit([this, channels]() {
+    m_executor.execute([this, channels]() {
         // The last element of the vector is the most recent channel state.
         m_channelState = channels.back();
     });
diff --git a/AFML/test/FocusManagerTest.cpp b/AFML/test/FocusManagerTest.cpp
index 7ba88599..c5446d2a 100644
--- a/AFML/test/FocusManagerTest.cpp
+++ b/AFML/test/FocusManagerTest.cpp
@@ -13,25 +13,36 @@
  * permissions and limitations under the License.
  */
 
+#include <chrono>
+#include <iostream>
 #include <memory>
+#include <mutex>
+#include <string>
+#include <vector>
+
 #include <gtest/gtest.h>
 
+#include <AVSCommon/AVS/AudioAttributes.h>
 #include <AVSCommon/AVS/FocusState.h>
+#include <AVSCommon/AVS/MixingBehavior.h>
+#include <AVSCommon/SDKInterfaces/MockExternalFocusMediator.h>
 #include <AVSCommon/SDKInterfaces/MockFocusManagerObserver.h>
 #include <AVSCommon/Utils/Configuration/ConfigurationNode.h>
-#include "AFML/FocusManager.h"
 
+#include "AFML/FocusManager.h"
 #include "InterruptModel/InterruptModel.h"
 
 namespace alexaClientSDK {
 namespace afml {
 namespace test {
 
+using namespace alexaClientSDK::avsCommon::utils::configuration;
+using namespace avsCommon::avs;
 using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::sdkInterfaces::test;
-using namespace avsCommon::avs;
-using namespace alexaClientSDK::avsCommon::utils::configuration;
-/// Alias for JSON stream type used in @c ConfigurationNode initialization
+using namespace ::testing;
+
+/// Alias for JSON stream type used in @c ConfigurationNode initialization.
 using JSONStream = std::vector<std::shared_ptr<std::istream>>;
 
 /// Short time out for when callbacks are expected not to occur.
@@ -43,6 +54,12 @@ static const auto DEFAULT_TIMEOUT = std::chrono::seconds(15);
 /// Time out to wait for ActivityUpdates.
 static const auto NO_ACTIVITY_UPDATE_TIMEOUT = std::chrono::milliseconds(250);
 
+/// Time out for patience duration on an activity.
+static const auto PATIENCE_DURATION_TIMEOUT = std::chrono::seconds(5);
+
+/// Time out to wait for a Promise. (This should never be reached)
+static const auto PROMISE_TIMOUT = std::chrono::seconds(30);
+
 /// The dialog Channel name used in initializing the FocusManager.
 static const std::string DIALOG_CHANNEL_NAME = "Dialog";
 
@@ -88,129 +105,129 @@ static const std::string DIFFERENT_DIALOG_INTERFACE_NAME = "different dialog";
 /// Sample Virtual Channel interface name.
 static const std::string VIRTUAL_INTERFACE_NAME = "virtual";
 
-/// The root key for the InterruptModel in the @c InterruptModelConfiguration
+/// The root key for the InterruptModel in the @c InterruptModelConfiguration.
 static const std::string INTERRUPT_MODEL_ROOT_KEY = "interruptModel";
 
-/// The Json that describes the InterruptModelConfiguration
+/// The Json that describes the InterruptModelConfiguration.
 static const std::string INTERRUPT_MODEL_CONFIG_JSON = R"({
 "interruptModel" : {
-                "Dialog" : {
-                },
-                "Communications" : {
-                    "contentType":
-                    {
-                        "MIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                }
-                            }
-                        },
-                        "NONMIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_PAUSE"
-                                    }
-                                }
-                            }
-                        }
-                    }
-                },
-                "Alert" : {
-                    "contentType" :
-                    {
-                        "MIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                      "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                },
-                                "Communications" : {
-                                      "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK",
-                                        "NONMIXABLE" : "MAY_DUCK"
-                                    }
-                                }
-                            }
-                        }
-                    }
-                },
-                "VirtualChannel" : {
-                    "contentType" :
-                    {
-                        "MIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                      "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                },
-                                "Communications" : {
-                                      "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK",
-                                        "NONMIXABLE" : "MAY_DUCK"
-                                    }
-                                }
-                            }
-                        }
-                    }
-                },
-                "Content" : {
-                    "contentType" :
-                    {
-                        "MIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                },
-                                "Communications" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK",
-                                        "NONMIXABLE" : "MUST_PAUSE"
-                                    }
-                                },
-                                "Alert" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                },
-                                "VirtualChannel" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MAY_DUCK"
-                                    }
-                                }
-                            }
-                        },
-                        "NONMIXABLE" : {
-                            "incomingChannel" : {
-                                "Dialog" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MUST_PAUSE"
-                                    }
-                                },
-                                "Communications" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MUST_PAUSE",
-                                        "NONMIXABLE" : "MUST_PAUSE"
-                                    }
-                                },
-                                "Alert" : {
-                                    "incomingContentType" : {
-                                        "MIXABLE" : "MUST_PAUSE"
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-    }
+               "Dialog" : {
+               },
+               "Communications" : {
+                   "contentType":
+                   {
+                       "MIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               }
+                           }
+                       },
+                       "NONMIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_PAUSE"
+                                   }
+                               }
+                           }
+                       }
+                   }
+               },
+               "Alert" : {
+                   "contentType" :
+                   {
+                       "MIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                     "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               },
+                               "Communications" : {
+                                     "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK",
+                                       "NONMIXABLE" : "MAY_DUCK"
+                                   }
+                               }
+                           }
+                       }
+                   }
+               },
+               "VirtualChannel" : {
+                   "contentType" :
+                   {
+                       "MIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                     "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               },
+                               "Communications" : {
+                                     "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK",
+                                       "NONMIXABLE" : "MAY_DUCK"
+                                   }
+                               }
+                           }
+                       }
+                   }
+               },
+               "Content" : {
+                   "contentType" :
+                   {
+                       "MIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               },
+                               "Communications" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK",
+                                       "NONMIXABLE" : "MUST_PAUSE"
+                                   }
+                               },
+                               "Alert" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               },
+                               "VirtualChannel" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MAY_DUCK"
+                                   }
+                               }
+                           }
+                       },
+                       "NONMIXABLE" : {
+                           "incomingChannel" : {
+                               "Dialog" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MUST_PAUSE"
+                                   }
+                               },
+                               "Communications" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MUST_PAUSE",
+                                       "NONMIXABLE" : "MUST_PAUSE"
+                                   }
+                               },
+                               "Alert" : {
+                                   "incomingContentType" : {
+                                       "MIXABLE" : "MUST_PAUSE"
+                                   }
+                               }
+                           }
+                       }
+                   }
+               }
+           }
+   }
 )";
 
 /// A test observer that mocks out the ChannelObserverInterface##onFocusChanged() call.
@@ -221,29 +238,34 @@ public:
     /**
      * Constructor.
      */
-    TestClient(const std::string& channelName, const std::string& interfaceName) :
-            m_channelName(channelName),
-            m_interfaceName(interfaceName),
-            m_focusState(FocusState::NONE),
-            m_mixingBehavior(MixingBehavior::UNDEFINED),
-            m_focusChangeCallbackInvoked(false),
-            m_mixingBehaviorChanged(false) {
-    }
+    TestClient(const std::string& channelName, const std::string& interfaceName);
 
+    /**
+     * Constructs a new Activity object.
+     *
+     * @param contentType The Activity's Content Type.
+     * @param patience The Activity's Patience Duration.
+     * @param audioAttributes The Activity's Audio Attributes.
+     * @return The new Activity, otherwise a @c nullptr if the operation failed.
+     */
     std::shared_ptr<FocusManagerInterface::Activity> createActivity(
         ContentType contentType = ContentType::NONMIXABLE,
-        std::chrono::milliseconds patience = std::chrono::milliseconds(0)) {
-        m_contentType = contentType;
-        return FocusManagerInterface::Activity::create(m_interfaceName, shared_from_this(), patience, contentType);
-    }
+        std::chrono::milliseconds patience = std::chrono::milliseconds(0),
+        AudioAttributes audioAttributes = {AudioAttributes::Usage::UNKNOWN});
 
-    const std::string& getChannelName() const {
-        return m_channelName;
-    }
+    /**
+     * Fetches the Channel name.
+     *
+     * @return The TestClient's Channel name.
+     */
+    const std::string& getChannelName() const;
 
-    const std::string& getInterfaceName() const {
-        return m_interfaceName;
-    }
+    /**
+     * Fetches the Interface name.
+     *
+     * @return The TestClient's Channel name.
+     */
+    const std::string& getInterfaceName() const;
 
     /**
      * Implementation of the ChannelObserverInterface##onFocusChanged() callback.
@@ -251,47 +273,62 @@ public:
      * @param focusState The new focus state of the Channel observer.
      * @param behavior The new MixingBehavior of the Channel observer.
      */
-    void onFocusChanged(FocusState focusState, MixingBehavior behavior) override {
-        std::unique_lock<std::mutex> lock(m_mutex);
-        m_focusState = focusState;
-        m_mixingBehaviorChanged = (m_mixingBehavior != behavior);
-        m_mixingBehavior = behavior;
-        m_focusChangeCallbackInvoked = true;
-        m_focusChanged.notify_one();
-    }
+    void onFocusChanged(FocusState focusState, MixingBehavior behavior) override;
 
-    struct testClientInfo {
-        FocusState focusState;
-        MixingBehavior mixingBehavior;
-        bool focusChanged;
-        bool mixingBehaviorChanged;
-        testClientInfo(FocusState state, MixingBehavior behavior, bool focusChg, bool mixingBehaviorChg) :
-                focusState{state},
-                mixingBehavior{behavior},
-                focusChanged{focusChg},
-                mixingBehaviorChanged{mixingBehaviorChg} {
-        }
-        testClientInfo() :
+    /**
+     * A representation of the TestClient's information.
+     */
+    struct TestClientInfo {
+        /**
+         * Constructs a new TestClientInfo object.
+         */
+        TestClientInfo() :
                 focusState{FocusState::NONE},
                 mixingBehavior{MixingBehavior::UNDEFINED},
                 focusChanged{false},
                 mixingBehaviorChanged{false} {
         }
+
+        /**
+         * Constructs a new TestClientInfo object.
+         *
+         * @param state The TestClientInfo's Focus State.
+         * @param behavior The TestClientInfo's Mixing Behavior.
+         * @param focusChg The TestClientInfo's Focus state changed boolean.
+         * @param mixingBehaviorChg The TestClientInfo's Mixing Behavior changed boolean.
+         */
+        TestClientInfo(FocusState state, MixingBehavior behavior, bool focusChg, bool mixingBehaviorChg) :
+                focusState{state},
+                mixingBehavior{behavior},
+                focusChanged{focusChg},
+                mixingBehaviorChanged{mixingBehaviorChg} {
+        }
+
+        /// The Focus State
+        FocusState focusState;
+
+        /// The Mixing Behavior.
+        MixingBehavior mixingBehavior;
+
+        /// Indicates whether a focus state change has occurred.
+        bool focusChanged;
+
+        /// Indicates whether a mixing behavior change has occurred.
+        bool mixingBehaviorChanged;
     };
 
     /**
      * Waits for the ChannelObserverInterface##onFocusChanged() callback.
      *
      * @param timeout The amount of time to wait for the callback.
-     * @param focusChanged An output parameter that notifies the caller whether a callback occurred.
-     * @return Returns @c true if the callback occured within the timeout period and @c false otherwise.
+     * @return Returns @c TestClientInfo object representing whether focus state or mixing behavior states have changed.
      */
-    testClientInfo waitForFocusOrMixingBehaviorChange(std::chrono::milliseconds timeout) {
+    TestClientInfo waitForFocusOrMixingBehaviorChange(std::chrono::milliseconds timeout) {
         std::unique_lock<std::mutex> lock(m_mutex);
         auto success = m_focusChanged.wait_for(
             lock, timeout, [this]() { return m_focusChangeCallbackInvoked || m_mixingBehaviorChanged; });
 
-        testClientInfo ret;
+        TestClientInfo ret;
         if (!success) {
             ret.focusChanged = false;
             ret.mixingBehaviorChanged = false;
@@ -309,14 +346,16 @@ public:
     }
 
 private:
+    /// The channel name of the Activity.
     std::string m_channelName;
 
+    /// The interface name of the Activity.
     std::string m_interfaceName;
 
     /// The ContentType of the Activity.
     ContentType m_contentType;
 
-    /// The focus state of the observer.
+    /// The FocusState of the observer.
     FocusState m_focusState;
 
     /// The MixingBehavior of the observer.
@@ -331,19 +370,48 @@ private:
     /// A boolean flag so that we can re-use the observer even after a callback has occurred.
     bool m_focusChangeCallbackInvoked;
 
-    /// A re-usable boolean flag to indicate that the MixingBehavior changed
+    /// A re-usable boolean flag to indicate that the MixingBehavior changed.
     bool m_mixingBehaviorChanged;
 };
 
+TestClient::TestClient(const std::string& channelName, const std::string& interfaceName) :
+        m_channelName(channelName),
+        m_interfaceName(interfaceName),
+        m_focusState(FocusState::NONE),
+        m_mixingBehavior(MixingBehavior::UNDEFINED),
+        m_focusChangeCallbackInvoked(false),
+        m_mixingBehaviorChanged(false) {
+}
+
+std::shared_ptr<FocusManagerInterface::Activity> TestClient::createActivity(
+    ContentType contentType,
+    std::chrono::milliseconds patience,
+    AudioAttributes audioAttributes) {
+    m_contentType = contentType;
+    return FocusManagerInterface::Activity::create(
+        m_interfaceName, shared_from_this(), patience, contentType, audioAttributes);
+}
+
+const std::string& TestClient::getChannelName() const {
+    return m_channelName;
+}
+
+const std::string& TestClient::getInterfaceName() const {
+    return m_interfaceName;
+}
+
+void TestClient::onFocusChanged(FocusState focusState, MixingBehavior behavior) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    m_focusState = focusState;
+    m_mixingBehaviorChanged = (m_mixingBehavior != behavior);
+    m_mixingBehavior = behavior;
+    m_focusChangeCallbackInvoked = true;
+    m_focusChanged.notify_one();
+}
+
 /// A test observer that mocks out the ActivityTrackerInterface##notifyOfActivityUpdates() call.
 class MockActivityTrackerInterface : public ActivityTrackerInterface {
 public:
-    /**
-     * Constructor.
-     */
-    MockActivityTrackerInterface() : m_activityUpdatesOccurred{false} {
-    }
-
     /// Structure of expected Channel::State result from tests.
     struct ExpectedChannelStateResult {
         /// The expected channel name.
@@ -356,20 +424,17 @@ public:
         const FocusState focusState;
     };
 
+    /**
+     * Constructor.
+     */
+    MockActivityTrackerInterface();
+
     /**
      * Implementation of the ActivityTrackerInterface##notifyOfActivityUpdates() callback.
      *
      * @param channelStates A vector of @c Channel::State that has been updated.
      */
-    void notifyOfActivityUpdates(const std::vector<Channel::State>& channelStates) override {
-        std::unique_lock<std::mutex> lock(m_mutex);
-        m_updatedChannels.clear();
-        for (auto& channel : channelStates) {
-            m_updatedChannels[channel.interfaceName] = channel;
-        }
-        m_activityUpdatesOccurred = true;
-        m_activityChanged.notify_one();
-    }
+    void notifyOfActivityUpdates(const std::vector<Channel::State>& channelStates) override;
 
     /**
      * Waits for the ActivityTrackerInterface##notifyOfActivityUpdates() callback.
@@ -379,39 +444,14 @@ public:
      */
     void waitForActivityUpdates(
         std::chrono::milliseconds timeout,
-        const std::vector<ExpectedChannelStateResult>& expected) {
-        std::unique_lock<std::mutex> lock(m_mutex);
-        bool success = m_activityChanged.wait_for(lock, timeout, [this, &expected]() {
-            if (m_activityUpdatesOccurred) {
-                EXPECT_EQ(m_updatedChannels.size(), expected.size());
-                auto count = 0;
-                for (auto& expectedChannel : expected) {
-                    auto& channel = m_updatedChannels[expectedChannel.interfaceName];
-                    EXPECT_EQ(channel.name, expectedChannel.name);
-                    EXPECT_EQ(channel.interfaceName, expectedChannel.interfaceName);
-                    EXPECT_EQ(channel.focusState, expectedChannel.focusState);
-                    count++;
-                }
-            }
-            return m_activityUpdatesOccurred;
-        });
-
-        if (success) {
-            m_activityUpdatesOccurred = false;
-        }
-        ASSERT_TRUE(success);
-    }
+        const std::vector<ExpectedChannelStateResult>& expected);
 
     /**
      * Waits for the if there's a ActivityTrackerInterface##notifyOfActivityUpdates() callback.
      *
      * @param timeout The amount of time to wait for the callback.
      */
-    bool waitForNoActivityUpdates(std::chrono::milliseconds timeout) {
-        std::unique_lock<std::mutex> lock(m_mutex);
-        m_activityChanged.wait_for(lock, timeout);
-        return m_activityUpdatesOccurred;
-    }
+    bool waitForNoActivityUpdates(std::chrono::milliseconds timeout);
 
 private:
     /// The focus state of the observer. The key is the interface name.
@@ -427,12 +467,60 @@ private:
     bool m_activityUpdatesOccurred;
 };
 
+MockActivityTrackerInterface::MockActivityTrackerInterface() : m_activityUpdatesOccurred{false} {
+}
+
+void MockActivityTrackerInterface::notifyOfActivityUpdates(const std::vector<Channel::State>& channelStates) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    m_updatedChannels.clear();
+    for (auto& channel : channelStates) {
+        m_updatedChannels[channel.interfaceName] = channel;
+    }
+    m_activityUpdatesOccurred = true;
+    m_activityChanged.notify_one();
+}
+
+void MockActivityTrackerInterface::waitForActivityUpdates(
+    std::chrono::milliseconds timeout,
+    const std::vector<ExpectedChannelStateResult>& expected) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    bool success = m_activityChanged.wait_for(lock, timeout, [this, &expected]() {
+        if (m_activityUpdatesOccurred) {
+            EXPECT_EQ(m_updatedChannels.size(), expected.size());
+            auto count = 0;
+            for (auto& expectedChannel : expected) {
+                auto& channel = m_updatedChannels[expectedChannel.interfaceName];
+                EXPECT_EQ(channel.name, expectedChannel.name);
+                EXPECT_EQ(channel.interfaceName, expectedChannel.interfaceName);
+                EXPECT_EQ(channel.focusState, expectedChannel.focusState);
+                count++;
+            }
+        }
+        return m_activityUpdatesOccurred;
+    });
+
+    if (success) {
+        m_activityUpdatesOccurred = false;
+    }
+    ASSERT_TRUE(success);
+}
+
+bool MockActivityTrackerInterface::waitForNoActivityUpdates(std::chrono::milliseconds timeout) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    m_activityChanged.wait_for(lock, timeout);
+    return m_activityUpdatesOccurred;
+}
+
 /// Manages testing focus changes
 class FocusChangeManager {
 public:
-    TestClient::testClientInfo getWaitResult(std::shared_ptr<TestClient> client) {
-        return client->waitForFocusOrMixingBehaviorChange(DEFAULT_TIMEOUT);
-    }
+    /**
+     * Fetches the TestClient's ChannelObserverInterface##onFocusChanged() callback result.
+     *
+     * @param client The Channel observer.
+     * @return A @c TestClient object representing whether focus state or mixing behavior changed.
+     */
+    TestClient::TestClientInfo getWaitResult(std::shared_ptr<TestClient> client);
 
     /**
      * Checks that a focus change occurred and that the focus state received is the same as the expected focus
@@ -441,61 +529,132 @@ public:
      * @param client The Channel observer.
      * @param expectedFocusState The expected focus state.
      */
-    void assertFocusChange(std::shared_ptr<TestClient> client, FocusState expectedFocusState) {
-        auto waitResult = getWaitResult(client);
-        ASSERT_TRUE(waitResult.focusChanged);
-        ASSERT_EQ(expectedFocusState, waitResult.focusState);
-    }
+    void assertFocusChange(std::shared_ptr<TestClient> client, FocusState expectedFocusState);
 
     /**
      * Checks that a focus change does not occur by waiting for the timeout duration.
      *
      * @param client The Channel observer.
      */
-    void assertNoFocusChange(std::shared_ptr<TestClient> client) {
-        // Will wait for the short timeout duration before succeeding
-        auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
-        ASSERT_FALSE(ret.focusChanged);
-    }
+    void assertNoFocusChange(std::shared_ptr<TestClient> client);
 
-    void assertMixingBehaviorChange(std::shared_ptr<TestClient> client, MixingBehavior behavior) {
-        // Will wait for the short timeout duration before succeeding
-        auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
-        ASSERT_TRUE(ret.mixingBehaviorChanged);
-        ASSERT_EQ(ret.mixingBehavior, behavior);
-    }
+    /**
+     * Checks that a mixing behavior change occurred and that the mixing behavior received is the same as the expected
+     * mixing behavior.
+     *
+     * @param client The Channel observer.
+     * @param expectedMixingBehavior The expected mixing behavior.
+     */
+    void assertMixingBehaviorChange(std::shared_ptr<TestClient> client, MixingBehavior expectedMixingBehavior);
 
-    void assertNoMixingBehaviorChange(std::shared_ptr<TestClient> client) {
-        // Will wait for the short timeout duration before succeeding
-        auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
-        ASSERT_FALSE(ret.mixingBehaviorChanged);
-    }
+    /**
+     * Checks that a mixing behavior change does not occur by waiting for the timeout duration.
+     *
+     * @param client The Channel observer.
+     */
+    void assertNoMixingBehaviorChange(std::shared_ptr<TestClient> client);
 
-    void assertNoMixingBehaviorOrFocusChange(std::shared_ptr<TestClient> client) {
-        // Will wait for the short timeout duration before succeeding
-        auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
-        ASSERT_FALSE(ret.mixingBehaviorChanged);
-        ASSERT_FALSE(ret.focusChanged);
-    }
+    /**
+     * Checks that there is no focus state or mixing behavior change that occurs by waiting for the timeout duration.
+     *
+     * @param client The Channel observer.
+     */
+    void assertNoMixingBehaviorOrFocusChange(std::shared_ptr<TestClient> client);
 
+    /**
+     * Checks that a focus state and mixing behavior change occurred and that the focus state and mixing behavior is the
+     * same as the expected focus state and expected mixing behavior.
+     *
+     * @param client The Channel observer.
+     * @param expectedFocusState The expected focus state.
+     * @param expectedMixingBehavior The expected mixing behavior.
+     */
     void assertMixingBehaviorAndFocusChange(
         std::shared_ptr<TestClient> client,
         FocusState expectedFocusState,
-        MixingBehavior behavior) {
-        // Will wait for the short timeout duration before succeeding
-        auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
-        ASSERT_TRUE(ret.mixingBehaviorChanged);
-        ASSERT_TRUE(ret.focusChanged);
-        ASSERT_EQ(expectedFocusState, ret.focusState);
-        ASSERT_EQ(behavior, ret.mixingBehavior);
-    }
+        MixingBehavior expectedMixingBehavior);
 };
 
+TestClient::TestClientInfo FocusChangeManager::getWaitResult(std::shared_ptr<TestClient> client) {
+    return client->waitForFocusOrMixingBehaviorChange(DEFAULT_TIMEOUT);
+}
+
+void FocusChangeManager::assertFocusChange(std::shared_ptr<TestClient> client, FocusState expectedFocusState) {
+    auto waitResult = getWaitResult(client);
+    ASSERT_TRUE(waitResult.focusChanged);
+    ASSERT_EQ(expectedFocusState, waitResult.focusState);
+}
+
+void FocusChangeManager::assertNoFocusChange(std::shared_ptr<TestClient> client) {
+    // Will wait for the short timeout duration before succeeding
+    auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
+    ASSERT_FALSE(ret.focusChanged);
+}
+
+void FocusChangeManager::assertMixingBehaviorChange(
+    std::shared_ptr<TestClient> client,
+    MixingBehavior expectedMixingBehavior) {
+    // Will wait for the short timeout duration before succeeding
+    auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
+    ASSERT_TRUE(ret.mixingBehaviorChanged);
+    ASSERT_EQ(ret.mixingBehavior, expectedMixingBehavior);
+}
+
+void FocusChangeManager::assertNoMixingBehaviorChange(std::shared_ptr<TestClient> client) {
+    // Will wait for the short timeout duration before succeeding
+    auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
+    ASSERT_FALSE(ret.mixingBehaviorChanged);
+}
+
+void FocusChangeManager::assertNoMixingBehaviorOrFocusChange(std::shared_ptr<TestClient> client) {
+    // Will wait for the short timeout duration before succeeding
+    auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
+    ASSERT_FALSE(ret.mixingBehaviorChanged);
+    ASSERT_FALSE(ret.focusChanged);
+}
+
+void FocusChangeManager::assertMixingBehaviorAndFocusChange(
+    std::shared_ptr<TestClient> client,
+    FocusState expectedFocusState,
+    MixingBehavior expectedMixingBehavior) {
+    // Will wait for the short timeout duration before succeeding
+    auto ret = client->waitForFocusOrMixingBehaviorChange(SHORT_TIMEOUT);
+    ASSERT_TRUE(ret.mixingBehaviorChanged);
+    ASSERT_TRUE(ret.focusChanged);
+    ASSERT_EQ(expectedFocusState, ret.focusState);
+    ASSERT_EQ(expectedMixingBehavior, ret.mixingBehavior);
+}
+
 /// Test fixture for testing FocusManager.
 class FocusManagerTest
         : public ::testing::Test
         , public FocusChangeManager {
 protected:
+    /**
+     * Initialization for tests.
+     */
+    void SetUp() override;
+
+    /**
+     * Generate an InterruptModel Configuration.
+     *
+     * @return A @c ConfigurationNode representing the InterruptModel.
+     */
+    ConfigurationNode generateInterruptModelConfig();
+
+    /**
+     * Helper function that creates an activity and acquires a channel.
+     *
+     * @param client The Channel observer.
+     * @param contentType The Content Type.
+     * @param patience The Patience Duration.
+     * @return @c true indicating that the operation was successful, @c false otherwise.
+     */
+    bool acquireChannelHelper(
+        std::shared_ptr<TestClient> client,
+        ContentType contentType = ContentType::NONMIXABLE,
+        std::chrono::milliseconds patience = std::chrono::milliseconds(0));
+
     /// The FocusManager.
     std::shared_ptr<FocusManager> m_focusManager;
 
@@ -522,63 +681,66 @@ protected:
 
     /// Interrupt Model
     std::shared_ptr<interruptModel::InterruptModel> m_interruptModel;
+};
 
-    ConfigurationNode generateInterruptModelConfig() {
-        auto stream = std::shared_ptr<std::istream>(new std::istringstream(INTERRUPT_MODEL_CONFIG_JSON));
-        std::vector<std::shared_ptr<std::istream>> jsonStream({stream});
-        ConfigurationNode::initialize(jsonStream);
-        return ConfigurationNode::getRoot();
-    }
+void FocusManagerTest::SetUp() {
+    m_activityTracker = std::make_shared<MockActivityTrackerInterface>();
 
-    virtual void SetUp() {
-        m_activityTracker = std::make_shared<MockActivityTrackerInterface>();
+    FocusManager::ChannelConfiguration dialogChannelConfig{DIALOG_CHANNEL_NAME, DIALOG_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration alertsChannelConfig{ALERTS_CHANNEL_NAME, ALERTS_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration contentChannelConfig{CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration virtualChannelConfig{VIRTUAL_CHANNEL_NAME, VIRTUAL_CHANNEL_PRIORITY};
 
-        FocusManager::ChannelConfiguration dialogChannelConfig{DIALOG_CHANNEL_NAME, DIALOG_CHANNEL_PRIORITY};
-        FocusManager::ChannelConfiguration alertsChannelConfig{ALERTS_CHANNEL_NAME, ALERTS_CHANNEL_PRIORITY};
-        FocusManager::ChannelConfiguration contentChannelConfig{CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY};
-        FocusManager::ChannelConfiguration virtualChannelConfig{VIRTUAL_CHANNEL_NAME, VIRTUAL_CHANNEL_PRIORITY};
+    std::vector<FocusManager::ChannelConfiguration> channelConfigurations{
+        dialogChannelConfig, alertsChannelConfig, contentChannelConfig};
 
-        std::vector<FocusManager::ChannelConfiguration> channelConfigurations{
-            dialogChannelConfig, alertsChannelConfig, contentChannelConfig};
+    dialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIALOG_INTERFACE_NAME);
+    alertsClient = std::make_shared<TestClient>(ALERTS_CHANNEL_NAME, ALERTS_INTERFACE_NAME);
+    contentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, CONTENT_INTERFACE_NAME);
+    anotherContentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, DIFFERENT_CONTENT_INTERFACE_NAME);
+    anotherDialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIFFERENT_DIALOG_INTERFACE_NAME);
+    virtualClient = std::make_shared<TestClient>(VIRTUAL_CHANNEL_NAME, VIRTUAL_INTERFACE_NAME);
 
-        dialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIALOG_INTERFACE_NAME);
-        alertsClient = std::make_shared<TestClient>(ALERTS_CHANNEL_NAME, ALERTS_INTERFACE_NAME);
-        contentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, CONTENT_INTERFACE_NAME);
-        anotherContentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, DIFFERENT_CONTENT_INTERFACE_NAME);
-        anotherDialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIFFERENT_DIALOG_INTERFACE_NAME);
-        virtualClient = std::make_shared<TestClient>(VIRTUAL_CHANNEL_NAME, VIRTUAL_INTERFACE_NAME);
+    std::vector<FocusManager::ChannelConfiguration> virtualChannelConfigurations{virtualChannelConfig};
 
-        std::vector<FocusManager::ChannelConfiguration> virtualChannelConfigurations{virtualChannelConfig};
+    m_interruptModel = interruptModel::InterruptModel::create(generateInterruptModelConfig()[INTERRUPT_MODEL_ROOT_KEY]);
+    m_focusManager = afml::FocusManager::create(
+        channelConfigurations, m_activityTracker, virtualChannelConfigurations, m_interruptModel);
+}
 
-        m_interruptModel =
-            interruptModel::InterruptModel::create(generateInterruptModelConfig()[INTERRUPT_MODEL_ROOT_KEY]);
-        m_focusManager = std::make_shared<FocusManager>(
-            channelConfigurations, m_activityTracker, virtualChannelConfigurations, m_interruptModel);
-    }
+ConfigurationNode FocusManagerTest::generateInterruptModelConfig() {
+    auto stream = std::shared_ptr<std::istream>(new std::istringstream(INTERRUPT_MODEL_CONFIG_JSON));
+    std::vector<std::shared_ptr<std::istream>> jsonStream({stream});
+    ConfigurationNode::initialize(jsonStream);
+    return ConfigurationNode::getRoot();
+}
 
-    bool acquireChannelHelper(
-        std::shared_ptr<TestClient> client,
-        ContentType contentType = ContentType::NONMIXABLE,
-        std::chrono::milliseconds patience = std::chrono::milliseconds(0)) {
-        auto activity = client->createActivity(contentType, patience);
-        return m_focusManager->acquireChannel(client->getChannelName(), activity);
-    }
-};
+bool FocusManagerTest::acquireChannelHelper(
+    std::shared_ptr<TestClient> client,
+    ContentType contentType,
+    std::chrono::milliseconds patience) {
+    auto activity = client->createActivity(contentType, patience);
+    return m_focusManager->acquireChannel(client->getChannelName(), activity);
+}
 
-/// Tests acquireChannel with an invalid Channel name, expecting no focus changes to be made.
+/**
+ * Tests acquireChannel with an invalid Channel name, expecting no focus changes to be made.
+ */
 TEST_F(FocusManagerTest, test_acquireInvalidChannelName) {
     ASSERT_FALSE(m_focusManager->acquireChannel(INCORRECT_CHANNEL_NAME, dialogClient, DIALOG_INTERFACE_NAME));
 }
 
-/// Tests acquireChannel, expecting to get Foreground status since no other Channels are active.
+/**
+ * Tests acquireChannel, expecting to get FOREGROUND focus since no other Channels are active.
+ */
 TEST_F(FocusManagerTest, test_acquireChannelWithNoOtherChannelsActive) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
     assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
 }
 
 /**
- * Tests acquireChannel with two Channels. The lower priority Channel should get Background focus and the higher
- * priority Channel should get Foreground focus.
+ * Tests acquireChannel with two Channels. The lower priority Channel should get BACKGROUND focus and the higher
+ * priority Channel should get FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_acquireLowerPriorityChannelWithOneHigherPriorityChannelTaken) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -588,10 +750,10 @@ TEST_F(FocusManagerTest, test_acquireLowerPriorityChannelWithOneHigherPriorityCh
 }
 
 /**
- * Tests acquireChannel with three Channels. The two lowest priority Channels should get Background focus while the
- * highest priority Channel should be Foreground focused.
+ * Tests acquireChannel with three Channels. The two lowest priority Channels should get BACKGROUND focus while the
+ * highest priority Channel should be FOREGROUND focused.
  */
-TEST_F(FocusManagerTest, test_aquireLowerPriorityChannelWithTwoHigherPriorityChannelsTaken) {
+TEST_F(FocusManagerTest, test_acquireLowerPriorityChannelWithTwoHigherPriorityChannelsTaken) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
     ASSERT_TRUE(acquireChannelHelper(alertsClient, ContentType::MIXABLE));
     ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
@@ -603,8 +765,8 @@ TEST_F(FocusManagerTest, test_aquireLowerPriorityChannelWithTwoHigherPriorityCha
 /**
  * Tests acquireChannel virtual channel is working the same as other channels.  We test with three Channels (one
  * virtual). First we acquire a non-virtual channel and make sure it goes FOREGROUND.  Then we acquire a virtual channel
- * with higher prioirty and one non-virtual with lower priority and make sure the two lowest priority Channels should
- * get Background focus while the highest priority Channel should be Foreground focused.
+ * with higher priority and one non-virtual with lower priority and make sure the two lowest priority Channels should
+ * get BACKGROUND focus while the highest priority Channel should be FOREGROUND focused.
  */
 TEST_F(FocusManagerTest, acquireVirtualChannelWithTwoLowerPriorityChannelsTaken) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -618,8 +780,8 @@ TEST_F(FocusManagerTest, acquireVirtualChannelWithTwoLowerPriorityChannelsTaken)
 
 /**
  * Tests acquireChannel with a high priority Channel while a low priority Channel is already taken. The lower priority
- * Channel should at first be Foreground focused and then get a change to Background focus while the higher priority
- * should be Foreground focused.
+ * Channel should at first be FOREGROUND focused and then get a change to BACKGROUND focus while the higher priority
+ * should be FOREGROUND focused.
  */
 TEST_F(FocusManagerTest, test_acquireHigherPriorityChannelWithOneLowerPriorityChannelTaken) {
     ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
@@ -632,7 +794,7 @@ TEST_F(FocusManagerTest, test_acquireHigherPriorityChannelWithOneLowerPriorityCh
 
 /**
  * Tests acquireChannel with a single Channel. The original observer should be notified to stop and the new observer
- * should obtain Foreground focus.
+ * should obtain FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_kickOutActivityOnSameChannel) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient));
@@ -669,8 +831,8 @@ TEST_F(FocusManagerTest, test_simpleReleaseChannelWithIncorrectObserver) {
 }
 
 /**
- * Tests releaseChannel of the Foreground focused Channel while another Channel is taken. The originally Background
- * focused Channel should be notified to come to the Foreground while the originally Foreground focused Channel should
+ * Tests releaseChannel of the FOREGROUND focused Channel while another Channel is taken. The originally BACKGROUND
+ * focused Channel should be notified to come to the FOREGROUND while the originally FOREGROUND focused Channel should
  * be notified to stop.
  */
 TEST_F(FocusManagerTest, test_releaseForegroundChannelWhileBackgroundChannelTaken) {
@@ -698,8 +860,8 @@ TEST_F(FocusManagerTest, test_simpleNonTargetedStop) {
 }
 
 /**
- * Tests stopForegroundActivity with a three active Channels. The Foreground Channel observer should be notified to
- * stop each time and the next highest priority background Channel should be brought to the foreground each time.
+ * Tests stopForegroundActivity with a three active Channels. The FOREGROUND Channel observer should be notified to
+ * stop each time and the next highest priority background Channel should be brought to the FOREGROUND each time.
  */
 TEST_F(FocusManagerTest, test_threeNonTargetedStopsWithThreeActivitiesHappening) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -715,7 +877,7 @@ TEST_F(FocusManagerTest, test_threeNonTargetedStopsWithThreeActivitiesHappening)
     m_focusManager->stopForegroundActivity();
     assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
     assertMixingBehaviorAndFocusChange(alertsClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
-    // no change in mixingbehavior or focusstate for content, no activity updates either
+    // No change in mixing behavior or focus state for content, no activity updates either.
     assertNoMixingBehaviorOrFocusChange(contentClient);
 
     m_focusManager->stopForegroundActivity();
@@ -728,7 +890,7 @@ TEST_F(FocusManagerTest, test_threeNonTargetedStopsWithThreeActivitiesHappening)
 
 /**
  * Tests stopForegroundActivity with a single Channel. The next client to request a different Channel should be given
- * foreground focus.
+ * FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_stopForegroundActivityAndAcquireDifferentChannel) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient));
@@ -743,7 +905,7 @@ TEST_F(FocusManagerTest, test_stopForegroundActivityAndAcquireDifferentChannel)
 
 /**
  * Tests stopForegroundActivity with a single Channel. The next client to request the same Channel should be given
- * foreground focus.
+ * FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_stopForegroundActivityAndAcquireSameChannel) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient));
@@ -758,7 +920,7 @@ TEST_F(FocusManagerTest, test_stopForegroundActivityAndAcquireSameChannel) {
 
 /**
  * Test stopAllActivities with a single channel.
- * Expect focus change only on that channel and reacquiring the same channel should resulted in foreground focus.
+ * Expect focus change only on that channel and re-acquiring the same channel should result in FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_stopAllActivitiesWithSingleChannel) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient));
@@ -775,7 +937,7 @@ TEST_F(FocusManagerTest, test_stopAllActivitiesWithSingleChannel) {
 
 /**
  * Test stopAllActivities with three channels.
- * Expect focus change to none for all channels and a channel should resulted in foreground focus.
+ * Expect focus change to NONE for all channels and a channel should result in FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, test_stopAllActivitiesWithThreeChannels) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -799,7 +961,7 @@ TEST_F(FocusManagerTest, test_stopAllActivitiesWithThreeChannels) {
 
 /**
  * Test stopAllActivities with a single channel.
- * Expect focus change only on that channel and reacquiring the same channel should result in foreground focus.
+ * Expect focus change only on that channel and re-acquiring the same channel should result in FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, stopAllActivitiesWithSingleChannel) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient));
@@ -817,7 +979,7 @@ TEST_F(FocusManagerTest, stopAllActivitiesWithSingleChannel) {
 
 /**
  * Test stopAllActivities with three channels.
- * Expect focus change to none for all channels and a channel should result in foreground focus.
+ * Expect focus change to NONE for all channels and a channel should result in FOREGROUND focus.
  */
 TEST_F(FocusManagerTest, stopAllActivitiesWithThreeChannels) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -841,8 +1003,8 @@ TEST_F(FocusManagerTest, stopAllActivitiesWithThreeChannels) {
 }
 
 /**
- * Tests releaseChannel with the background Channel while there is a foreground Channel. The foreground Channel
- * should remain foregrounded while the background Channel's observer should be notified to stop.
+ * Tests releaseChannel with the BACKGROUND Channel while there is a FOREGROUND Channel. The FOREGROUND Channel
+ * should remain foregrounded while the BACKGROUND Channel's observer should be notified to stop.
  */
 TEST_F(FocusManagerTest, test_releaseBackgroundChannelWhileTwoChannelsTaken) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -860,7 +1022,7 @@ TEST_F(FocusManagerTest, test_releaseBackgroundChannelWhileTwoChannelsTaken) {
 /**
  * Tests acquireChannel of an already active foreground Channel while another Channel is also active. The original
  * observer of the foreground be notified to stop and the new observer of the Channel will be notified that it has
- * Foreground focus. The originally backgrounded Channel should not change focus.
+ * FOREGROUND focus. The originally backgrounded Channel should not change focus.
  */
 TEST_F(FocusManagerTest, test_kickOutActivityOnSameChannelWhileOtherChannelsActive) {
     ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
@@ -875,7 +1037,9 @@ TEST_F(FocusManagerTest, test_kickOutActivityOnSameChannelWhileOtherChannelsActi
     assertNoMixingBehaviorOrFocusChange(contentClient);
 }
 
-/// Tests that multiple observers can be added, and that they are notified of all focus changes.
+/**
+ * Tests that multiple observers can be added, and that they are notified of all focus changes.
+ */
 TEST_F(FocusManagerTest, test_addObserver) {
     // These are all the observers that will be added.
     std::vector<std::shared_ptr<MockFocusManagerObserver>> observers;
@@ -903,7 +1067,7 @@ TEST_F(FocusManagerTest, test_addObserver) {
         ASSERT_TRUE(observer->waitForFocusChanges(DEFAULT_TIMEOUT));
     }
 
-    // Drop foreground focus.
+    // Drop FOREGROUND focus.
     for (auto& observer : observers) {
         observer->expectFocusChange(DIALOG_CHANNEL_NAME, FocusState::NONE);
         observer->expectFocusChange(CONTENT_CHANNEL_NAME, FocusState::FOREGROUND);
@@ -915,7 +1079,9 @@ TEST_F(FocusManagerTest, test_addObserver) {
     }
 }
 
-/// Tests that observers can be removed, and that they are no longer notified of focus changes after removal.
+/**
+ * Tests that observers can be removed, and that they are no longer notified of focus changes after removal.
+ */
 TEST_F(FocusManagerTest, test_removeObserver) {
     // These are all the observers that will ever be added.
     std::vector<std::shared_ptr<MockFocusManagerObserver>> allObservers;
@@ -946,7 +1112,7 @@ TEST_F(FocusManagerTest, test_removeObserver) {
     m_focusManager->removeObserver(activeObservers.back());
     activeObservers.pop_back();
 
-    // Now another focus change with the removed observer.
+    // Another focus change with the removed observer.
     for (auto& observer : activeObservers) {
         observer->expectFocusChange(CONTENT_CHANNEL_NAME, FocusState::BACKGROUND);
     }
@@ -963,7 +1129,7 @@ TEST_F(FocusManagerTest, test_removeObserver) {
     }
     activeObservers.clear();
 
-    // And a final focus change with no observers.
+    // Final focus change with no observers.
     m_focusManager->stopForegroundActivity();
 
     for (auto& observer : allObservers) {
@@ -1025,11 +1191,11 @@ TEST_F(FocusManagerTest, test_activityTracker) {
     ASSERT_TRUE(m_focusManager->releaseChannel(ALERTS_CHANNEL_NAME, alertsClient).get());
     m_activityTracker->waitForActivityUpdates(DEFAULT_TIMEOUT, test7);
 
-    // acquire Virtual channel and expect no notifyOfActivityUpdates().
+    // Acquire Virtual channel and expect no notifyOfActivityUpdates().
     ASSERT_TRUE(acquireChannelHelper(virtualClient));
     ASSERT_FALSE(m_activityTracker->waitForNoActivityUpdates(NO_ACTIVITY_UPDATE_TIMEOUT));
 
-    // release Virtual channel and expect no notifyOfActivityUpdates().
+    // Release Virtual channel and expect no notifyOfActivityUpdates().
     ASSERT_TRUE(m_focusManager->releaseChannel(VIRTUAL_CHANNEL_NAME, virtualClient).get());
     ASSERT_FALSE(m_activityTracker->waitForNoActivityUpdates(NO_ACTIVITY_UPDATE_TIMEOUT));
 
@@ -1039,7 +1205,7 @@ TEST_F(FocusManagerTest, test_activityTracker) {
     ASSERT_TRUE(acquireChannelHelper(contentClient));
     m_activityTracker->waitForActivityUpdates(DEFAULT_TIMEOUT, test8);
 
-    // acquire Virtual channel and expect no updates to virtual channel but Content channel to go to BACKGROUND.
+    // Acquire Virtual channel and expect no updates to virtual channel but Content channel to go to BACKGROUND.
     const std::vector<MockActivityTrackerInterface::ExpectedChannelStateResult> test9 = {
         {CONTENT_CHANNEL_NAME, CONTENT_INTERFACE_NAME, FocusState::BACKGROUND}};
     ASSERT_TRUE(acquireChannelHelper(virtualClient));
@@ -1051,61 +1217,86 @@ class ChannelTest
         : public ::testing::Test
         , public FocusChangeManager {
 protected:
-    /// observer A for the Content MultiActivity Channel
+    /**
+     * Representation of an Activity Update.
+     */
+    struct ActivityUpdateElem {
+        ActivityUpdateElem(std::string interfaceName, FocusState focus) :
+                m_interfaceName{interfaceName},
+                m_focusState{focus} {
+        }
+
+        /// The interface name.
+        std::string m_interfaceName;
+
+        /// The focus state.
+        FocusState m_focusState;
+    };
+
+    /**
+     * Initialization for tests.
+     */
+    void SetUp() override;
+
+    /**
+     * Checks whether there are Activity Updates.
+     *
+     * @param channel The channel being observed.
+     * @param incoming The incoming activity updates.
+     */
+    void checkActivityUpdates(std::shared_ptr<Channel> channel, std::vector<ActivityUpdateElem>& incoming);
+
+    /// An observer A for the Content MultiActivity Channel
     std::shared_ptr<TestClient> clientA;
 
-    /// observer B for the Content MultiActivity Channel
+    /// An observer B for the Content MultiActivity Channel
     std::shared_ptr<TestClient> clientB;
 
-    /// observer C for the Content MultiActivity Channel
+    /// An observer C for the Content MultiActivity Channel
     std::shared_ptr<TestClient> clientC;
 
     /// A test Channel.
     std::shared_ptr<Channel> testChannel;
 
-    /// Content Channel.
+    /// A Content Channel.
     std::shared_ptr<Channel> contentChannel;
+};
 
-    virtual void SetUp() {
-        clientA = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientA_Interface");
-        clientB = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientB_Interface");
-        clientC = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientC_Interface");
-        testChannel = std::make_shared<Channel>(DIALOG_CHANNEL_NAME, DIALOG_CHANNEL_PRIORITY);
-        contentChannel = std::make_shared<Channel>(CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY);
-    }
-
-    struct ActivityUpdateElem {
-        std::string m_interfaceName;
-        FocusState m_focusState;
-        ActivityUpdateElem(std::string interfaceName, FocusState focus) :
-                m_interfaceName{interfaceName},
-                m_focusState{focus} {
-        }
-    };
-
-    void checkActivityUpdates(std::shared_ptr<Channel> channel, std::vector<ActivityUpdateElem>& incoming) {
-        auto activityUpdates = channel->getActivityUpdates();
-        ASSERT_EQ(incoming.size(), activityUpdates.size());
-        for (size_t i = 0; i < incoming.size(); i++) {
-            ASSERT_EQ(activityUpdates.at(i).interfaceName, incoming.at(i).m_interfaceName);
-            ASSERT_EQ(activityUpdates.at(i).focusState, incoming.at(i).m_focusState);
-        }
+void ChannelTest::SetUp() {
+    clientA = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientA_Interface");
+    clientB = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientB_Interface");
+    clientC = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, "ClientC_Interface");
+    testChannel = std::make_shared<Channel>(DIALOG_CHANNEL_NAME, DIALOG_CHANNEL_PRIORITY);
+    contentChannel = std::make_shared<Channel>(CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY);
+}
 
-        incoming.clear();
+void ChannelTest::checkActivityUpdates(std::shared_ptr<Channel> channel, std::vector<ActivityUpdateElem>& incoming) {
+    auto activityUpdates = channel->getActivityUpdates();
+    ASSERT_EQ(incoming.size(), activityUpdates.size());
+    for (size_t i = 0; i < incoming.size(); i++) {
+        ASSERT_EQ(activityUpdates.at(i).interfaceName, incoming.at(i).m_interfaceName);
+        ASSERT_EQ(activityUpdates.at(i).focusState, incoming.at(i).m_focusState);
     }
-};
+    incoming.clear();
+}
 
-/// Tests that the getName method of Channel works properly.
+/**
+ * Tests that the getName method of Channel returns the name correctly.
+ */
 TEST_F(ChannelTest, test_getName) {
     ASSERT_EQ(testChannel->getName(), DIALOG_CHANNEL_NAME);
 }
 
-/// Tests that the getPriority method of Channel works properly.
+/**
+ * Tests that the getPriority method of Channel returns the priority correctly.
+ */
 TEST_F(ChannelTest, test_getPriority) {
     ASSERT_EQ(testChannel->getPriority(), DIALOG_CHANNEL_PRIORITY);
 }
 
-/// Tests that the observer properly gets notified of focus changes.
+/**
+ * Tests that the observer correctly gets notified of focus changes.
+ */
 TEST_F(ChannelTest, test_setObserverThenSetFocus) {
     auto Activity_A = clientA->createActivity();
     testChannel->setPrimaryActivity(Activity_A);
@@ -1122,7 +1313,9 @@ TEST_F(ChannelTest, test_setObserverThenSetFocus) {
     ASSERT_FALSE(testChannel->setFocus(FocusState::NONE, MixingBehavior::MUST_STOP));
 }
 
-/// Tests that Channels are compared properly
+/**
+ * Tests that Channels are compared correctly.
+ */
 TEST_F(ChannelTest, test_priorityComparison) {
     std::shared_ptr<Channel> lowerPriorityChannel =
         std::make_shared<Channel>(CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY);
@@ -1130,7 +1323,9 @@ TEST_F(ChannelTest, test_priorityComparison) {
     ASSERT_FALSE(*lowerPriorityChannel > *testChannel);
 }
 
-/// Tests that a Channel correctly reports whether it is active.
+/**
+ * Tests that a Channel correctly reports whether it is active.
+ */
 TEST_F(ChannelTest, test_isChannelActive) {
     // initially channel is not active
     ASSERT_FALSE(testChannel->isActive());
@@ -1154,7 +1349,7 @@ TEST_F(ChannelTest, test_isChannelActive) {
     ASSERT_FALSE(testChannel->isActive());
 }
 
-/*
+/**
  * Tests that the timeAtIdle only gets updated when channel goes to idle and not when channel goes to Foreground or
  * Background.
  */
@@ -1173,6 +1368,9 @@ TEST_F(ChannelTest, test_getTimeAtIdle) {
     ASSERT_GT(afterNoneTime, afterBackgroundTime);
 }
 
+/**
+ * Tests that a new Activity will kick out the existing Activity on a Channel.
+ */
 TEST_F(ChannelTest, test_MultiActivity_NewActivityKicksExistingActivity) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1202,6 +1400,9 @@ TEST_F(ChannelTest, test_MultiActivity_NewActivityKicksExistingActivity) {
     ASSERT_EQ(contentChannel->getActivity(Activity_B->getInterface()), nullptr);
 }
 
+/**
+ * Tests incoming Activity interaction with the same channel priority.
+ */
 TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience1) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1240,6 +1441,9 @@ TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience1) {
     ASSERT_EQ(contentChannel->getActivity(Activity_A->getInterface()), nullptr);
 }
 
+/**
+ * Tests incoming Activity interaction with the same channel priority.
+ */
 TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience2) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1278,6 +1482,9 @@ TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience2) {
     ASSERT_EQ(contentChannel->getActivity(Activity_B->getInterface()), nullptr);
 }
 
+/**
+ * Tests incoming Activity interaction with same channel priority.
+ */
 TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience3) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1313,6 +1520,9 @@ TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience3) {
     ASSERT_EQ(contentChannel->getActivity(Activity_B->getInterface()), nullptr);
 }
 
+/**
+ * Tests incoming Activity interaction with same channel priority.
+ */
 TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience4) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1362,6 +1572,9 @@ TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience4) {
     ASSERT_TRUE(contentChannel->getState().interfaceName == Activity_B->getInterface());
 }
 
+/**
+ * Tests incoming Activity interaction with same channel priority.
+ */
 TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience5) {
     std::vector<ActivityUpdateElem> expectedUpdates;
 
@@ -1405,6 +1618,1332 @@ TEST_F(ChannelTest, test_MultiActivity_IncomingActivityWithPatience5) {
     ASSERT_EQ(contentChannel->getActivity(Activity_C->getInterface()), nullptr);
 }
 
+/// Test fixture for testing FocusManager with ExternalFocusMediator enabled.
+class FocusManagerWithExternalFocusMediatorEnabledTest
+        : public ::testing::Test
+        , public FocusChangeManager {
+protected:
+    /**
+     * Initialization for tests.
+     */
+    void SetUp();
+
+    /**
+     * Generate an InterruptModel Configuration.
+     *
+     * @return A @c ConfigurationNode representing the InterruptModel.
+     */
+    ConfigurationNode generateInterruptModelConfig();
+
+    /**
+     * Helper function that creates an activity and acquires a channel.
+     *
+     * @param client The Channel observer.
+     * @param contentType The Content Type.
+     * @param patience The Patience Duration.
+     * @param audioAttributes The Audio Attributes.
+     * @return @c true indicating that the operation was successful, @c false otherwise.
+     */
+    bool acquireChannelHelper(
+        std::shared_ptr<TestClient> client,
+        ContentType contentType = ContentType::NONMIXABLE,
+        std::chrono::milliseconds patience = std::chrono::milliseconds(0),
+        AudioAttributes audioAttributes = {AudioAttributes::Usage::UNKNOWN});
+
+    /// The FocusManager.
+    std::shared_ptr<FocusManager> m_focusManager;
+
+    /// A client that acquires the dialog Channel.
+    std::shared_ptr<TestClient> dialogClient;
+
+    /// Another client that acquires the dialog Channel.
+    std::shared_ptr<TestClient> anotherDialogClient;
+
+    /// A client that acquires the alerts Channel.
+    std::shared_ptr<TestClient> alertsClient;
+
+    /// A client that acquire the content Channel.
+    std::shared_ptr<TestClient> contentClient;
+
+    /// Another client that acquires the content Channel.
+    std::shared_ptr<TestClient> anotherContentClient;
+
+    /// A client that acquires the virtual Channel.
+    std::shared_ptr<TestClient> virtualClient;
+
+    /// Mock Activity Tracker.
+    std::shared_ptr<MockActivityTrackerInterface> m_activityTracker;
+
+    /// The Interrupt Model.
+    std::shared_ptr<interruptModel::InterruptModel> m_interruptModel;
+
+    /// The ExternalFocusMediator.
+    std::shared_ptr<MockExternalFocusMediator> m_externalFocusMediator;
+};
+
+void FocusManagerWithExternalFocusMediatorEnabledTest::SetUp() {
+    m_activityTracker = std::make_shared<MockActivityTrackerInterface>();
+
+    FocusManager::ChannelConfiguration dialogChannelConfig{DIALOG_CHANNEL_NAME, DIALOG_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration alertsChannelConfig{ALERTS_CHANNEL_NAME, ALERTS_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration contentChannelConfig{CONTENT_CHANNEL_NAME, CONTENT_CHANNEL_PRIORITY};
+    FocusManager::ChannelConfiguration virtualChannelConfig{VIRTUAL_CHANNEL_NAME, VIRTUAL_CHANNEL_PRIORITY};
+
+    // Populate vector with channel configs.
+    std::vector<FocusManager::ChannelConfiguration> channelConfigurations{
+        dialogChannelConfig, alertsChannelConfig, contentChannelConfig};
+
+    std::vector<FocusManager::ChannelConfiguration> virtualChannelConfigurations{virtualChannelConfig};
+
+    dialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIALOG_INTERFACE_NAME);
+    anotherDialogClient = std::make_shared<TestClient>(DIALOG_CHANNEL_NAME, DIFFERENT_DIALOG_INTERFACE_NAME);
+    alertsClient = std::make_shared<TestClient>(ALERTS_CHANNEL_NAME, ALERTS_INTERFACE_NAME);
+    contentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, CONTENT_INTERFACE_NAME);
+    anotherContentClient = std::make_shared<TestClient>(CONTENT_CHANNEL_NAME, DIFFERENT_CONTENT_INTERFACE_NAME);
+    virtualClient = std::make_shared<TestClient>(VIRTUAL_CHANNEL_NAME, VIRTUAL_INTERFACE_NAME);
+
+    m_interruptModel = interruptModel::InterruptModel::create(generateInterruptModelConfig()[INTERRUPT_MODEL_ROOT_KEY]);
+
+    m_externalFocusMediator = std::make_shared<NiceMock<MockExternalFocusMediator>>();
+    ON_CALL(*m_externalFocusMediator, initialize(_, _)).WillByDefault(Return(true));
+
+    m_focusManager = afml::FocusManager::create(
+        channelConfigurations,
+        m_activityTracker,
+        virtualChannelConfigurations,
+        m_interruptModel,
+        m_externalFocusMediator);
+
+    ASSERT_NE(m_focusManager, nullptr);
+}
+
+ConfigurationNode FocusManagerWithExternalFocusMediatorEnabledTest::generateInterruptModelConfig() {
+    auto stream = std::shared_ptr<std::istream>(new std::istringstream(INTERRUPT_MODEL_CONFIG_JSON));
+    std::vector<std::shared_ptr<std::istream>> jsonStream({stream});
+    ConfigurationNode::initialize(jsonStream);
+    return ConfigurationNode::getRoot();
+}
+
+bool FocusManagerWithExternalFocusMediatorEnabledTest::acquireChannelHelper(
+    std::shared_ptr<TestClient> client,
+    ContentType contentType,
+    std::chrono::milliseconds patience,
+    AudioAttributes audioAttributes) {
+    auto activity = client->createActivity(contentType, patience, audioAttributes);
+    return m_focusManager->acquireChannel(client->getChannelName(), activity);
+}
+
+/**
+ * Tests acquireChannel with an invalid Channel name, expecting no focus state or mixing behavior changes.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_InvalidChannelName) {
+    ASSERT_FALSE(m_focusManager->acquireChannel(INCORRECT_CHANNEL_NAME, dialogClient, DIALOG_INTERFACE_NAME));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting to get
+ * FOREGROUND focus and PRIMARY mixing behavior, since no other channels are active.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_NoChannelsActive_GrantsForegroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and MAY_DUCK mixing behavior promise. Expecting to get
+ * FOREGROUND focus and PRIMARY mixing behavior, since no other channels are active.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_NoChannelsActive_GrantsForegroundFocusAndMayDuckMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and MUST_PAUSE mixing behavior promise. Expecting to get
+ * FOREGROUND focus and PRIMARY mixing behavior, since no other channels are active.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_NoChannelsActive_GrantsForegroundFocusAndMustPauseMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled BACKGROUND focus and UNDEFINED mixing behavior promise. Expecting to get
+ * BACKGROUND focus and UNDEFINED mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_NoChannelsActive_GrantsBackgroundFocusAndUndefinedMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertFocusChange(dialogClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(dialogClient);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled BACKGROUND focus and MAY_DUCK mixing behavior promise. Expecting to get
+ * BACKGROUND focus and MAY_DUCK mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_NoChannelsActive_GrantsBackgroundFocusAndMayDuckMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled BACKGROUND focus and MUST_PAUSE mixing behavior promise. Expecting to get
+ * BACKGROUND focus and MUST_PAUSE mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_NoChannelsActive_GrantsBackgroundFocusAndMustPauseMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity to acquire FOREGROUND focus and PRIMARY mixing behavior. The second activity on the same Channel will kick
+ * out the first Channel and acquire FOREGROUND focus and PRIMARY mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_PrimaryActivityOnSameChannel_ForegroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherDialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(anotherDialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise for AUDIO_CAPTURE, and a
+ * BACKGROUND focus with UNDEFINED mixing behavior promise otherwise. Expecting the first activity to acquire FOREGROUND
+ * focus and PRIMARY mixing behavior. The second activity acquiring focus on the same Channel will kick out the first
+ * Channel and acquire BACKGROUND focus and UNDEFINED mixing behavior (No other channels present so mixing behavior is
+ * UNDEFINED).
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_PrimaryActivityOnSameChannel_BackgroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            // E.g. focusRequest.audioAttributes.usage == AudioAttributes::Usage::SPEECH
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(
+        anotherDialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::SPEECH}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertFocusChange(anotherDialogClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(anotherDialogClient);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity with a lower priority Channel to acquire FOREGROUND focus and PRIMARY mixing behavior. The second activity
+ * acquiring focus with a higher priority Channel will BACKGROUND the first lower priority Channel and acquire
+ * FOREGROUND focus and PRIMARY mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_HigherPriorityChannel_OneLowerPriorityChannelTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity with a higher priority Channel to acquire FOREGROUND focus and PRIMARY mixing behavior. The second activity
+ * acquiring focus with a lower priority Channel acquires BACKGROUND focus and MAY_DUCK mixing behavior
+ * (Default Behavior).
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_LowerPriorityChannel_OneHigherPriorityChannelTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity with a higher priority Channel to acquire FOREGROUND focus and PRIMARY mixing behavior. The second activity
+ * acquiring focus with a lower priority Channel acquires BACKGROUND focus and MAY_DUCK mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_LowerPriorityChannel_OneHigherPriorityChannelTaken_MAY_DUCK) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            // E.g. focusRequest.audioAttributes.usage == AudioAttributes::Usage::MEDIA
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity with a higher priority Channel to acquire FOREGROUND focus and PRIMARY mixing behavior. The second activity
+ * acquiring focus with a lower priority Channel acquires BACKGROUND focus and MUST_PAUSE mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_LowerPriorityChannel_OneHigherPriorityChannelTaken_MUST_PAUSE) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            // E.g. focusRequest.audioAttributes.usage == AudioAttributes::Usage::MEDIA
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+                        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise. Expecting the first
+ * activity with the highest priority Channel to acquire FOREGROUND focus and PRIMARY mixing behavior. The second and
+ * third activities acquiring focus with a lower priority Channel will acquire BACKGROUND focus and MAY_DUCK mixing
+ * behavior (Default Behavior).
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_acquireChannel_LowerPriorityChannel_TwoHigherPriorityChannelsTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(3)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(alertsClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise for virtual Channel.
+ * Expecting the first non-virtual Channel with highest priority to acquire FOREGROUND focus and PRIMARY mixing
+ * behavior. The second non-virtual Channel acquired with a lower priority is set to BACKGROUND focus and MAY_DUCK
+ * mixing behavior (Default Behavior). The final virtual Channel respects the highest priority Channel is is also set to
+ * BACKGROUND focus and MAY_DUCK mixing behavior (Default Behavior).
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_VirtualChannel_TwoChannelsTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(3)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    ASSERT_TRUE(acquireChannelHelper(virtualClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+    assertMixingBehaviorAndFocusChange(virtualClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests acquireChannel with a rejected promise. Expecting NONE focus state and MUST_STOP mixing behavior.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_PromiseRejected) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillOnce(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::reject(
+                    std::errc::invalid_argument);
+        }));
+
+    // Define observers to test that callbacks are invoked.
+    std::vector<std::shared_ptr<MockFocusManagerObserver>> allObservers;
+
+    // Note: StrictMock here so that we fail on unexpected observer callbacks.
+    allObservers.push_back(std::make_shared<testing::StrictMock<MockFocusManagerObserver>>());
+
+    // Verify that onFocusChanged() callback is invoked.
+    for (auto& observer : allObservers) {
+        m_focusManager->addObserver(observer);
+        observer->expectFocusChange(DIALOG_CHANNEL_NAME, FocusState::NONE);
+    }
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise for AUDIO_CAPTURE, and a
+ * rejected promise otherwise. Expecting the AUDIO_CAPTURE activity to acquire FOREGROUND focus and PRIMARY mixing
+ * behavior. The second activity acquiring focus will fail and see NONE focus state and MUST_STOP mixing behavior.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_PromiseRejected_OtherChannelsActive) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            // E.g. focusRequest.audioAttributes.usage == AudioAttributes::Usage::MEDIA
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::reject(
+                    std::errc::invalid_argument);
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests acquireChannel with a fulfilled FOREGROUND focus and UNDEFINED mixing behavior promise for AUDIO_CAPTURE, and a
+ * rejected promise otherwise. Expecting the AUDIO_CAPTURE activity to acquire FOREGROUND focus and PRIMARY mixing
+ * behavior. The second activity acquiring focus will fail and set focus state to NONE and mixing behavior to MUST_STOP.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_acquireChannel_PromiseRejected_SameChannelIsActive) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            // E.g. focusRequest.audioAttributes.usage == AudioAttributes::Usage::SPEECH
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::reject(
+                    std::errc::invalid_argument);
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::SPEECH}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests stopForegroundActivity with a single FOREGROUND Channel. Expect the channel to be set to NONE focus and
+ * MUST_STOP mixing behavior.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_stopForegroundActivity_ForegroundChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests stopForegroundActivity with a single BACKGROUND Channel. Expect the channel to be set to NONE focus and
+ * MUST_STOP mixing behavior.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_stopForegroundActivity_BackgroundChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertFocusChange(dialogClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(dialogClient);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests stopForegroundActivity with a single FOREGROUND and single BACKGROUND Channel. The BACKGROUND channel must not
+ * be automatically set to FOREGROUND.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_stopForegroundActivity_OneForegroundAndOneBackgroundChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            if (focusRequest.focusRequestMetadata.audioAttributes.usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+                return avsCommon::utils::threading::
+                    Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                            ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+            }
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(
+        dialogClient, ContentType::MIXABLE, std::chrono::milliseconds(0), {AudioAttributes::Usage::AUDIO_CAPTURE}));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertFocusChange(contentClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(contentClient);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+}
+
+/**
+ * Tests stopForegroundActivity with multiple activities on the same Channel. Expect the channel to restore the same
+ * focus state of the previous activity. The acquire channel promise callback will only occur once since the
+ * channel will remain active.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_stopForegroundActivity_MultiActivityChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(0);
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests stopForegroundActivity with multiple activities in the BACKGROUND channel. Expect the channel to restore the
+ * same focus state of the previous activity and to not promote to the FOREGROUND when a higher priority channel is
+ * released. The acquire channel promise callback will only occur twice since one of the channels will remain active.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_stopForegroundActivity_MultiActivityChannel_BackgroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertFocusChange(contentClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(contentClient);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertFocusChange(anotherContentClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(anotherContentClient);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+    assertNoMixingBehaviorOrFocusChange(anotherContentClient);
+
+    m_focusManager->stopForegroundActivity();
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Test stopAllActivities with three channels. Expect all activities to stop.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_stopAllActivities_ThreeChannels) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(3)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(alertsClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(3);
+    m_focusManager->stopAllActivities();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Test stopAllActivities with three channels, one of which has multiple activities. Expect all single activity Channels
+ * to stop. The multiple activity content channel will release the primary activity and update the focus of the
+ * activity to have the same focus as the released primary activity.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_stopAllActivities_ThreeChannelsAndMultiActivity_ForegroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(3)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(alertsClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(2);
+    m_focusManager->stopAllActivities();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Test stopAllActivities with three channels, one of which has multiple activities. Expect all single activity Channels
+ * to stop. The multiple activity content channel will release the primary activity and keep the focus of the activity
+ * the same as the released primary activity.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_stopAllActivities_ThreeChannelsAndMultiActivity_BackgroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(3)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertFocusChange(dialogClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(dialogClient);
+
+    ASSERT_TRUE(acquireChannelHelper(alertsClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertFocusChange(alertsClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(alertsClient);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertFocusChange(contentClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(contentClient);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertNoMixingBehaviorOrFocusChange(alertsClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertFocusChange(anotherContentClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(anotherContentClient);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(2);
+    m_focusManager->stopAllActivities();
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(alertsClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests releaseChannel with a single Channel. Expect that ExternalFocusMediator's onFocusRelease method is called.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_releaseChannel_Success) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    ASSERT_TRUE(m_focusManager->releaseChannel(DIALOG_CHANNEL_NAME, dialogClient).get());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests releaseChannel of the FOREGROUND Channel while another Channel is taken. The originally BACKGROUND focused
+ * channel remains in BACKGROUND focus, while the originally FOREGROUND focused Channel is released. Expect that
+ * ExternalFocusMediator's onFocusRelease method is called.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_releaseForegroundChannel_BackgroundChannelActive) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    ASSERT_TRUE(m_focusManager->releaseChannel(DIALOG_CHANNEL_NAME, dialogClient).get());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+}
+
+/**
+ * Tests releaseChannel on a multi-activity channel with FOREGROUND focus. Expect the BACKGROUND activity to regain
+ * the same focus that the primary activity held before releasing. The acquire channel promise callback will only occur
+ * once since the channel will remain active. Expect that ExternalFocusMediator's onFocusRelease method is called.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_releaseChannel_MultiActivity) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(m_focusManager->releaseChannel(CONTENT_CHANNEL_NAME, anotherContentClient).get());
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    EXPECT_CALL(*m_externalFocusMediator, onFocusRelease(_)).Times(1);
+    ASSERT_TRUE(m_focusManager->releaseChannel(CONTENT_CHANNEL_NAME, contentClient).get());
+    assertNoMixingBehaviorOrFocusChange(anotherContentClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests getActiveChannelStates when there are no active Channels. Expect no Channels to be returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_getActiveChannelStates_NoActiveChannels) {
+    auto activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+}
+
+/**
+ * Tests getActiveChannelStates when there is exactly one Channel active. Expect exactly one Channel to be returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_getActiveChannelStates_ExactlyOneActiveChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    auto activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+}
+
+/**
+ * Tests getActiveChannelStates when there are multiple active Channels. Expect the correct number of active Channels to
+ * be returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_getActiveChannelStates_MultipleActiveChannels) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    auto activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 2);
+}
+
+/**
+ * Tests getActiveChannelStates when there are multiple active Channels and some are released. Expect the correct number
+ * of active Channels to be returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_getActiveChannelStates_MultipleActiveChannels_Releasing) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    auto activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 2);
+
+    ASSERT_TRUE(m_focusManager->releaseChannel(DIALOG_CHANNEL_NAME, dialogClient).get());
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    ASSERT_TRUE(m_focusManager->releaseChannel(CONTENT_CHANNEL_NAME, contentClient).get());
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+}
+
+/**
+ * Tests getActiveChannelStates when there is one multiple activity Channel active. Expect the correct number of active
+ * Channels to be returned and that the non-primary activity acquires the focus of the primary activity released. The
+ * acquire channel promise callback will only occur once since the channel will remain active.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_getActiveChannelStates_MultipleActiveChannels_Stopping) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    auto activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.empty());
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+    activeChannels = m_focusManager->getActiveChannelStates();
+    ASSERT_TRUE(activeChannels.size() == 1);
+
+    m_focusManager->stopForegroundActivity();
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests changeFocusState of an invalid Channel. Expect that no updates to focus are made and a rejected promise is
+ * returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_changeFocusState_InvalidChannel) {
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND);
+    auto changeFocusPromise = m_focusManager->changeFocusState(INCORRECT_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isRejected());
+}
+
+/**
+ * Tests changeFocusState of an inactive Channel. Expect that no updates to focus are made and a rejected promise is
+ * returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_changeFocusState_InactiveChannel) {
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND);
+    auto changeFocusPromise = m_focusManager->changeFocusState(DIALOG_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isRejected());
+}
+
+/**
+ * Tests changeFocusState of a BACKGROUND focused Channel with UNDEFINED mixing behavior. Expect that the new focus
+ * state (FOREGROUND) as well as the default mixing behavior for FOREGROUND channels (PRIMARY) is set.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_changeFocusState_ForegroundFocus) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertFocusChange(dialogClient, FocusState::BACKGROUND);
+    assertNoMixingBehaviorChange(dialogClient);
+
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND);
+
+    auto changeFocusPromise = m_focusManager->changeFocusState(DIALOG_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isFulfilled());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+}
+
+/**
+ * Tests changeFocusState of a FOREGROUND focused Channel with PRIMARY mixing behavior. Expect the new focus state
+ * BACKGROUND and MAY_DUCK mixing behavior.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_changeFocusState_BackgroundFocusAndMayDuckMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK);
+
+    auto changeFocusPromise = m_focusManager->changeFocusState(DIALOG_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isFulfilled());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests changeFocusState of a FOREGROUND focused Channel with PRIMARY mixing behavior. Expect that the new focus state
+ * (BACKGROUND) as well as the new mixing behavior (MUST_PAUSE) is set.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_changeFocusState_BackgroundFocusAndMustPauseMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND,
+        ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE);
+
+    auto changeFocusPromise = m_focusManager->changeFocusState(DIALOG_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isFulfilled());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+}
+
+/**
+ * Tests changeFocusState of a FOREGROUND focused CHANNEL with PRIMARY mixing behavior. Expect the new focus state
+ * BACKGROUND and MAY_DUCK mixing behavior.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_changeFocusState_BackgroundFocusAndNullMixingBehavior) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto newExternalFocus = ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+        ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND);
+
+    auto changeFocusPromise = m_focusManager->changeFocusState(DIALOG_CHANNEL_NAME, newExternalFocus);
+    EXPECT_TRUE(changeFocusPromise.awaitFor(PROMISE_TIMOUT).isFulfilled());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+}
+
+/**
+ * Tests releaseChannel (ExternalFocusMediatorCallbackInterface) with a single Channel. Expect that the Channel is
+ * correctly released and that the promise is in pending state.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_mediatorReleaseFocus_Success) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto releaseChannelPromise = m_focusManager->mediatorReleaseFocus(DIALOG_CHANNEL_NAME);
+    EXPECT_TRUE(releaseChannelPromise.awaitFor(PROMISE_TIMOUT).isResolved());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests releaseChannel (ExternalFocusMediatorCallbackInterface) with a single Multi-Activity Channel. Expect that the
+ * Channel is completely released and that the promise is in pending state. The acquire channel promise callback will
+ * only occur once since the channel will remain active.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_mediatorReleaseFocus_MultiActivityChannel) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(1)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(anotherContentClient, ContentType::MIXABLE, PATIENCE_DURATION_TIMEOUT));
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MUST_PAUSE);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto releaseChannelPromise = m_focusManager->mediatorReleaseFocus(CONTENT_CHANNEL_NAME);
+    EXPECT_TRUE(releaseChannelPromise.awaitFor(PROMISE_TIMOUT).isResolved());
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertMixingBehaviorAndFocusChange(anotherContentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests releaseChannel (ExternalFocusMediatorCallbackInterface) with a Channel that does not exist. Expect that there
+ * is no change in focus state or mixing behavior and that a rejected promise is returned.
+ */
+TEST_F(FocusManagerWithExternalFocusMediatorEnabledTest, test_mediatorReleaseFocus_ChannelDoesNotExist) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    auto releaseChannelPromise = m_focusManager->mediatorReleaseFocus(DIFFERENT_DIALOG_INTERFACE_NAME);
+    EXPECT_TRUE(releaseChannelPromise.awaitFor(PROMISE_TIMOUT).isRejected());
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+}
+
+/**
+ * Tests releaseChannel (ExternalFocusMediatorCallbackInterface) with multiple Channels. Expect that the Channel is
+ * correctly released, the next highest priority channel is not automatically foregrounded and that the promise is
+ * in pending state.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_mediatorReleaseFocus_BackgroundFocus_ForegroundChannelIsTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    auto releaseChannelPromise = m_focusManager->mediatorReleaseFocus(CONTENT_CHANNEL_NAME);
+    EXPECT_TRUE(releaseChannelPromise.isPending());
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+}
+
+/**
+ * Tests releaseChannel (ExternalFocusMediatorCallbackInterface) with multiple Channels. Expect that the Channel is
+ * correctly released, the next highest priority channel is not automatically foregrounded and that the promise is
+ * in pending state.
+ */
+TEST_F(
+    FocusManagerWithExternalFocusMediatorEnabledTest,
+    test_mediatorReleaseFocus_ForegroundFocus_BackgroundChannelTaken) {
+    EXPECT_CALL(*m_externalFocusMediator, acquireFocus(_))
+        .Times(2)
+        .WillRepeatedly(Invoke([](const avsCommon::avs::FocusRequest& focusRequest) {
+            return avsCommon::utils::threading::
+                Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>::resolveEmplace(
+                    ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus(
+                        ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND));
+        }));
+
+    ASSERT_TRUE(acquireChannelHelper(dialogClient, ContentType::MIXABLE));
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+
+    ASSERT_TRUE(acquireChannelHelper(contentClient, ContentType::MIXABLE));
+    assertNoMixingBehaviorOrFocusChange(dialogClient);
+    assertMixingBehaviorAndFocusChange(contentClient, FocusState::BACKGROUND, MixingBehavior::MAY_DUCK);
+
+    auto releaseChannelPromise = m_focusManager->mediatorReleaseFocus(DIALOG_CHANNEL_NAME);
+    EXPECT_TRUE(releaseChannelPromise.awaitFor(PROMISE_TIMOUT).isResolved());
+    assertMixingBehaviorAndFocusChange(dialogClient, FocusState::NONE, MixingBehavior::MUST_STOP);
+    assertNoMixingBehaviorOrFocusChange(contentClient);
+}
+
 }  // namespace test
 }  // namespace afml
 }  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AudioAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AudioAttributes.h
new file mode 100644
index 00000000..42b775aa
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AudioAttributes.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AUDIOATTRIBUTES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AUDIOATTRIBUTES_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/**
+ * A representation of the Audio Attributes.
+ */
+struct AudioAttributes {
+    /**
+     * An enum class used to specify the audio usage of a component.
+     */
+    enum class Usage {
+        /// The default Usage value, used when no Usage is defined.
+        UNKNOWN,
+
+        /// The Usage value used when the usage is an alarm.
+        ALARM,
+
+        /// The Usage value used when the usage is capturing and interacting with user speech.
+        AUDIO_CAPTURE,
+
+        /// The Usage value used when the usage is voice communications, such as telephony or VoIP.
+        COMMUNICATION,
+
+        /// The Usage value used when the usage is media, such as music or audio tracks.
+        MEDIA,
+
+        /// The Usage value used when the usage is a notification.
+        NOTIFICATION,
+
+        /// The Usage value used when the usage is a audio response to user queries, or audio instructions.
+        SPEECH
+    };
+
+    /// Audio attribute representing the usage.
+    Usage usage;
+
+// GCC 4.x and 5.x reached end of support before some of c++11 amendments were made. In particular, these compilers
+// do not have default constructors for list initialization from aggregates. This issue has been addressed in GCC 6.x.
+// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467
+#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ < 6)
+    /**
+     * Copy constructor.
+     *
+     * This constructor is required only for GCC before version 6.x.
+     *
+     * @param[in] audioAttributes The audio attibutes.
+     *
+     * @see http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467
+     */
+    AudioAttributes(const AudioAttributes& audioAttributes);
+
+    /**
+     * Explicit constructor with parameters.
+     *
+     * This constructor is required only for GCC before version 6.x.
+     *
+     * @param[in] usage Audio attribute representing the usage.
+     *
+     * @see http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467
+     */
+    AudioAttributes(Usage usage);
+#endif
+};
+
+/**
+ * This function converts the provided @c Usage to a @c std::string.
+ *
+ * @param usage The @c usage to convert to a @c std::string.
+ * @param usageStr[out] The @c std::string conversion of @c Usage.
+ * @return Whether the operation was successful. If unsuccessful, @c usageStr's value is left unchanged.
+ */
+inline bool audioAttributesUsageToString(const AudioAttributes::Usage usage, std::string& usageStr) {
+    if (usage == AudioAttributes::Usage::UNKNOWN) {
+        usageStr = "UNKNOWN";
+    } else if (usage == AudioAttributes::Usage::ALARM) {
+        usageStr = "ALARM";
+    } else if (usage == AudioAttributes::Usage::AUDIO_CAPTURE) {
+        usageStr = "AUDIO_CAPTURE";
+    } else if (usage == AudioAttributes::Usage::COMMUNICATION) {
+        usageStr = "COMMUNICATION";
+    } else if (usage == AudioAttributes::Usage::MEDIA) {
+        usageStr = "MEDIA";
+    } else if (usage == AudioAttributes::Usage::NOTIFICATION) {
+        usageStr = "NOTIFICATION";
+    } else if (usage == AudioAttributes::Usage::SPEECH) {
+        usageStr = "SPEECH";
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function derives an @c Usage from a @c std::string.
+ *
+ * @param usageStr The string representation of @c Usage.
+ * @param usage[out] The @c Usage derived from a @c std::string.
+ * @return Whether the operation was successful. If unsuccessful, @c usage's value is not guaranteed.
+ */
+inline bool audioAttributesUsageFromString(const std::string& usageStr, AudioAttributes::Usage& usage) {
+    if ("UNKNOWN" == usageStr) {
+        usage = AudioAttributes::Usage::UNKNOWN;
+    } else if ("ALARM" == usageStr) {
+        usage = AudioAttributes::Usage::ALARM;
+    } else if ("AUDIO_CAPTURE" == usageStr) {
+        usage = AudioAttributes::Usage::AUDIO_CAPTURE;
+    } else if ("COMMUNICATION" == usageStr) {
+        usage = AudioAttributes::Usage::COMMUNICATION;
+    } else if ("MEDIA" == usageStr) {
+        usage = AudioAttributes::Usage::MEDIA;
+    } else if ("NOTIFICATION" == usageStr) {
+        usage = AudioAttributes::Usage::NOTIFICATION;
+    } else if ("SPEECH" == usageStr) {
+        usage = AudioAttributes::Usage::SPEECH;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AUDIOATTRIBUTES_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/FocusRequest.h b/AVSCommon/AVS/include/AVSCommon/AVS/FocusRequest.h
new file mode 100644
index 00000000..e7eb0387
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/FocusRequest.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_FOCUSREQUEST_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_FOCUSREQUEST_H_
+
+#include <chrono>
+#include <string>
+
+#include <AVSCommon/AVS/AudioAttributes.h>
+#include <AVSCommon/AVS/ContentType.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/**
+ * Focus Request containing focus request id and focus request metadata.
+ */
+struct FocusRequest {
+    /**
+     * A representation of Focus Request Metadata.
+     */
+    struct FocusRequestMetadata {
+        /**
+         * Constructs a new FocusRequestMetadata object.
+         *
+         * @param channelName The channel name.
+         * @param priority The channel priority.
+         * @param audioAttributes The audio attributes.
+         * @param patienceDuration The duration of patience in milliseconds of the activity.
+         * @param contentType The content type of the activity.
+         */
+        FocusRequestMetadata(
+            const std::string& channelName,
+            unsigned int priority,
+            const avsCommon::avs::AudioAttributes& audioAttributes,
+            const std::chrono::milliseconds& patienceDuration,
+            avsCommon::avs::ContentType contentType) :
+                channelName{channelName},
+                priority{priority},
+                audioAttributes{audioAttributes},
+                patienceDuration{patienceDuration},
+                contentType{contentType} {
+        }
+
+        /// The name of the Channel.
+        std::string channelName;
+
+        /// The priority of the Channel.
+        unsigned int priority;
+
+        /// The audio attributes of the component that is requesting focus.
+        avsCommon::avs::AudioAttributes audioAttributes;
+
+        /// The duration of patience in milliseconds of the activity.
+        /// This is used for an incoming activity to not kick out the existing activity until the duration of the timer
+        /// concludes.
+        std::chrono::milliseconds patienceDuration;
+
+        /// The content type of the activity.
+        avsCommon::avs::ContentType contentType;
+    };
+
+    /**
+     * Constructs a new FocusRequest object.
+     *
+     * @param focusRequestId The FocusRequest's id.
+     * @param focusRequestMetadata The FocusRequest's metadata.
+     */
+    FocusRequest(const std::string& focusRequestId, const FocusRequestMetadata& focusRequestMetadata) :
+            focusRequestId{focusRequestId},
+            focusRequestMetadata{focusRequestMetadata} {
+    }
+
+    /// A focus request id.
+    std::string focusRequestId;
+
+    /// The metadata associated with a focus request.
+    FocusRequestMetadata focusRequestMetadata;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_FOCUSREQUEST_H_
diff --git a/AVSCommon/AVS/src/AudioAttributes.cpp b/AVSCommon/AVS/src/AudioAttributes.cpp
new file mode 100644
index 00000000..2d144549
--- /dev/null
+++ b/AVSCommon/AVS/src/AudioAttributes.cpp
@@ -0,0 +1,37 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/AudioAttributes.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+// GCC 4.x and 5.x reached end of support before some of c++11 amendments were made. In particular, these compilers
+// do not have default constructors for list initialization from aggregates. This issue has been addressed in GCC 6.x.
+// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467
+#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ < 6)
+
+AudioAttributes::AudioAttributes(Usage usage) : usage{usage} {
+}
+
+AudioAttributes::AudioAttributes(const AudioAttributes& audioAttributes) : usage{audioAttributes.usage} {
+}
+
+#endif
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index f581277b..7408b1c7 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -114,7 +114,7 @@ void DialogUXStateAggregator::addObserver(std::shared_ptr<DialogUXStateObserverI
         ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
         return;
     }
-    m_executor.submit([this, observer]() {
+    m_executor.execute([this, observer]() {
         m_observers.insert(observer);
         observer->onDialogUXStateChanged(m_currentState);
     });
@@ -131,7 +131,7 @@ void DialogUXStateAggregator::removeObserver(std::shared_ptr<DialogUXStateObserv
 void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterface::State state) {
     ACSDK_DEBUG0(LX("onStateChanged").d("AudioInputProcessorState", state));
     m_audioInputProcessorState = state;
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         ACSDK_DEBUG0(LX("onStateChangedLambda").d("AudioInputProcessorState", state));
         switch (state) {
             case AudioInputProcessorObserverInterface::State::IDLE:
@@ -168,7 +168,7 @@ void DialogUXStateAggregator::onStateChanged(
     const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) {
     ACSDK_DEBUG0(LX("onStateChanged").d("SpeechSynthesizerState", state));
     m_speechSynthesizerState = state;
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         ACSDK_DEBUG0(LX("onStateChangedLambda").d("SpeechSynthesizerState", state));
         switch (state) {
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
@@ -222,7 +222,7 @@ void DialogUXStateAggregator::onConnectionStatusChanged(
     const DialogUXStateAggregator::Status status,
     const std::vector<DialogUXStateAggregator::EngineConnectionStatus>& engineStatuses) {
     ACSDK_DEBUG(LX("onConnectionStatusChanged").d("engineAggregatedStatus", status));
-    m_executor.submit([this, engineStatuses]() {
+    m_executor.execute([this, engineStatuses]() {
         bool isDisconnected = true;
         for (const auto& engineStatus : engineStatuses) {
             ACSDK_DEBUG(LX("onConnectionStatusChangedLambda")
@@ -244,7 +244,7 @@ void DialogUXStateAggregator::onConnectionStatusChanged(
 
 void DialogUXStateAggregator::onRequestProcessingStarted() {
     ACSDK_DEBUG0(LX("onRequestProcessingStarted"));
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
         // Stop the listening timer
         m_listeningTimeoutTimer.stop();
@@ -274,7 +274,7 @@ void DialogUXStateAggregator::onRequestProcessingStarted() {
 
 void DialogUXStateAggregator::onRequestProcessingCompleted() {
     ACSDK_DEBUG(LX("onRequestProcessingCompleted"));
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
             /// It is possible that the cloud sends RPC without sending RPS. In those situations, if we are in
             /// LISTENING state, switch back to IDLE.
@@ -295,7 +295,7 @@ void DialogUXStateAggregator::notifyObserversOfState() {
 
 void DialogUXStateAggregator::transitionFromThinkingTimedOut() {
     ACSDK_DEBUG5(LX("transitionFromThinkingTimedOut"));
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         ACSDK_DEBUG5(LX("transitionFromThinkingTimedOutExecutor").d("m_currentState", m_currentState));
         if (DialogUXStateObserverInterface::DialogUXState::THINKING == m_currentState) {
             ACSDK_DEBUG(LX("transitionFromThinkingTimedOut"));
@@ -308,7 +308,7 @@ void DialogUXStateAggregator::transitionFromThinkingTimedOut() {
 
 void DialogUXStateAggregator::transitionFromListeningTimedOut() {
     ACSDK_DEBUG5(LX("transitionFromListeningTimedOut"));
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         ACSDK_DEBUG5(LX("transitionFromListeningTimedOutExecutor").d("m_currentState", m_currentState));
         if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
             ACSDK_DEBUG(LX("transitionFromListeningTimedOut"));
@@ -321,7 +321,7 @@ void DialogUXStateAggregator::transitionFromListeningTimedOut() {
 
 void DialogUXStateAggregator::tryEnterIdleStateOnTimer() {
     ACSDK_DEBUG5(LX("tryEnterIdleStateOnTimer"));
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         ACSDK_DEBUG5(LX("tryEnterIdleStateOnTimerExecutor")
                          .d("m_currentState", m_currentState)
                          .d("m_audioInputProcessorState", m_audioInputProcessorState)
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index 0ff9cb43..cdda58fb 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -40,11 +40,11 @@ add_library(AVSCommon
     AVS/src/NamespaceAndName.cpp
     AVS/src/EditableMessageRequest.cpp
     AVS/src/WaitableMessageRequest.cpp
+    AVS/src/AudioAttributes.cpp
     Utils/src/Bluetooth/SDPRecords.cpp
     Utils/src/BluetoothEventBus.cpp
     Utils/src/Configuration/ConfigurationNode.cpp
     Utils/src/DeviceInfo.cpp
-    Utils/src/Executor.cpp
     Utils/src/FileUtils.cpp
     Utils/src/FormattedAudioStreamAdapter.cpp
     Utils/src/JSON/JSONGenerator.cpp
@@ -106,6 +106,12 @@ add_library(AVSCommon
     Utils/src/TaskThread.cpp
     Utils/src/ThreadPool.cpp
     Utils/src/Threading/ConditionVariableWrapper.cpp
+    Utils/src/Threading/ExecutorFactory.cpp
+    Utils/src/Threading/Executor.cpp
+    Utils/src/Threading/PromiseCommon.cpp
+    Utils/src/Threading/PromiseResolverCommon.cpp
+    Utils/src/Threading/PromiseState.cpp
+    Utils/src/Threading/SharedExecutor.cpp
     Utils/src/TimePoint.cpp
     Utils/src/TimeUtils.cpp
     Utils/src/Timer.cpp
@@ -127,6 +133,8 @@ target_include_directories(AVSCommon PUBLIC
     "${MultipartParser_SOURCE_DIR}"
     ${CURL_INCLUDE_DIRS})
 
+target_include_directories(AVSCommon PRIVATE "${AVSCommon_SOURCE_DIR}/Utils/privateInclude")
+
 if (MSVC)
     target_include_directories(AVSCommon PUBLIC
             "${CMAKE_CURRENT_BINARY_DIR}/exports")
@@ -145,6 +153,7 @@ target_link_libraries(AVSCommon
     ${CURL_LIBRARIES}
     acsdkApplicationAudioPipelineFactoryInterfaces
     acsdkEqualizerInterfaces
+    acsdkNotificationsInterfaces
     acsdkInteractionModelInterfaces
     )
 
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextRequesterInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextRequesterInterface.h
index 246dc3d0..e8d64cd0 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextRequesterInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextRequesterInterface.h
@@ -84,7 +84,7 @@ public:
      */
     virtual void onContextAvailable(
         const endpoints::EndpointIdentifier& endpointId,
-        const avs::AVSContext& endpointContext,
+        const std::shared_ptr<avs::AVSContext>& endpointContext,
         ContextRequestToken requestToken);
 
     /**
@@ -141,9 +141,9 @@ inline void ContextRequesterInterface::onContextAvailable(const std::string& jso
 
 inline void ContextRequesterInterface::onContextAvailable(
     const endpoints::EndpointIdentifier& endpointId,
-    const avs::AVSContext& endpointContext,
+    const std::shared_ptr<avs::AVSContext>& endpointContext,
     ContextRequestToken requestToken) {
-    onContextAvailable(endpointContext.toJson());
+    onContextAvailable(endpointContext->toJson());
 }
 
 inline void ContextRequesterInterface::onContextFailure(const ContextRequestError error) {
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DoNotDisturbSettingObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DoNotDisturbSettingObserverInterface.h
new file mode 100644
index 00000000..c342e81b
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DoNotDisturbSettingObserverInterface.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_DONOTDISTURBSETTINGOBSERVERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_DONOTDISTURBSETTINGOBSERVERINTERFACE_H_
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+class DoNotDisturbSettingObserverInterface {
+public:
+    virtual ~DoNotDisturbSettingObserverInterface() = default;
+
+    virtual void onDoNotDisturbSettingChanged(const bool& value) = 0;
+};
+
+}
+}
+}
+
+#endif // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_DONOTDISTURBSETTINGOBSERVERINTERFACE_H_
\ No newline at end of file
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorCallbackInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorCallbackInterface.h
new file mode 100644
index 00000000..a575a634
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorCallbackInterface.h
@@ -0,0 +1,344 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORCALLBACKINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORCALLBACKINTERFACE_H_
+
+#include <ostream>
+#include <string>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/FocusRequest.h>
+#include <AVSCommon/AVS/FocusState.h>
+#include <AVSCommon/AVS/MixingBehavior.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+/**
+ * The External Focus Mediator Callback Interface enables the external system to notify the Focus Manager of any updates
+ * to the state of a channel, resulting from focus requests/releases from other applications in the system.
+ */
+class ExternalFocusMediatorCallbackInterface {
+public:
+    /**
+     * An enum class used to specify the levels of external focus that a channel can have.
+     */
+    enum class ExternalFocusState {
+        /// Represents the highest focus a channel can have.
+        FOREGROUND,
+
+        /// Represents the intermediate level focus a channel can have.
+        BACKGROUND
+    };
+
+    /**
+     * An enum class used to specify the external mixing behavior that a channel can have.
+     */
+    enum class ExternalMixingBehavior {
+        /// Indicates that the corresponding activity may duck.
+        MAY_DUCK,
+
+        /// Indicates that the corresponding activity must pause.
+        MUST_PAUSE,
+
+        /// Indicates that the corresponding activity does not have a defined behavior.
+        UNDEFINED
+    };
+
+    /**
+     * A representation of the focus and mixing behavior of a channel compatible with the External Focus Mediator.
+     */
+    struct ExternalFocusMediatorFocus {
+        /**
+         * Constructs a new ExternalFocusMediatorFocus object.
+         *
+         * @param externalFocusState The ExternalFocusMediatorFocus's external focus state.
+         * @param externalMixingBehavior The ExternalFocusMediatorFocus's external mixing behavior.
+         */
+        ExternalFocusMediatorFocus(
+            ExternalFocusState externalFocusState,
+            ExternalMixingBehavior externalMixingBehavior = ExternalMixingBehavior::UNDEFINED) :
+                externalFocusState{externalFocusState},
+                externalMixingBehavior{externalMixingBehavior} {
+        }
+
+        /// External Focus State
+        ExternalFocusState externalFocusState;
+
+        /// External Mixing Behavior
+        ExternalMixingBehavior externalMixingBehavior;
+    };
+
+    /// Destructor
+    virtual ~ExternalFocusMediatorCallbackInterface() = default;
+
+    /**
+     * A function the external focus mediator calls to fetch the @c ExternalFocusMediatorFocus of all active channels.
+     *
+     * @return A map of @c ExternalFocusMediatorFocus, with the key being the channel name. If an error occurs an empty
+     * map will be returned.
+     */
+    virtual std::unordered_map<std::string, ExternalFocusMediatorFocus> getActiveChannelStates() = 0;
+
+    /**
+     * A function the external focus mediator calls to change the focus of a channel.
+     *
+     * The following external focus states are acceptable:
+     * @code
+     *     {ExternalFocusState::FOREGROUND, ExternalMixingBehavior::UNDEFINED}
+     *     {ExternalFocusState::BACKGROUND, ExternalMixingBehavior::MAY_DUCK}
+     *     {ExternalFocusState::BACKGROUND, ExternalMixingBehavior::MUST_PAUSE}
+     *     {ExternalFocusState::BACKGROUND, ExternalMixingBehavior::UNDEFINED}
+     * @endcode
+     *
+     * Invalid external focus states are subject to default to the following for FOREGROUND/BACKGROUND states:
+     * @code
+     *     {ExternalFocusState::FOREGROUND, ExternalMixingBehavior::UNDEFINED}
+     *     {ExternalFocusState::BACKGROUND, ExternalMixingBehavior::UNDEFINED}
+     * @endcode
+     *
+     * @note It is possible that the requested Focus state may be demoted to respect the channel priorities and
+     * interrupt model. For example: A request for FOREGROUND focus from a lower priority channel, while a higher
+     * priority channel holds FOREGROUND focus, will result in the lower priority Channel being set to a BACKGROUND
+     * focus. ExternalFocusMediatorInterface implementations must ensure they have a mechanism to retrieve the correct
+     * state from the ExternalFocusMediatorCallbackInterface.
+     *
+     * @param focusRequest Focus request id relating to the channel acquiring focus.
+     * @param externalFocus The external focus state to change to.
+     * @return A Promise indicating if it is fulfilled, or an error condition if it is rejected.
+     */
+    virtual utils::threading::Promise<void> changeFocusState(
+        const std::string& focusRequestId,
+        const ExternalFocusMediatorFocus& externalFocus) = 0;
+
+    /**
+     * A function the external focus mediator calls to request that FocusManager releases a channel, thus stopping
+     * playback of content in the requested channel.
+     *
+     * @param focusRequest Focus request id relating to the channel releasing focus.
+     * @return A Promise indicating if it is fulfilled, or an error condition if it is rejected.
+     */
+    virtual utils::threading::Promise<void> mediatorReleaseFocus(const std::string& focusRequestId) = 0;
+};
+
+/**
+ * This function converts the provided @c ExternalFocusState to an AVS @c FocusState.
+ *
+ * @param externalFocusState The @c ExternalFocusState to convert to an AVS @c FocusState.
+ * @param focusState[out] The AVS @c FocusState representation of the @c ExternalFocusState.
+ * @return Whether the operation was successful. If unsuccessful, @c focusState's value is not guaranteed.
+ */
+inline bool externalFocusStateToFocusState(
+    const ExternalFocusMediatorCallbackInterface::ExternalFocusState& externalFocusState,
+    avs::FocusState& focusState) {
+    if (externalFocusState == ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND) {
+        focusState = avs::FocusState::FOREGROUND;
+    } else if (externalFocusState == ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND) {
+        focusState = avs::FocusState::BACKGROUND;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function converts the provided @c FocusState to an @c ExternalFocusState.
+ *
+ * @param focusState The @c FocusState to convert to an @c ExternalFocusState.
+ * @param externalFocusState[out] The @c ExternalFocusState representation of the @c FocusState.
+ * @return Whether the operation was successful. If unsuccessful, @c externalFocusState's value is not guaranteed.
+ */
+inline bool externalFocusStateFromFocusState(
+    const avs::FocusState& focusState,
+    ExternalFocusMediatorCallbackInterface::ExternalFocusState& externalFocusState) {
+    if (focusState == avs::FocusState::FOREGROUND) {
+        externalFocusState = ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND;
+    } else if (focusState == avs::FocusState::BACKGROUND) {
+        externalFocusState = ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function converts the provided @c ExternalFocusState to a @c std::string.
+ *
+ * @param externalFocusState The @c ExternalFocusState to convert to a @c std::string.
+ * @param externalFocusStateStr[out] The @c std::string conversion of @c externalFocusState.
+ * @return Whether the operation was successful. If unsuccessful, @c externalFocusStateStr's value is left unchanged.
+ */
+inline bool externalFocusStateToString(
+    const ExternalFocusMediatorCallbackInterface::ExternalFocusState& externalFocusState,
+    std::string& externalFocusStateStr) {
+    if (externalFocusState == ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND) {
+        externalFocusStateStr = "FOREGROUND";
+    } else if (externalFocusState == ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND) {
+        externalFocusStateStr = "BACKGROUND";
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function derives an @c ExternalFocusState from a @c std::string.
+ *
+ * @param externalFocusStateStr The string representation of @c externalFocusState.
+ * @param externalFocusState[out] The @c ExternalFocusState derived from a @c std::string.
+ * @return Whether the operation was successful. If unsuccessful, @c externalFocusState's value is not guaranteed.
+ */
+inline bool externalFocusStateFromString(
+    const std::string& externalFocusStateStr,
+    ExternalFocusMediatorCallbackInterface::ExternalFocusState& externalFocusState) {
+    if ("FOREGROUND" == externalFocusStateStr) {
+        externalFocusState = ExternalFocusMediatorCallbackInterface::ExternalFocusState::FOREGROUND;
+    } else if ("BACKGROUND" == externalFocusStateStr) {
+        externalFocusState = ExternalFocusMediatorCallbackInterface::ExternalFocusState::BACKGROUND;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * Write an @c ExternalFocusState value to an @c ostream as a string.
+ *
+ * @param stream The stream to write the value to.
+ * @param externalFocusState The @c ExternalFocusState value to write to the @c ostream as a string.
+ * @return The @c ostream that was passed in and written to.
+ */
+inline std::ostream& operator<<(
+    std::ostream& stream,
+    const ExternalFocusMediatorCallbackInterface::ExternalFocusState& externalFocusState) {
+    std::string externalFocusStateStr;
+    externalFocusStateToString(externalFocusState, externalFocusStateStr);
+    return stream << externalFocusStateStr;
+}
+
+/**
+ * This function converts the provided @c ExternalMixingBehavior to an AVS @c MixingBehavior.
+ *
+ * @param externalMixingBehavior The @c ExternalMixingBehavior to convert to an AVS @c MixingBehavior.
+ * @param mixingBehavior[out] The AVS @c MixingBehavior representation of the @c ExternalMixingBehavior.
+ * @return Whether the operation was successful. If unsuccessful, @c mixingBehavior's value is not guaranteed.
+ */
+inline bool externalMixingBehaviorToMixingBehavior(
+    const ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior& externalMixingBehavior,
+    avs::MixingBehavior& mixingBehavior) {
+    if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK) {
+        mixingBehavior = avs::MixingBehavior::MAY_DUCK;
+    } else if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE) {
+        mixingBehavior = avs::MixingBehavior::MUST_PAUSE;
+    } else if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::UNDEFINED) {
+        mixingBehavior = avs::MixingBehavior::UNDEFINED;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function converts the provided @c MixingBehavior to an @c ExternalMixingBehavior.
+ *
+ * @param mixingBehavior The @c MixingBehavior to convert to an @c ExternalMixingBehavior.
+ * @param externalMixingBehavior[out] The @c ExternalMixingBehavior representation of the @c MixingBehavior.
+ * @return Whether the operation was successful. If unsuccessful, @c externalMixingBehavior's value is set to UNDEFINED
+ * by default.
+ */
+inline bool externalMixingBehaviorFromMixingBehavior(
+    const avs::MixingBehavior& mixingBehavior,
+    ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior& externalMixingBehavior) {
+    if (mixingBehavior == avs::MixingBehavior::MAY_DUCK) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK;
+    } else if (mixingBehavior == avs::MixingBehavior::MUST_PAUSE) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE;
+    } else if (mixingBehavior == avs::MixingBehavior::UNDEFINED) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::UNDEFINED;
+    } else {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::UNDEFINED;
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function converts the provided @c ExternalMixingBehavior to a @c std::string.
+ *
+ * @param externalMixingBehavior The @c externalMixingBehavior to convert to a @c std::string.
+ * @param externalMixingBehaviorStr[out] The @c std::string conversion of @c externalMixingBehavior.
+ * @return Whether the operation was successful. If unsuccessful, @c externalMixingBehaviorStr's value is left
+ * unchanged.
+ */
+inline bool externalMixingBehaviorToString(
+    const ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior externalMixingBehavior,
+    std::string& externalMixingBehaviorStr) {
+    if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK) {
+        externalMixingBehaviorStr = "MAY_DUCK";
+    } else if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE) {
+        externalMixingBehaviorStr = "MUST_PAUSE";
+    } else if (externalMixingBehavior == ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::UNDEFINED) {
+        externalMixingBehaviorStr = "UNDEFINED";
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * This function derives an @c ExternalMixingBehavior from a @c std::string.
+ *
+ * @param externalMixingBehaviorStr The string representation of @c externalMixingBehavior.
+ * @param externalMixingBehavior[out] The @c ExternalMixingBehavior derived from a @c std::string.
+ * @return Whether the operation was successful. If unsuccessful, @c externalMixingBehavior's value is not guaranteed.
+ */
+inline bool externalMixingBehaviorFromString(
+    const std::string& externalMixingBehaviorStr,
+    ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior& externalMixingBehavior) {
+    if ("MAY_DUCK" == externalMixingBehaviorStr) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MAY_DUCK;
+    } else if ("MUST_PAUSE" == externalMixingBehaviorStr) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::MUST_PAUSE;
+    } else if ("UNDEFINED" == externalMixingBehaviorStr) {
+        externalMixingBehavior = ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior::UNDEFINED;
+    } else {
+        return false;
+    }
+    return true;
+}
+
+/**
+ * Write an @c ExternalMixingBehavior value to an @c ostream as a string.
+ *
+ * @param stream The stream to write the value to.
+ * @param externalMixingBehavior The @c ExternalMixingBehavior value to write to the @c ostream as a string.
+ * @return The @c ostream that was passed in and written to.
+ */
+inline std::ostream& operator<<(
+    std::ostream& stream,
+    const ExternalFocusMediatorCallbackInterface::ExternalMixingBehavior& externalMixingBehavior) {
+    std::string externalMixingBehaviorStr;
+    externalMixingBehaviorToString(externalMixingBehavior, externalMixingBehaviorStr);
+    return stream << externalMixingBehaviorStr;
+}
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORCALLBACKINTERFACE_H_
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h
new file mode 100644
index 00000000..dca9a6a4
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h
@@ -0,0 +1,115 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORINTERFACE_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/AVS/FocusRequest.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorCallbackInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+/**
+ * The ExternalFocusMediatorInterface enables communication with an external focus system. The system integrator is
+ * responsible for implementing this interface. The External Focus Mediator utilizes the
+ * ExternalFocusMediatorCallbackInterface to request changes in Channel Focus, or to release Channel Focus. The
+ * following operations are provided:
+ *
+ * initialize - Initialization of the External Focus Mediator with the ExternalFocusMediatorCallbackInterface and
+ * Channel Configurations.
+ *
+ * acquireFocus - Enables the External Focus Mediator to resolve/reject focus requests from a Focus System.
+ *
+ * onFocusRelease - Receive notifications when focus has been completely released.
+ *
+ * @note The External Focus Mediator will not be provided any automatic promotion of Channels. For instance, if a
+ * FOREGROUND Channel is released, a lower priority Channel in BACKGROUND will not be automatically set to the
+ * FOREGROUND. It is the responsibility of the External Focus Mediator to explicitly make this call using the
+ * changeFocusState() method provided by the ExternalFocusMediatorCallbackInterface.
+ */
+class ExternalFocusMediatorInterface {
+public:
+    /**
+     * The configuration used by the ExternalFocusMediator containing all channels in FocusManager. This configuration
+     * is static and does not change.
+     */
+    struct CallbackChannelConfiguration {
+        /**
+         * Constructs a new CallbackChannelConfiguration object.
+         *
+         * @param channelName The CallbackChannelConfiguration's name of the channel.
+         * @param priority The CallbackChannelConfiguration's priority of the channel.
+         */
+        CallbackChannelConfiguration(const std::string& channelName, const unsigned int priority) :
+                channelName{channelName},
+                priority{priority} {
+        }
+
+        /// The name of the channel
+        const std::string channelName;
+
+        /// The priority of the channel
+        const unsigned int priority;
+    };
+
+    /// Destructor.
+    virtual ~ExternalFocusMediatorInterface() = default;
+
+    /**
+     * This function is called at startup to initialize the external focus mediator by passing in the
+     * @c ExternalFocusMediatorCallbackInterface and @c CallbackChannelConfiguration to the abstraction.
+     *
+     * @param callbackInterface The callback interface used by the external focus mediator interface to perform actions
+     * on the FocusManager.
+     * @param callbackChannelConfigurations The channel information present in the FocusManager.
+     * @return Whether the initialization was successful.
+     */
+    virtual bool initialize(
+        const std::shared_ptr<ExternalFocusMediatorCallbackInterface>& callbackInterface,
+        const std::vector<CallbackChannelConfiguration>& callbackChannelConfigurations) = 0;
+
+    /**
+     * This function is called so that the FocusManager requests focus of an audio channel. The external focus mediator
+     * can reject the focus request by rejecting the promise. Otherwise, if focus is granted, the external focus
+     * mediator can fulfill the promise with the initial @c ExternalFocusMediatorFocusState.
+     *
+     * @param focusRequest Focus request containing channel metadata related to the channel acquiring focus.
+     * @return A Promise containing the @c ExternalFocusMediatorFocus if it is fulfilled, or an error condition if it is
+     * rejected. The external focus mediator must either fulfill or reject the promise.
+     */
+    virtual utils::threading::Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus> acquireFocus(
+        const avsCommon::avs::FocusRequest& focusRequest) = 0;
+
+    /**
+     * This function is called to notify the ExternalFocusMediator that a Channel has released focus on an audio
+     * channel completely. It is the responsibility of the External Focus Mediator to synchronize state accordingly.
+     *
+     * @param focusRequestId Focus request id relating to the channel releasing focus.
+     */
+    virtual void onFocusRelease(const std::string& focusRequestId) = 0;
+};
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALFOCUSMEDIATORINTERFACE_H_
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
index 42ad8e47..54beccaf 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
@@ -22,8 +22,10 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/AudioAttributes.h>
 #include <AVSCommon/AVS/ContentType.h>
 #include "ChannelObserverInterface.h"
+#include "ExternalFocusMediatorInterface.h"
 #include "FocusManagerObserverInterface.h"
 
 namespace alexaClientSDK {
@@ -70,12 +72,15 @@ public:
          * @param channelObserver The Activity's Channel Observer.
          * @param patienceDuration The Activity's Patience Duration.
          * @param contentType The Activity's Content Type.
+         * @param audioAttributes The Activity's Audio Attributes.
+         * @return The new Activity, otherwise a @c nullptr if the operation failed.
          */
         static std::shared_ptr<Activity> create(
             const std::string& interfaceName,
             const std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface>& channelObserver,
             const std::chrono::milliseconds& patienceDuration = std::chrono::milliseconds::zero(),
-            const avsCommon::avs::ContentType contentType = avsCommon::avs::ContentType::NONMIXABLE);
+            avsCommon::avs::ContentType contentType = avsCommon::avs::ContentType::NONMIXABLE,
+            const avsCommon::avs::AudioAttributes& audioAttributes = {avsCommon::avs::AudioAttributes::Usage::UNKNOWN});
 
         bool operator==(const Activity& rhs) {
             return this->m_interface == rhs.m_interface;
@@ -118,6 +123,13 @@ public:
          */
         avsCommon::avs::MixingBehavior getMixingBehavior() const;
 
+        /**
+         * Gets the @c AudioAttributes associated with this @c Activity.
+         *
+         * @return The @c AudioAttributes associated with this @c Activity.
+         */
+        avsCommon::avs::AudioAttributes getAudioAttributes() const;
+
         /**
          * Returns the channel observer of Activity.
          *
@@ -145,12 +157,14 @@ public:
             const std::string& interfaceName,
             const std::chrono::milliseconds& patienceDuration,
             const std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface>& channelObserver,
-            const avsCommon::avs::ContentType contentType) :
+            avsCommon::avs::ContentType contentType,
+            const avsCommon::avs::AudioAttributes& audioAttributes) :
                 m_interface{interfaceName},
                 m_patienceDuration{patienceDuration},
                 m_channelObserver{channelObserver},
                 m_contentType{contentType},
-                m_mixingBehavior{avsCommon::avs::MixingBehavior::UNDEFINED} {
+                m_mixingBehavior{avsCommon::avs::MixingBehavior::UNDEFINED},
+                m_audioAttributes{audioAttributes} {
         }
 
         /**
@@ -160,23 +174,26 @@ public:
          */
         void setMixingBehavior(avsCommon::avs::MixingBehavior behavior);
 
-        // The mutex that synchronizes all operations within the activity
+        /// The mutex that synchronizes all operations within the activity
         mutable std::mutex m_mutex;
 
-        // The interface name of the Activity.
+        /// The interface name of the Activity.
         const std::string m_interface;
 
-        // The duration of patience in milliseconds of the Activity.
+        /// The duration of patience in milliseconds of the Activity.
         const std::chrono::milliseconds m_patienceDuration;
 
-        // The channel observer of the Activity.
+        /// The channel observer of the Activity.
         const std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> m_channelObserver;
 
-        // The ContentType associated with this Activity
+        /// The ContentType associated with this Activity
         avsCommon::avs::ContentType m_contentType;
 
-        // Last MixingBehavior associated with this activity
+        /// Last MixingBehavior associated with this activity
         avsCommon::avs::MixingBehavior m_mixingBehavior;
+
+        /// The audio attributes of the Activity.
+        avsCommon::avs::AudioAttributes m_audioAttributes;
     };
 
     /// The default Dialog Channel name.
@@ -217,13 +234,18 @@ public:
      * caller will be notified via an ChannelObserverInterface##onFocusChanged() call to the @c channelObserver when
      * it can start the activity.
      *
+     * When interacting with the External Focus Mediator, this method will expect a promise returned by the External
+     * Focus System and grant/reject focus based on the promise being fulfilled/rejected respectively.
+     *
      * @param channelName The name of the Channel to acquire.
      * @param channelObserver The observer that will be acquiring the Channel and be notified of focus changes.
      * @param interfaceName The name of the AVS interface occupying the Channel. This should be unique and represents
      * the name of the AVS interface using the Channel.  The name of the AVS interface is used by the ActivityTracker to
      * send Context to AVS.
      *
-     * @return Returns @c true if the Channel can be acquired and @c false otherwise.
+     * @return Returns @c true if the Channel can be acquired and @c false otherwise. However, if External Focus
+     * Mediator is enabled, the method will return @c true, if the operation is successful. Regardless of whether the
+     * External Focus Mediator chooses to reject focus by rejecting the promise.
      */
     virtual bool acquireChannel(
         const std::string& channelName,
@@ -235,10 +257,17 @@ public:
      * caller will be notified via an ChannelObserverInterface##onFocusChanged() call to the @c channelObserver when
      * it can start the activity.
      *
+     * When interacting with the External Focus Mediator, this method will expect a promise returned by the External
+     * Focus System and grant/reject focus based on the promise being fulfilled/rejected respectively. Therefore, this
+     * becomes an asynchronous interaction that may fail. In the case where a promise is rejected, a channel will NOT be
+     * acquired.
+     *
      * @param channelName The name of the Channel to acquire.
      * @param channelActivity Activity object associated with the Channel.
      *
-     * @return Returns @c true if the Channel can be acquired and @c false otherwise.
+     * @return Returns @c true if the Channel can be acquired and @c false otherwise. However, if External Focus
+     * Mediator is enabled, the method will return @c true, if the operation is successful. Regardless of whether the
+     * External Focus Mediator chooses to reject focus by rejecting the promise.
      */
     virtual bool acquireChannel(
         const std::string& channelName,
@@ -250,6 +279,13 @@ public:
      * Channel to release is the current foreground focused Channel, it will also notify the next highest priority
      * Channel via an ChannelObserverInterface##onFocusChanged() callback that it has gained foreground focus.
      *
+     * When interacting with the External Focus Mediator, this method will provide a callback
+     * ExternalFocusMediator##onChannelRelease() to notify the External Focus Mediator that a Channel has been released.
+     *
+     * @note If multiple activities occupy a single Channel, the callback ExternalFocusMediator##onChannelRelease() will
+     * not be called, since the Channel will remain active. There must be no activities remaining on the Channel for the
+     * callback to emit.
+     *
      * @param channelName The name of the Channel to release.
      * @param channelObserver The observer to be released from the Channel.
      * @return @c std::future<bool> which will contain @c true if the Channel can be released and @c false otherwise.
@@ -259,10 +295,12 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) = 0;
 
     /**
-     * This method will request that the currently foregrounded Channel activity be stopped, if there is one. This will
-     * be performed asynchronously, and so, if at the time of processing, the activity has stopped for any reason, then
-     * no stop will be performed. If something was stopped, the next highest priority active Channel will be brought
-     * to the foreground.
+     * This method will request that the currently highest priority Channel activity be stopped, if there is one. This
+     * will be performed asynchronously, and so, if at the time of processing, the activity has stopped for any reason,
+     * then no stop will be performed. If something was stopped, the next highest priority active Channel will be
+     * brought to the foreground.
+     *
+     * @note If the highest priority Channel is in the background, it will still be released.
      */
     virtual void stopForegroundActivity() = 0;
 
@@ -307,13 +345,14 @@ inline std::shared_ptr<FocusManagerInterface::Activity> FocusManagerInterface::A
     const std::string& interfaceName,
     const std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface>& channelObserver,
     const std::chrono::milliseconds& patienceDuration,
-    const avsCommon::avs::ContentType contentType) {
+    avsCommon::avs::ContentType contentType,
+    const avsCommon::avs::AudioAttributes& audioAttributes) {
     if (interfaceName.empty() || patienceDuration.count() < 0 || channelObserver == nullptr) {
         return nullptr;
     }
 
-    auto activity = std::shared_ptr<FocusManagerInterface::Activity>(
-        new FocusManagerInterface::Activity(interfaceName, patienceDuration, channelObserver, contentType));
+    auto activity = std::shared_ptr<FocusManagerInterface::Activity>(new FocusManagerInterface::Activity(
+        interfaceName, patienceDuration, channelObserver, contentType, audioAttributes));
     return activity;
 }
 
@@ -340,6 +379,11 @@ inline avsCommon::avs::MixingBehavior FocusManagerInterface::Activity::getMixing
     return m_mixingBehavior;
 }
 
+inline avsCommon::avs::AudioAttributes FocusManagerInterface::Activity::getAudioAttributes() const {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    return m_audioAttributes;
+}
+
 inline std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> FocusManagerInterface::Activity::
     getChannelObserver() const {
     return m_channelObserver;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h
new file mode 100644
index 00000000..ed8c3749
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSINVOKERINTERFACE_H
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSINVOKERINTERFACE_H
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+    class UniversalDeviceCommandsInvokerInterface {
+    public:
+        /**
+         * Perform an Universal Device Command (UDC).
+         *
+         * @param universalDeviceCommand Identifies the UDC.
+         */
+        virtual bool invokeCommand(std::string universalDeviceCommand) = 0;
+
+        /// Destructor.
+        virtual ~UniversalDeviceCommandsInvokerInterface() = default;
+    };
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSINVOKERINTERFACE_H
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h
new file mode 100644
index 00000000..23315a27
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSPROVIDERINTERFACE_H
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSPROVIDERINTERFACE_H
+
+#include <string>
+#include <set>
+
+#include <AVSCommon/AVS/CapabilityState.h>
+#include <AVSCommon/AVS/CapabilityTag.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+    const int WAIT_FOR_AVAILABLE_COMMANDS_TIMEOUT_IN_MILLISECONDS = 100;
+
+    class UniversalDeviceCommandsProviderInterface {
+    public:
+        virtual ~UniversalDeviceCommandsProviderInterface() = default;
+        virtual void onCommandsAvailable(std::set<std::string> commands) = 0;
+        virtual void clearAvailableCommands() = 0;
+        virtual avsCommon::avs::CapabilityTag getUniversalDeviceControllerTag() = 0;
+        virtual avsCommon::avs::CapabilityState getUniversalDeviceControllerState(
+            int waitTimeoutInMilliSeconds = WAIT_FOR_AVAILABLE_COMMANDS_TIMEOUT_IN_MILLISECONDS) = 0;
+        virtual void expectCommands() = 0;
+        virtual void stopExpectingCommands() = 0;
+    };
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_UNIVERSALDEVICECOMMANDSPROVIDERINTERFACE_H
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExternalFocusMediator.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExternalFocusMediator.h
new file mode 100644
index 00000000..19ec4273
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExternalFocusMediator.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKEXTERNALFOCUSMEDIATOR_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKEXTERNALFOCUSMEDIATOR_H_
+
+#include <string>
+#include <vector>
+
+#include <gmock/gmock.h>
+
+#include "AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace test {
+
+/// Mock class that implements the ExternalFocusMediator.
+class MockExternalFocusMediator : public ExternalFocusMediatorInterface {
+public:
+    MOCK_METHOD2(
+        initialize,
+        bool(
+            const std::shared_ptr<ExternalFocusMediatorCallbackInterface>& callbackInterface,
+            const std::vector<CallbackChannelConfiguration>& callbackChannelConfigurations));
+    MOCK_METHOD1(
+        acquireFocus,
+        avsCommon::utils::threading::Promise<ExternalFocusMediatorCallbackInterface::ExternalFocusMediatorFocus>(
+            const avsCommon::avs::FocusRequest& focusRequest));
+    MOCK_METHOD1(onFocusRelease, void(const std::string& focusRequestId));
+};
+
+}  // namespace test
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKEXTERNALFOCUSMEDIATOR_H_
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsInvoker.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsInvoker.h
new file mode 100644
index 00000000..c6408e6e
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsInvoker.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSINVOKER_H
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSINVOKER_H
+
+#include <gmock/gmock.h>
+
+#include <AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace test {
+
+/*
+ * A mock of the @c UniversalDeviceCommandsInvokerInterface.
+ */
+class MockUniversalDeviceCommandsInvoker : public avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface {
+public:
+    MOCK_METHOD1(invokeCommand, bool(std::string));
+};
+
+}  // namespace test
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSINVOKER_H
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsProvider.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsProvider.h
new file mode 100644
index 00000000..e981c94d
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsProvider.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSPROVIDER_H
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSPROVIDER_H
+
+#include <gmock/gmock.h>
+
+#include <AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace test {
+
+/*
+ * A mock of the @c UniversalDeviceCommandsProviderInterface.
+ */
+class MockUniversalDeviceCommandsProvider : public avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface {
+public:
+    MOCK_METHOD1(onCommandsAvailable, void(std::set<std::string>));
+    MOCK_METHOD0(clearAvailableCommands, void());
+    MOCK_METHOD0(getUniversalDeviceControllerTag, avsCommon::avs::CapabilityTag());
+    MOCK_METHOD1(getUniversalDeviceControllerState, avsCommon::avs::CapabilityState(int));
+    MOCK_METHOD0(expectCommands, void());
+    MOCK_METHOD0(stopExpectingCommands, void());
+};
+
+}  // namespace test
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_TEST_AVSCOMMON_SDKINTERFACES_MOCKUNIVERSALDEVICECOMMANDSPROVIDER_H
diff --git a/AVSCommon/Utils/doc/PromiseAPI.dox b/AVSCommon/Utils/doc/PromiseAPI.dox
new file mode 100644
index 00000000..feaf5dbb
--- /dev/null
+++ b/AVSCommon/Utils/doc/PromiseAPI.dox
@@ -0,0 +1,24 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @defgroup PromiseAPI Promise API
+ * @brief Eventual result handling framework.
+ *
+ * PromiseAPI enables handling of eventual results without the use of callback interfaces.
+ *
+ * @sa alexaClientSDK::avsCommon::utils::threading::Promise
+ * @sa alexaClientSDK::avsCommon::utils::threading::PromiseResolver
+ */
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
index ec70c280..09b63823 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
@@ -27,82 +27,64 @@ namespace utils {
 namespace logger {
 
 /**
- * Class to provide @c std::this_thread access to unique name for itself.
+ * Class to provide unique name for execution context.
  *
- * The name ThreadMoniker is used instead of ThreadId to avoid confusion with platform specific thread identifiers
- * or the @c std::thread::id values rendered as a string.
+ * This class provides management for thread-local execution context identifiers. Execution context identifier is a
+ * hexadecimal string which is managed by facilities like @c Executor and @c Timer. Logging framework adds identifier
+ * value to all messages to identify which executor or timer is running the task.
+ *
+ * @note The same identifier can be reused by different threads, but will have the same context.
  */
 class ThreadMoniker {
 public:
+    /// Prefix value for executor monikers.
+    static constexpr char PREFIX_EXECUTOR = 'e';
+
+    /// Prefix value for timer monikers.
+    static constexpr char PREFIX_TIMER = 't';
+
     /**
-     * Get the moniker for @c std::this_thread.
+     * Get the moniker for the caller's thread.
      *
-     * @return The moniker for @c std::this_thread.
+     * Method returns identifier value assigned to the current thread by a call to #setThisThreadMoniker(). If the value
+     * has not been previously set, a new value is generated by #generateMoniker(), assigned to the current thread, and
+     * returned.
+     *
+     * @return The moniker for the caller's thread.
      */
-    static inline std::string getThisThreadMoniker();
+    static std::string getThisThreadMoniker() noexcept;
 
     /**
      * Generate a unique moniker.
      *
+     * This method generates a fixed-width moniker string. By default the value is a alpha-numeric string, prepended
+     * with spaces. If the \a prefix is specified, the value also includes prefix character with colon.
+     *
+     * @param prefix Optional prefix for moniker value. If @a prefix if not 0, it is used for generating moniker.
+     * Some of prefix values are reserved for use by ACSDK: 't' prefix is used by timers, and 'e' prefix is used by
+     * executors.
+     *
      * @return A new unique moniker.
      */
-    static std::string generateMoniker();
+    static std::string generateMoniker(char prefix = 0) noexcept;
 
     /**
-     * Set the moniker for @c std::this_thread. This method should be called before @c getThisThreadMoniker() in order
-     * to take effect.
+     * Set the moniker for the caller's thread.
+     *
+     * This method sets identifier value for the caller's thread. Any subsequent calls to #getThisThreadMoniker() will
+     * return @a moniker value.
      *
      * @param moniker The moniker for @c std::this_thread.
      */
-    static inline void setThisThreadMoniker(const std::string& moniker);
+    static void setThisThreadMoniker(const std::string& moniker) noexcept;
 
 private:
     /**
      * Constructor.
-     *
-     * @param moniker Optional moniker for this thread. If no moniker is provided, a new moniker will be provided.
      */
-    ThreadMoniker(const std::string& moniker = std::string());
-
-    /**
-     * Return the @c ThreadMoniker object for the current thread.
-     *
-     * @param moniker Use this moniker to initialize the @c ThreadMoniker if it doesn't exist already.
-     * @return The moniker for the @c std::this_thread.
-     */
-    static inline const ThreadMoniker& getMonikerObject(const std::string& moniker = std::string());
-
-    /**
-     * Return the @c ThreadMoniker object for the current thread for OS that don't support thread local variables.
-     *
-     * @param moniker Use this moniker to initialize the @c ThreadMoniker if it doesn't exist already.
-     * @return The moniker for the @c std::this_thread.
-     */
-    static const ThreadMoniker& getMonikerObjectFromMap(const std::string& moniker = std::string());
-
-    /// The current thread's moniker.
-    std::string m_moniker;
+    ThreadMoniker() = delete;
 };
 
-std::string ThreadMoniker::getThisThreadMoniker() {
-    return getMonikerObject().m_moniker;
-}
-
-void ThreadMoniker::setThisThreadMoniker(const std::string& moniker) {
-    getMonikerObject(moniker);
-}
-
-const ThreadMoniker& ThreadMoniker::getMonikerObject(const std::string& moniker) {
-#ifdef _WIN32
-    return getMonikerObjectFromMap(moniker);
-#else
-    /// Per-thread static instance so that @c m_threadMoniker.m_moniker is @c std::this_thread's moniker.
-    static thread_local ThreadMoniker m_threadMoniker{moniker};
-
-    return m_threadMoniker;
-#endif
-}
-
 }  // namespace logger
 }  // namespace utils
 }  // namespace avsCommon
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/PlatformDefinitions.h b/AVSCommon/Utils/include/AVSCommon/Utils/PlatformDefinitions.h
index e47afd3c..5fab2790 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/PlatformDefinitions.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/PlatformDefinitions.h
@@ -43,4 +43,74 @@ typedef SSIZE_T ssize_t;
 #define ACSDK_USE_RTTI ON
 #endif
 
+/**
+ * @macro ACSDK_ALWAYS_INLINE
+ *
+ * Compiler-specific macro to disable cost-benefit analysis and always inline a method.
+ */
+
+/**
+ * @macro ACSDK_NO_INLINE
+ *
+ * Compiler-specific macro to disable cost-benefit analysis and never inline a method.
+ */
+
+/**
+ * @macro ACSDK_HIDDEN
+ *
+ * Compiler-specific macro to make symbol not visible outside of binary object.
+ */
+
+/**
+ * @macro ACSDK_INTERNAL_LINKAGE
+ *
+ * Compiler-specific macro to make symbol not visible outside of the scope it is instantiated.
+ */
+
+/**
+ * @macro ACSDK_HIDE_FROM_ABI
+ * @brief Compiler-specific macro to exclude symbol from binary exports.
+ *
+ * Macro excludes symbols from binary export table. This helps to reduce binary size when building shared libraries.
+ */
+
+#if defined(_MSC_VER)
+#define ACSDK_ALWAYS_INLINE __forceinline
+#define ACSDK_NO_INLINE __declspec(noinline)
+#define ACSDK_HIDDEN
+#define ACSDK_INTERNAL_LINKAGE ACSDK_ALWAYS_INLINE
+#elif defined(__GNUC__)
+
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+
+#define ACSDK_ALWAYS_INLINE inline __attribute__((__always_inline__))
+#define ACSDK_NO_INLINE __attribute__((__noinline__))
+#define ACSDK_HIDDEN __attribute__((__visibility__("hidden")))
+
+#if defined(__clang__)
+#if __has_attribute(internal_linkage)
+#define ACSDK_INTERNAL_LINKAGE __attribute__((internal_linkage))
+#else
+#define ACSDK_INTERNAL_LINKAGE __attribute__((__visibility__("hidden")))
+#endif
+#else
+#define ACSDK_INTERNAL_LINKAGE __attribute__((__visibility__("internal")))
+#endif
+#else
+#define ACSDK_ALWAYS_INLINE inline
+#define ACSDK_NO_INLINE
+#define ACSDK_HIDDEN
+#define ACSDK_INTERNAL_LINKAGE ACSDK_ALWAYS_INLINE
+#endif
+#define ACSDK_HIDE_FROM_ABI ACSDK_INTERNAL_LINKAGE
+
+/**
+ * @brief Compiler-specific macro for inline-only methods.
+ *
+ * Macro excludes symbols from binary export table. This helps to reduce binary size when building shared libraries.
+ */
+#define ACSDK_INLINE_VISIBILITY ACSDK_HIDE_FROM_ABI
+
 #endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_PLATFORMDEFINITIONS_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
index af8e4713..a51e29bc 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
@@ -26,8 +26,9 @@
 #include <mutex>
 #include <utility>
 
-#include "AVSCommon/Utils/Threading/TaskThread.h"
-#include "AVSCommon/Utils/Power/PowerResource.h"
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/TaskThread.h>
+#include <AVSCommon/Utils/Power/PowerResource.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -35,134 +36,174 @@ namespace utils {
 namespace threading {
 
 /**
+ * @brief Single-thread executor implementation.
+ *
  * An Executor is used to run callable types asynchronously.
+ *
+ * This type is a wrapper around ExecutorInterface implementation.
  */
 class Executor {
 public:
+    /**
+     * Constructs an Executor.
+     */
+    Executor() noexcept;
+
     /**
      * Constructs an Executor.
      *
-     * @param delayExit The period of time that this executor will keep its thread running while waiting
-     * for a new job. We use 1s by default.
+     * @param unused Unused parameter.
+     *
+     * @deprecated This method is kept for backwards compatibility.
      */
-    Executor(const std::chrono::milliseconds& delayExit = std::chrono::milliseconds(1000));
+    Executor(const std::chrono::milliseconds& unused) noexcept;
 
     /**
      * Destructs an Executor.
      */
-    ~Executor();
+    ~Executor() noexcept;
+
+    /**
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an Executor thread.
+     *
+     * @param[in] function Function to execute. Function must not be empty.
+     * @return True if @a function is accepted for execution, false if @a function is empty or executor is shutdown.
+     */
+    bool execute(std::function<void()>&& function) noexcept;
+
+    /**
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an Executor thread.
+     *
+     * @param[in] function Function to execute.
+     * @return True if @a function is accepted for execution, false if @a function is empty or executor is shutdown.
+     */
+    bool execute(const std::function<void()>& function) noexcept;
 
     /**
      * Submits a callable type (function, lambda expression, bind expression, or another function object) to be executed
      * on an Executor thread. The future must be checked for validity before waiting on it.
      *
+     * @tparam Task Callable type.
+     * @tparam Args Argument types.
+     *
      * @param task A callable type representing a task.
      * @param args The arguments to call the task with.
-     * @returns A @c std::future for the return value of the task.
+     * @return A @c std::future for the return value of the task.
+     *
+     * @note This method is less memory and speed efficient then #execute() and should not be used unless std::future
+     *       result is required.
      */
     template <typename Task, typename... Args>
-    auto submit(Task task, Args&&... args) -> std::future<decltype(task(args...))>;
+    auto submit(Task task, Args&&... args) noexcept -> std::future<decltype(task(args...))>;
 
     /**
      * Submits a callable type (function, lambda expression, bind expression, or another function object) to the front
      * of the internal queue to be executed on an Executor thread. The future must be checked for validity before
      * waiting on it.
      *
+     * @tparam Task Callable type.
+     * @tparam Args Argument types.
+     *
      * @param task A callable type representing a task.
      * @param args The arguments to call the task with.
-     * @returns A @c std::future for the return value of the task.
+     * @return A @c std::future for the return value of the task.
+     *
+     * @note This method is less memory and speed efficient then #execute() and should not be used unless std::future
+     *       result is required.
      */
     template <typename Task, typename... Args>
-    auto submitToFront(Task task, Args&&... args) -> std::future<decltype(task(args...))>;
+    auto submitToFront(Task task, Args&&... args) noexcept -> std::future<decltype(task(args...))>;
 
     /**
      * Waits for any previously submitted tasks to complete.
      */
-    void waitForSubmittedTasks();
+    void waitForSubmittedTasks() noexcept;
 
     /// Clears the executor of outstanding tasks and refuses any additional tasks to be submitted.
-    void shutdown();
+    void shutdown() noexcept;
 
     /// Returns whether or not the executor is shutdown.
-    bool isShutdown();
-
-private:
-    /// The queue type to use for holding tasks.
-    using Queue = std::deque<std::function<void()>>;
+    bool isShutdown() noexcept;
 
     /**
-     * Executes the next job in the queue.
+     * @brief Provides access to ExecutorInterface reference.
      *
-     * @return @c true if there's a next job; @c false if the job queue is empty.
+     * @return Reference to internal ExecutorInterface.
      */
-    bool runNext();
+    operator std::shared_ptr<ExecutorInterface>() const noexcept;
+
+private:
+    // Friend declaration.
+    friend class SharedExecutor;
 
     /**
-     * Checks if the job queue is empty and that no job is added in the grace period determined by @c m_timeout.
-     *
-     * @return @c true if there's at least one job left in the queue; @c false if the job queue is empty.
+     * @brief Ordering hint when submitting a new task to executor.
      */
-    bool hasNext();
+    enum class QueuePosition {
+        /// Add task to front of task queue.
+        Front = 1,
+        /// Add task to back of task queue.
+        Back
+    };
 
     /**
-     * Returns and removes the task at the front of the queue. If there are no tasks, this call will return an empty
-     * function.
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an Executor thread.
      *
-     * @returns A function that represents a new task. The function will be empty if the queue has no job.
+     * @param[in] function Function to execute.
+     * @param[in] queuePosition Position in the queue for the new task.
+     * @return True on success, false on error: if @a function is empty, @a queuePosition is not valid, or executor is
+     *         in shutdown.
      */
-    std::function<void()> pop();
+    bool execute(std::function<void()>&& function, QueuePosition queuePosition) noexcept;
 
     /**
      * Pushes a task on the the queue. If the queue is shutdown, the task will be dropped, and an invalid
      * future will be returned.
      *
-     * @param front If @c true, push to the front of the queue, else push to the back.
+     * @param queuePosition Position in the queue for the new task.
      * @param task A task to push to the front or back of the queue.
      * @param args The arguments to call the task with.
      * @returns A @c std::future to access the return value of the task. If the queue is shutdown, the task will be
      *     dropped, and an invalid future will be returned.
      */
     template <typename Task, typename... Args>
-    auto pushTo(bool front, Task task, Args&&... args) -> std::future<decltype(task(args...))>;
-
-    /// The queue of tasks
-    Queue m_queue;
+    auto pushTo(QueuePosition queuePosition, Task&& task, Args&&... args) noexcept
+        -> std::future<decltype(task(args...))>;
 
-    /// Flag to indicate if the taskThread already have an executing job.
-    bool m_threadRunning;
-
-    /// Period that this queue will wait for a new job until it releases the task thread.
-    std::chrono::milliseconds m_timeout;
-
-    /// A mutex to protect access to the tasks in m_queue.
-    std::mutex m_queueMutex;
-
-    /// A flag for whether or not the queue is expecting more tasks.
-    std::atomic_bool m_shutdown;
-
-    /// A @c PowerResource.
-    std::shared_ptr<power::PowerResource> m_powerResource;
-
-    /// The condition variable used to detect new job or timeout.
-    std::condition_variable m_delayedCondition;
-
-    /// The id of this instance.
-    const uint64_t m_id;
+    /**
+     * Pushes a function on the the queue. If the queue is shutdown, the function will be dropped, and an invalid
+     * future will be returned.
+     *
+     * @tparam T Return type for @a function and resulting future value type.
+     * @param queuePosition Position in the queue for the new task.
+     * @param function A function to push.
+     * @returns A @c std::future to access the return value of the task. If the queue is shutdown, the task will be
+     *     dropped, and an invalid future will be returned.
+     */
+    template <typename T>
+    std::future<T> pushFunction(QueuePosition queuePosition, std::function<T()>&& function) noexcept;
 
-    /// The thread to execute tasks on. The thread must be declared last to be destructed first.
-    TaskThread m_taskThread;
+    /// Internal shared executor reference.
+    std::shared_ptr<class SharedExecutor> m_executor;
 };
 
+inline Executor::Executor(const std::chrono::milliseconds&) noexcept : Executor() {
+}
+
 template <typename Task, typename... Args>
-auto Executor::submit(Task task, Args&&... args) -> std::future<decltype(task(args...))> {
-    bool front = false;
-    return pushTo(front, std::forward<Task>(task), std::forward<Args>(args)...);
+auto Executor::submit(Task task, Args&&... args) noexcept -> std::future<decltype(task(args...))> {
+    return pushTo(QueuePosition::Back, std::forward<Task>(task), std::forward<Args>(args)...);
 }
 
 template <typename Task, typename... Args>
-auto Executor::submitToFront(Task task, Args&&... args) -> std::future<decltype(task(args...))> {
-    bool front = true;
-    return pushTo(front, std::forward<Task>(task), std::forward<Args>(args)...);
+auto Executor::submitToFront(Task task, Args&&... args) noexcept -> std::future<decltype(task(args...))> {
+    return pushTo(QueuePosition::Front, std::forward<Task>(task), std::forward<Args>(args)...);
 }
 
 /**
@@ -172,14 +213,14 @@ auto Executor::submitToFront(Task task, Args&&... args) -> std::future<decltype(
  * @param future The @c std::future on which to wait for a result to forward to @c promise.
  */
 template <typename T>
-inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std::future<T>* future) {
+inline static void forwardPromise(std::promise<T>& promise, std::future<T>& future) noexcept {
 #if __cpp_exceptions || defined(__EXCEPTIONS)
     try {
 #endif
-        promise->set_value(future->get());
+        promise.set_value(future.get());
 #if __cpp_exceptions || defined(__EXCEPTIONS)
     } catch (...) {
-        promise->set_exception(std::current_exception());
+        promise.set_exception(std::current_exception());
     }
 #endif
 }
@@ -191,28 +232,32 @@ inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std:
  * @param future The @c std::future on which to wait before fulfilling @c promise.
  */
 template <>
-inline void forwardPromise<void>(std::shared_ptr<std::promise<void>> promise, std::future<void>* future) {
+inline void forwardPromise<void>(std::promise<void>& promise, std::future<void>& future) noexcept {
 #if __cpp_exceptions || defined(__EXCEPTIONS)
     try {
 #endif
-        future->get();
-        promise->set_value();
+        future.get();
+        promise.set_value();
 #if __cpp_exceptions || defined(__EXCEPTIONS)
     } catch (...) {
-        promise->set_exception(std::current_exception());
+        promise.set_exception(std::current_exception());
     }
 #endif
 }
 
 template <typename Task, typename... Args>
-auto Executor::pushTo(bool front, Task task, Args&&... args) -> std::future<decltype(task(args...))> {
+inline auto Executor::pushTo(QueuePosition queuePosition, Task&& task, Args&&... args) noexcept
+    -> std::future<decltype(task(args...))> {
+    using ValueType = decltype(task(args...));
     // Remove arguments from the tasks type by binding the arguments to the task.
-    auto boundTask = std::bind(std::forward<Task>(task), std::forward<Args>(args)...);
+    std::function<ValueType()> fn{std::bind(std::forward<Task>(task), std::forward<Args>(args)...)};
+    return pushFunction(queuePosition, std::move(fn));
+}
 
+template <typename T>
+std::future<T> Executor::pushFunction(QueuePosition queuePosition, std::function<T()>&& function) noexcept {
     /*
-     * Create a std::packaged_task with the correct return type. The decltype only returns the return value of the
-     * boundTask. The following parentheses make it a function call with the boundTask return type. The package task
-     * will then return a future of the correct type.
+     * Create a std::packaged_task with the correct return type.
      *
      * Note: A std::packaged_task fulfills its future *during* the call to operator().  If the user of a
      * std::packaged_task hands it off to another thread to execute, and then waits on the future, they will be able to
@@ -223,53 +268,69 @@ auto Executor::pushTo(bool front, Task task, Args&&... args) -> std::future<decl
      * workaround for this limitation.  It executes the packaged task, then disposes of it before passing the task's
      * return value back to the future that the user is waiting on.
      */
-    using PackagedTaskType = std::packaged_task<decltype(boundTask())()>;
-    auto packaged_task = std::make_shared<PackagedTaskType>(boundTask);
 
-    // Create a promise/future that we will fulfill when we have cleaned up the task.
-    auto cleanupPromise = std::make_shared<std::promise<decltype(task(args...))>>();
-    auto cleanupFuture = cleanupPromise->get_future();
+    /**
+     * @brief Structure to carry parameters into lambda through shared pointer.
+     * @private
+     */
+    struct CallCtx {
+        /**
+         * @brief Construct object and assigned function to packaged task.
+         *
+         * @param function Function to wrap into packaged task.
+         */
+        inline CallCtx(std::function<T()>&& function) : packagedTask{std::move(function)} {
+        }
+
+        /// Packaged task.
+        std::packaged_task<T()> packagedTask;
+        /// Promise for result forwarding.
+        std::promise<T> cleanupPromise;
+    };
+
+    auto callCtx = std::make_shared<CallCtx>(std::move(function));
 
     // Remove the return type from the task by wrapping it in a lambda with no return value.
-    auto translated_task = [packaged_task, cleanupPromise]() mutable {
+    auto translated_task = [callCtx]() mutable {
         // Execute the task.
-        packaged_task->operator()();
+        callCtx->packagedTask();
         // Note the future for the task's result.
-        auto taskFuture = packaged_task->get_future();
+        auto taskFuture = callCtx->packagedTask.get_future();
         // Clean up the task.
-        packaged_task.reset();
+        callCtx->packagedTask.reset();
+        auto cleanupPromise = std::move(callCtx->cleanupPromise);
+        // Release parameters.
+        callCtx.reset();
         // Forward the task's result to our cleanup promise/future.
-        forwardPromise(cleanupPromise, &taskFuture);
+        forwardPromise(cleanupPromise, taskFuture);
     };
 
+    // Create a promise/future that we will fulfill when we have cleaned up the task.
+    auto cleanupFuture = callCtx->cleanupPromise.get_future();
+
     // Release our local reference to packaged task so that the only remaining reference is inside the lambda.
-    packaged_task.reset();
-
-    {
-        bool restart = false;
-        std::lock_guard<std::mutex> queueLock{m_queueMutex};
-        if (!m_shutdown) {
-            restart = !m_threadRunning;
-            if (m_powerResource) {
-                m_powerResource->acquire();
-            }
-            m_queue.emplace(front ? m_queue.begin() : m_queue.end(), std::move(translated_task));
-        } else {
-            using FutureType = decltype(task(args...));
-            return std::future<FutureType>();
-        }
+    callCtx.reset();
 
-        if (restart) {
-            // Restart task thread.
-            m_taskThread.start(std::bind(&Executor::runNext, this));
-            m_threadRunning = true;
-        }
+    if (!execute(std::move(translated_task), queuePosition)) {
+        return std::future<T>();
     }
 
-    m_delayedCondition.notify_one();
     return cleanupFuture;
 }
 
+/// @name Externalize Executor::pushFunction() for common types.
+/// @{
+extern template std::future<void> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<void()>&& function) noexcept;
+extern template std::future<bool> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<bool()>&& function) noexcept;
+extern template std::future<std::string> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<std::string()>&& function) noexcept;
+/// @}
+
 }  // namespace threading
 }  // namespace utils
 }  // namespace avsCommon
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorFactory.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorFactory.h
new file mode 100644
index 00000000..be69d72d
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorFactory.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORFACTORY_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORFACTORY_H_
+
+#include <memory>
+
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Create a single-thread executor.
+ *
+ * @return New executor reference or nullptr on error.
+ */
+std::shared_ptr<ExecutorInterface> createSingleThreadExecutor() noexcept;
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORFACTORY_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorInterface.h
new file mode 100644
index 00000000..5897a873
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ExecutorInterface.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORINTERFACE_H_
+
+#include <functional>
+#include <system_error>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Interface for asynchronous execution of functions.
+ *
+ * This interface enables submission of functions for asynchronous execution. The implementations should use thread pool
+ * to acquire threads for running functions, and may be single- or multi-threaded.
+ *
+ * Executors can be in normal mode, when they accept tasks, and in shutdown mode. In shutdown mode executors do not
+ * accept new tasks for processing, and any tasks, that haven't started an execution will be dropped.
+ *
+ * @code
+ * auto error = executor->execute([]{ ... });
+ * if (error) {
+ *     ACSDK_ERROR(LX(__func__).("executorError", error.message()));
+ * }
+ * @endcode
+ *
+ * @see Executor
+ * @see ThreadPool
+ */
+class ExecutorInterface {
+public:
+    /**
+     * @brief Destructs an Executor.
+     *
+     * This method awaits till all running tasks are completed, and drops all enqueued tasks that haven't started
+     * execution.
+     */
+    virtual ~ExecutorInterface() noexcept = default;
+
+    /**
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an executor thread.
+     *
+     * @param[in] function Function to execute. Function must not be empty. Upon successful execution the @a function
+     *                     becomes empty (value is moved). On failure, the value of @a function is not modified.
+     *
+     * @return Platform-independent error code. If successful, the error value is zero.
+     *
+     * @retval std::errc::invalid_argument If @a function is empty.
+     * @retval std::errc::operation_not_permitted If executor is shutdown.
+     */
+    virtual std::error_condition execute(std::function<void()>&& function) noexcept = 0;
+
+    /**
+     * @{
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an executor thread.
+     *
+     * @param[in] function Function to execute. Function must not be empty.
+     *
+     * @return Platform-independent error code. If successful, the error value is zero.
+     *
+     * @retval std::errc::invalid_argument If @a function is empty.
+     * @retval std::errc::operation_not_permitted If executor is shutdown.
+     */
+    virtual std::error_condition execute(const std::function<void()>& function) noexcept = 0;
+};
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_EXECUTORINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnFulfilledAdapter.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnFulfilledAdapter.h
new file mode 100644
index 00000000..de9ca428
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnFulfilledAdapter.h
@@ -0,0 +1,588 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONFULFILLEDADAPTER_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONFULFILLEDADAPTER_H_
+
+#include <functional>
+#include <memory>
+
+#include <AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Adapters for OnFulfilled callables for Promise<T>.
+ *
+ * The method provides adapter functions to convert callables into form, suitable for PromiseState use (with type
+ * erasure).
+ *
+ * @tparam T Promise value type.
+ *
+ * @see OnFulfilledAdapter<void>
+ * @see OnRejectedAdapter
+ * @see Promise
+ *
+ * @ingroup PromiseAPI
+ * @private
+ */
+template <typename T>
+class OnFulfilledAdapter {
+public:
+    /// @copydoc Promise::OnFulfilledWithResolver
+    template <typename R>
+    using OnFulfilledWithResolver = typename PromiseTypeTraits<T>::template OnFulfilledWithResolver<R>;
+
+    /// @copydoc Promise::OnFulfilledWithPromise
+    template <typename R>
+    using OnFulfilledWithPromise = typename PromiseTypeTraits<T>::template OnFulfilledWithPromise<R>;
+
+    /// @copydoc Promise::OnFulfilledWithValue
+    template <typename R>
+    using OnFulfilledWithValue = typename PromiseTypeTraits<T>::template OnFulfilledWithValue<R>;
+
+    /// @copydoc Promise::OnFulfilledFinally
+    using OnFulfilledFinally = typename PromiseTypeTraits<T>::OnFulfilledFinally;
+
+    /**
+     * @{
+     * @brief Convert OnFulfilled callable into PromiseState::OnFulfilled function.
+     *
+     * Method converts OnFulfilled callable into PromiseState::OnFulfilled function. The method accepts callables, that
+     * can be converted into one of the following forms:
+     * @code
+     * # OnFulfilled function that accepts value and returns eventual result
+     * std::function<Promise<R>()>
+     *
+     * # OnFulfilled function that accepts value and returns non-eventual result
+     * std::function<R()>
+     *
+     * # OnFulfilled function that accepts value and resolver and returns void
+     * std::function<void(PromiseResolver<R>)>
+     * @endcode
+     *
+     * There is an ambiguity when @a R is void, as bind expressions are allowed to ignore additional arguments, and
+     * compiler will not be able to automatically select correct method for bind expression that accepts one argument
+     * and returns void.
+     *
+     * @tparam R           Result value type.
+     * @tparam OnFulfilled Callable type.
+     *
+     * @param[in] onFulfilled Callable to adapt.
+     *
+     * @return Non-empty function if @a onFulfilled is not empty, or empty function if @a onFulfilled is empty.
+     */
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::
+        enable_if<std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type;
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+        std::is_assignable<OnFulfilledWithResolver<R>, OnFulfilled>::value &&
+            !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type;
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+        std::is_assignable<OnFulfilledWithValue<R>, OnFulfilled>::value &&
+            !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type;
+    /// @}
+
+    /**
+     * @{
+     * @brief Adapt OnFulfilled callable to PromiseState::OnFulfilled for Promise::finally().
+     *
+     * Method converts @a onFulfilled callable into form suitable for PromiseState use.
+     *
+     * @tparam OnFulfilled Callable type.
+     *
+     * @param[in] onFulfilled Callable to adapt.
+     * @return Non-empty function if @a onFulfilled is empty, or empty one otherwise.
+     */
+    template <typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+        !std::is_same<std::nullptr_t, OnFulfilled>::value && std::is_assignable<OnFulfilledFinally, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type;
+    template <typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnFulfilled&& onFulfilled) ->
+        typename std::enable_if<std::is_same<std::nullptr_t, OnFulfilled>::value, PromiseState::OnFulfilled>::type;
+    /// @}
+
+private:
+    /**
+     * @brief Invoke OnFulfilledWithPromise for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithPromise using value stored in PromiseState container and
+     * propagating eventual result from callable result (Promise<R>) into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled Promise::then() onFulfilled callable converted to OnFulfilledWithPromise<R>.
+     * @param[in] destinationState      Destination state.
+     * @param[in] value       Fulfillment value.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithPromise(
+        const OnFulfilledWithPromise<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value);
+
+    /**
+     * @brief Invoke OnFulfilledWithResolver for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithResolver using value stored in PromiseState container and
+     * propagating eventual result from resolver into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled Promise::then() onFulfilled callable converted to OnFulfilledWithResolver<R>.
+     * @param[in] destinationState      Destination state.
+     * @param[in] value       Fulfillment value.
+     *
+     * @return Promise state that is taken from @a onFulfilled return value. The state may be nullptr if @a onFulfilled
+     *         has returned invalid state.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithResolver(
+        const OnFulfilledWithResolver<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value);
+
+    /**
+     * @{
+     * @brief Invoke OnFulfilledWithValue for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithValue using value stored in PromiseState container and
+     * using the return value to resolve the destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled Promise::then() onFulfilled callable converted to OnFulfilledWithValue<R>.
+     * @param[in] destinationState      Destination state.
+     * @param[in] value       Fulfillment value.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<!std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value);
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value);
+    /// @}
+
+    /**
+     * @brief Invoke FinallyOnFulfilledFunction using value from PromiseState.
+     *
+     * This function enables invocation of FinallyOnFulfilledFunction using value stored in PromiseState container.
+     *
+     * @param[in] onFulfilled Promise<void>::finally() onFulfilled function. This function must not be empty.
+     * @param[in] value       Fulfillment value.
+     */
+    ACSDK_INLINE_VISIBILITY static void invokeFinally(
+        const OnFulfilledFinally& onFulfilled,
+        const std::shared_ptr<PromiseState::Value>& value);
+};
+
+/**
+ * @brief Adapters for OnFulfilled callables for Promise<void>.
+ *
+ * The method provides adapter functions to convert callables into form, suitable for PromiseState use (with type
+ * erasure).
+ *
+ * @see OnFulfilledAdapter
+ * @see OnRejectedAdapter
+ * @see Promise
+ *
+ * @ingroup PromiseAPI
+ * @private
+ */
+template <>
+class OnFulfilledAdapter<void> {
+public:
+    /// @copydoc Promise::OnFulfilledWithResolver
+    template <typename R>
+    using OnFulfilledWithResolver = typename PromiseTypeTraits<void>::template OnFulfilledWithResolver<R>;
+
+    /// @copydoc Promise::OnFulfilledWithPromise
+    template <typename R>
+    using OnFulfilledWithPromise = typename PromiseTypeTraits<void>::template OnFulfilledWithPromise<R>;
+
+    /// @copydoc Promise::OnFulfilledWithValue
+    template <typename R>
+    using OnFulfilledWithValue = typename PromiseTypeTraits<void>::template OnFulfilledWithValue<R>;
+
+    /// @copydoc Promise::OnFulfilledFinally
+    using OnFulfilledFinally = typename PromiseTypeTraits<void>::OnFulfilledFinally;
+
+    /**
+     * @{
+     * @brief Convert OnFulfilled callable into PromiseState::OnFulfilled function.
+     *
+     * Method converts OnFulfilled callable into PromiseState::OnFulfilled function. The method accepts callables, that
+     * can be converted into one of the following forms:
+     * @code
+     * # OnFulfilled function that accepts value and returns eventual result
+     * std::function<Promise<R>()>
+     *
+     * # OnFulfilled function that accepts value and returns non-eventual result
+     * std::function<R()>
+     *
+     * # OnFulfilled function that accepts value and resolver and returns void
+     * std::function<void(PromiseResolver<R>)>
+     * @endcode
+     *
+     * There is an ambiguity when @a R is void, as bind expressions are allowed to ignore additional arguments, and
+     * compiler will not be able to automatically select correct method for bind expression that accepts one argument
+     * and returns void.
+     *
+     * @tparam R           Result value type.
+     * @tparam OnFulfilled Callable type.
+     *
+     * @param[in] onFulfilled Callable to adapt.
+     *
+     * @return Non-empty function if @a onFulfilled is not empty, or empty function if @a onFulfilled is empty.
+     */
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::
+        enable_if<std::is_assignable<OnFulfilledWithResolver<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type;
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::
+        enable_if<std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type;
+    template <typename R, typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+        std::is_assignable<OnFulfilledWithValue<R>, OnFulfilled>::value &&
+            !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type;
+    /// @}
+
+    /**
+     * @{
+     * @brief Adapt OnFulfilled callable to PromiseState::OnFulfilled for Promise::finally().
+     *
+     * Method converts @a onFulfilled callable into form suitable for PromiseState use.
+     *
+     * @tparam OnFulfilled Callable type.
+     *
+     * @param[in] onFulfilled Callable to adapt.
+     * @return Non-empty function if @a onFulfilled is empty, or empty one otherwise.
+     */
+    template <typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+        !std::is_same<std::nullptr_t, OnFulfilled>::value && std::is_assignable<OnFulfilledFinally, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type;
+    template <typename OnFulfilled>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnFulfilled&& onFulfilled) ->
+        typename std::enable_if<std::is_same<std::nullptr_t, OnFulfilled>::value, PromiseState::OnFulfilled>::type;
+    /// @}
+
+private:
+    /**
+     * @brief Invoke OnFulfilledWithPromise for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithPromise using value stored in PromiseState container and
+     * propagating eventual result from callable result (Promise<R>) into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled      Promise::then() onFulfilled callable converted to OnFulfilledWithPromise<R>.
+     * @param[in] destinationState Destination state.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithPromise(
+        const OnFulfilledWithPromise<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState);
+
+    /**
+     * @brief Invoke OnFulfilledWithResolver for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithResolver using value stored in PromiseState container and
+     * propagating eventual result from resolver into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled      Promise::then() onFulfilled callable converted to OnFulfilledWithResolver<R>.
+     * @param[in] destinationState Destination state.
+     *
+     * @return Promise state that is taken from @a onFulfilled return value. The state may be nullptr if @a onFulfilled
+     *         has returned invalid state.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithResolver(
+        const OnFulfilledWithResolver<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState);
+
+    /**
+     * @{
+     * @brief Invoke OnFulfilledWithValue for void eventual value type.
+     *
+     * This function enables invocation of OnFulfilledWithValue using value stored in PromiseState container and
+     * using the return value to resolve the destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onFulfilled      Promise::then() onFulfilled callable converted to OnFulfilledWithValue<R>.
+     * @param[in] destinationState Destination state.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<!std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState);
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState);
+    /// @}
+};
+
+template <typename T>
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<T>::adapt(OnFulfilled&& onFulfilled) -> typename std::
+    enable_if<std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type {
+    OnFulfilledWithPromise<R> function{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeWithPromise<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState>        - target state
+            std::placeholders::_2);  // std::shared_ptr<PromiseState::Value> - fulfillment value
+    }
+    return nullptr;
+}
+
+template <typename T>
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<T>::adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+    std::is_assignable<OnFulfilledWithResolver<R>, OnFulfilled>::value &&
+        !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+    PromiseState::OnFulfilled>::type {
+    OnFulfilledWithResolver<R> function{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeWithResolver<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState>        - target state
+            std::placeholders::_2);  // std::shared_ptr<PromiseState::Value> - fulfillment value
+    }
+    return nullptr;
+}
+
+template <typename T>
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<T>::adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+    std::is_assignable<OnFulfilledWithValue<R>, OnFulfilled>::value &&
+        !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+    PromiseState::OnFulfilled>::type {
+    OnFulfilledWithValue<R> function{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeWithValue<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState>        - target state
+            std::placeholders::_2);  // std::shared_ptr<PromiseState::Value> - fulfillment value
+    }
+    return nullptr;
+}
+
+template <typename T>
+template <typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<T>::adaptFinally(OnFulfilled&& onFulfilled) ->
+    typename std::enable_if<
+        !std::is_same<std::nullptr_t, OnFulfilled>::value && std::is_assignable<OnFulfilledFinally, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type {
+    OnFulfilledFinally function{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeFinally,
+            std::move(function),
+            std::placeholders::_2);  // std::shared_ptr<PromiseState::Value> - fulfillment value
+    }
+    return nullptr;
+}
+
+template <typename T>
+template <typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<T>::adaptFinally(OnFulfilled&& onFulfilled) ->
+    typename std::enable_if<std::is_same<std::nullptr_t, OnFulfilled>::value, PromiseState::OnFulfilled>::type {
+    return std::forward<OnFulfilled>(onFulfilled);
+}
+
+template <typename T>
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnFulfilledAdapter<T>::invokeWithResolver(
+    const OnFulfilledWithResolver<R>& onFulfilled,
+    const std::shared_ptr<PromiseState>& destinationState,
+    const std::shared_ptr<PromiseState::Value>& value) {
+    onFulfilled(*reinterpret_cast<const T*>(value.get()), PromiseResolver<R>{destinationState});
+}
+
+template <typename T>
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnFulfilledAdapter<T>::invokeWithPromise(
+    const OnFulfilledWithPromise<R>& onFulfilled,
+    const std::shared_ptr<PromiseState>& destinationState,
+    const std::shared_ptr<PromiseState::Value>& value) {
+    auto promise = onFulfilled(*reinterpret_cast<const T*>(value.get()));
+    if (promise.m_state) {
+        promise.m_state->addResultConsumer(destinationState, nullptr, nullptr, nullptr);
+    } else {
+        destinationState->reject(std::errc::invalid_argument);
+    }
+}
+
+template <typename T>
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<R, void>::value, void>::type OnFulfilledAdapter<
+    T>::
+    invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value) {
+    destinationState->resolve(std::make_shared<R>(onFulfilled(*reinterpret_cast<const T*>(value.get()))));
+}
+
+template <typename T>
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<std::is_same<R, void>::value, void>::type OnFulfilledAdapter<T>::
+    invokeWithValue(
+        const OnFulfilledWithValue<R>& onFulfilled,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::shared_ptr<PromiseState::Value>& value) {
+    onFulfilled(*reinterpret_cast<const T*>(value.get()));
+    destinationState->fulfillWithVoid();
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void OnFulfilledAdapter<T>::invokeFinally(
+    const OnFulfilledFinally& onFulfilled,
+    const std::shared_ptr<PromiseState::Value>& value) {
+    onFulfilled(*reinterpret_cast<const T*>(value.get()));
+}
+
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY auto OnFulfilledAdapter<void>::adapt(OnFulfilled&& onFulfilled) -> typename std::
+    enable_if<std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type {
+    OnFulfilledWithPromise<R> function = std::forward<OnFulfilled>(onFulfilled);
+    if (function) {
+        return std::bind(
+            &invokeWithPromise<R>,
+            std::move(function),
+            std::placeholders::_1);  // std::shared_ptr<PromiseState> - target state
+    }
+    return nullptr;
+}
+
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY auto OnFulfilledAdapter<void>::adapt(OnFulfilled&& onFulfilled) -> typename std::
+    enable_if<std::is_assignable<OnFulfilledWithResolver<R>, OnFulfilled>::value, PromiseState::OnFulfilled>::type {
+    auto function = OnFulfilledWithResolver<R>{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeWithResolver<R>,
+            std::move(function),
+            std::placeholders::_1);  // std::shared_ptr<PromiseState> - target state
+    }
+    return nullptr;
+}
+
+template <typename R, typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY auto OnFulfilledAdapter<void>::adapt(OnFulfilled&& onFulfilled) -> typename std::enable_if<
+    std::is_assignable<OnFulfilledWithValue<R>, OnFulfilled>::value &&
+        !std::is_assignable<OnFulfilledWithPromise<R>, OnFulfilled>::value,
+    PromiseState::OnFulfilled>::type {
+    auto function = OnFulfilledWithValue<R>{std::forward<OnFulfilled>(onFulfilled)};
+    if (function) {
+        return std::bind(
+            &invokeWithValue<R>,
+            std::move(function),
+            std::placeholders::_1);  // std::shared_ptr<PromiseState> - target state
+    }
+    return nullptr;
+}
+
+template <typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<void>::adaptFinally(OnFulfilled&& onFulfilled) ->
+    typename std::enable_if<
+        !std::is_same<std::nullptr_t, OnFulfilled>::value && std::is_assignable<OnFulfilledFinally, OnFulfilled>::value,
+        PromiseState::OnFulfilled>::type {
+    auto function = OnFulfilledFinally{std::move(onFulfilled)};
+    if (function) {
+        return std::bind(&OnFulfilledFinally::operator(), std::move(function));
+    }
+    return nullptr;
+}
+
+template <typename OnFulfilled>
+ACSDK_INLINE_VISIBILITY inline auto OnFulfilledAdapter<void>::adaptFinally(OnFulfilled&& onFulfilled) ->
+    typename std::enable_if<std::is_same<std::nullptr_t, OnFulfilled>::value, PromiseState::OnFulfilled>::type {
+    return std::forward<OnFulfilled>(onFulfilled);
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnFulfilledAdapter<void>::invokeWithResolver(
+    const OnFulfilledWithResolver<R>& onFulfilled,
+    const std::shared_ptr<PromiseState>& destinationState) {
+    onFulfilled(PromiseResolver<R>{destinationState});
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnFulfilledAdapter<void>::invokeWithPromise(
+    const OnFulfilledWithPromise<R>& onFulfilled,
+    const std::shared_ptr<PromiseState>& destinationState) {
+    auto promise = onFulfilled();
+    if (promise.m_state) {
+        promise.m_state->addResultConsumer(destinationState, nullptr, nullptr, nullptr);
+    } else {
+        destinationState->reject(std::errc::invalid_argument);
+    }
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<R, void>::value, void>::type OnFulfilledAdapter<
+    void>::
+    invokeWithValue(const OnFulfilledWithValue<R>& onFulfilled, const std::shared_ptr<PromiseState>& destinationState) {
+    destinationState->resolve(std::make_shared<R>(onFulfilled()));
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<std::is_same<R, void>::value, void>::type OnFulfilledAdapter<
+    void>::
+    invokeWithValue(const OnFulfilledWithValue<R>& onFulfilled, const std::shared_ptr<PromiseState>& destinationState) {
+    onFulfilled();
+    destinationState->fulfillWithVoid();
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONFULFILLEDADAPTER_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnRejectedAdapter.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnRejectedAdapter.h
new file mode 100644
index 00000000..a054f55c
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/OnRejectedAdapter.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONREJECTEDADAPTER_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONREJECTEDADAPTER_H_
+
+#include <functional>
+#include <memory>
+
+#include <AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Adapters for OnRejected callables for Promise.
+ *
+ * The method provides adapter functions to convert callables into form, suitable for PromiseState use (with type
+ * erasure).
+ *
+ * @see OnFulfilledAdapter
+ * @see OnFulfilledAdapter<void>
+ * @see Promise
+ *
+ * @ingroup PromiseAPI
+ * @private
+ */
+class OnRejectedAdapter {
+public:
+    /// @copydoc Promise::OnRejectedWithResolver
+    template <typename R>
+    using OnRejectedWithResolver = typename PromiseTypeTraits<void>::template OnRejectedWithResolver<R>;
+
+    /// @copydoc Promise::OnRejectedWithPromise
+    template <typename R>
+    using OnRejectedWithPromise = typename PromiseTypeTraits<void>::template OnRejectedWithPromise<R>;
+
+    /// @copydoc Promise::OnRejectedWithValue
+    template <typename R>
+    using OnRejectedWithValue = typename PromiseTypeTraits<void>::template OnRejectedWithValue<R>;
+
+    /// @copydoc Promise::OnRejectedFinally
+    using OnRejectedFinally = typename PromiseTypeTraits<void>::OnRejectedFinally;
+
+    /**
+     * @{
+     * @brief Convert OnRejected callable into PromiseState::OnRejected function.
+     *
+     * Method converts OnRejected callable into PromiseState::OnRejected function. The method accepts callables, that
+     * can be converted into one of the following forms:
+     * @code
+     * # OnRejected function that accepts reject reason and returns eventual result
+     * std::function<Promise<R>(const std::error_condition&)>
+     *
+     * # OnRejected function that accepts reject reason and returns non-eventual result
+     * std::function<R(const std::error_condition&)>
+     *
+     * # OnRejected function that accepts reject reason and resolver and returns void
+     * std::function<void(const std::error_condition&, PromiseResolver<R>)>
+     * @endcode
+     *
+     * There is an ambiguity when @a R is void, as bind expressions are allowed to ignore additional arguments, and
+     * compiler will not be able to automatically select correct method for bind expression that accepts one argument
+     * and returns void.
+     *
+     * @tparam R          Result value type.
+     * @tparam OnRejected Callable type.
+     *
+     * @param[in] onRejected Callable to adapt.
+     *
+     * @return Non-empty function if @a onRejected is not empty, or empty function if @a onRejected is empty.
+     */
+    template <typename R, typename OnRejected>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnRejected&& onRejected) -> typename std::
+        enable_if<std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value, PromiseState::OnRejected>::type;
+    template <typename R, typename OnRejected>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnRejected&& onRejected) -> typename std::enable_if<
+        std::is_assignable<OnRejectedWithResolver<R>, OnRejected>::value &&
+            !std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value,
+        PromiseState::OnRejected>::type;
+    template <typename R, typename OnRejected>
+    ACSDK_INLINE_VISIBILITY static auto adapt(OnRejected&& onRejected) -> typename std::enable_if<
+        std::is_assignable<OnRejectedWithValue<R>, OnRejected>::value &&
+            !std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value,
+        PromiseState::OnRejected>::type;
+    /// @}
+
+    /**
+     * @{
+     * @brief Adapt OnRejectedFinally function to PromiseState::OnRejected.
+     *
+     * Method converts @a onRejected function into form suitable for PromiseState use.
+     *
+     * @tparam OnRejected Callable type.
+     *
+     * @param[in] onRejected Function to adapt.
+     * @return Non-empty function if @a onRejected is empty, or empty one otherwise.
+     */
+    template <typename OnRejected>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnRejected&& onRejected) -> typename std::enable_if<
+        !std::is_same<std::nullptr_t, OnRejected>::value && std::is_assignable<OnRejectedFinally, OnRejected>::value,
+        PromiseState::OnRejected>::type;
+    template <typename OnRejected>
+    ACSDK_INLINE_VISIBILITY static auto adaptFinally(OnRejected&& onRejected) ->
+        typename std::enable_if<std::is_same<std::nullptr_t, OnRejected>::value, PromiseState::OnRejected>::type;
+    /// @}
+
+private:
+    /**
+     * @brief Invoke OnRejectedWithResolver for void eventual value type.
+     *
+     * This function enables invocation of OnRejectedWithResolver using value stored in PromiseState container and
+     * propagating eventual result from resolver into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onRejected       Promise::then() or Promise::thenCatch() onRejected callable converted to
+     *                             OnRejectedWithResolver<R>.
+     * @param[in] destinationState Destination state.
+     * @param[in] rejectReason     Reject reason.
+     *
+     * @return Promise state that is taken from @a onRejected return value. The state may be nullptr if @a onRejected
+     *         has returned invalid state.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithResolver(
+        const OnRejectedWithResolver<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason);
+
+    /**
+     * @brief Invoke OnRejectedWithPromise for void eventual value type.
+     *
+     * This function enables invocation of OnRejectedWithPromise using value stored in PromiseState container and
+     * propagating eventual result from callable result (Promise<R>) into destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onRejected       Promise::then() or Promise::thenCatch() onRejected callable converted to
+     *                             OnRejectedWithPromise<R>.
+     * @param[in] destinationState Destination state.
+     * @param[in] rejectReason     Reject reason.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static void invokeWithPromise(
+        const OnRejectedWithPromise<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason);
+
+    /**
+     * @{
+     * @brief Invoke OnRejectedWithValue for void eventual value type.
+     *
+     * This function enables invocation of OnRejectedWithValue using reject reason stored in PromiseState container and
+     * using the return value to resolve the destination state.
+     *
+     * @tparam R Result type.
+     *
+     * @param[in] onRejected       Promise::then() or Promise::thenCatch() onRejected callable converted to
+     *                             OnRejectedWithValue<R>.
+     * @param[in] destinationState Destination state.
+     * @param[in] rejectReason     Reject reason.
+     *
+     * @see #adapt()
+     */
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<!std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnRejectedWithValue<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason);
+    template <typename R>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<std::is_same<R, void>::value, void>::type invokeWithValue(
+        const OnRejectedWithValue<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason);
+    /// @}
+};
+
+template <typename R, typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline auto OnRejectedAdapter::adapt(OnRejected&& onRejected) -> typename std::
+    enable_if<std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value, PromiseState::OnRejected>::type {
+    auto function = OnRejectedWithPromise<R>{std::forward<OnRejected>(onRejected)};
+    if (function) {
+        return std::bind(
+            &invokeWithPromise<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState> - target state
+            std::placeholders::_2);  // std::error_condition          - reject reason
+    }
+    return nullptr;
+}
+
+template <typename R, typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline auto OnRejectedAdapter::adapt(OnRejected&& onRejected) -> typename std::enable_if<
+    std::is_assignable<OnRejectedWithResolver<R>, OnRejected>::value &&
+        !std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value,
+    PromiseState::OnRejected>::type {
+    OnRejectedWithResolver<R> function{std::forward<OnRejected>(onRejected)};
+    if (function) {
+        return std::bind(
+            &invokeWithResolver<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState> - target state
+            std::placeholders::_2);  // std::error_condition          - reject reason
+    }
+    return nullptr;
+}
+
+template <typename R, typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline auto OnRejectedAdapter::adapt(OnRejected&& onRejected) -> typename std::enable_if<
+    std::is_assignable<OnRejectedWithValue<R>, OnRejected>::value &&
+        !std::is_assignable<OnRejectedWithPromise<R>, OnRejected>::value,
+    PromiseState::OnRejected>::type {
+    OnRejectedWithValue<R> function{std::forward<OnRejected>(onRejected)};
+    if (function) {
+        return std::bind(
+            &invokeWithValue<R>,
+            std::move(function),
+            std::placeholders::_1,   // std::shared_ptr<PromiseState> - target state
+            std::placeholders::_2);  // std::error_condition          - reject reason
+    }
+    return nullptr;
+}
+
+template <typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline auto OnRejectedAdapter::adaptFinally(OnRejected&& onRejected) -> typename std::enable_if<
+    !std::is_same<std::nullptr_t, OnRejected>::value && std::is_assignable<OnRejectedFinally, OnRejected>::value,
+    PromiseState::OnRejected>::type {
+    OnRejectedFinally function{std::forward<OnRejected>(onRejected)};
+    if (function) {
+        return std::bind(
+            &OnRejectedFinally::operator(),
+            std::move(function),
+            std::placeholders::_2);  // std::error_condition - reject reason
+    }
+    return nullptr;
+}
+
+template <typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline auto OnRejectedAdapter::adaptFinally(OnRejected&& onRejected) ->
+    typename std::enable_if<std::is_same<std::nullptr_t, OnRejected>::value, PromiseState::OnRejected>::type {
+    return std::forward<OnRejected>(onRejected);
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnRejectedAdapter::invokeWithResolver(
+    const OnRejectedWithResolver<R>& onRejected,
+    const std::shared_ptr<PromiseState>& destinationState,
+    const std::error_condition& rejectReason) {
+    onRejected(rejectReason, PromiseResolver<R>{destinationState});
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline void OnRejectedAdapter::invokeWithPromise(
+    const OnRejectedWithPromise<R>& onRejected,
+    const std::shared_ptr<PromiseState>& destinationState,
+    const std::error_condition& rejectReason) {
+    auto promise = onRejected(rejectReason);
+    if (promise.m_state) {
+        promise.m_state->addResultConsumer(destinationState, nullptr, nullptr, nullptr);
+    } else {
+        destinationState->reject(std::errc::invalid_argument);
+    }
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<R, void>::value, void>::type OnRejectedAdapter::
+    invokeWithValue(
+        const OnRejectedWithValue<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason) {
+    destinationState->resolve(std::make_shared<R>(onRejected(rejectReason)));
+}
+
+template <typename R>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<std::is_same<R, void>::value, void>::type OnRejectedAdapter::
+    invokeWithValue(
+        const OnRejectedWithValue<R>& onRejected,
+        const std::shared_ptr<PromiseState>& destinationState,
+        const std::error_condition& rejectReason) {
+    onRejected(rejectReason);
+    destinationState->fulfillWithVoid();
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_ONREJECTEDADAPTER_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseImpl.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseImpl.h
new file mode 100644
index 00000000..9e2d2332
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseImpl.h
@@ -0,0 +1,227 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISEIMPL_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISEIMPL_H_
+
+#include <functional>
+#include <memory>
+#include <tuple>
+#include <type_traits>
+
+#include <AVSCommon/Utils/Threading/Internal/OnFulfilledAdapter.h>
+#include <AVSCommon/Utils/Threading/Internal/OnRejectedAdapter.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+template <typename... Promises>
+ACSDK_INLINE_VISIBILITY inline Promise<void> PromiseCommon::all(Promises&... promises) {
+    return PromiseCommon::commonAggregate(PromiseState::Aggregate::ALL, {promises.m_state...});
+}
+
+template <typename... Promises>
+ACSDK_INLINE_VISIBILITY inline Promise<void> PromiseCommon::any(Promises&... promises) {
+    return PromiseCommon::commonAggregate(PromiseState::Aggregate::ANY, {promises.m_state...});
+}
+
+template <typename... Promises>
+ACSDK_INLINE_VISIBILITY inline Promise<void> PromiseCommon::race(Promises&... promises) {
+    return PromiseCommon::commonAggregate(PromiseState::Aggregate::RACE, {promises.m_state...});
+}
+
+template <typename T>
+template <typename T1>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<T1, void>::value, Promise<T>>::type Promise<
+    T>::resolve(T1&& value) {
+    return Promise<T>(std::make_shared<PromiseState>(PromiseTypeTraits<T>::emplace(std::forward<T1>(value))));
+}
+
+template <typename T>
+template <typename... Args>
+ACSDK_INLINE_VISIBILITY inline Promise<T> Promise<T>::resolveEmplace(Args&&... args) {
+    return Promise<T>(std::make_shared<PromiseState>(PromiseTypeTraits<T>::emplace(std::forward<Args>(args)...)));
+}
+
+template <typename T>
+template <typename T1>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<std::is_same<T1, void>::value, Promise<T>>::type Promise<
+    T>::resolve() {
+    return Promise<T>(std::make_shared<PromiseState>(PromiseState::getVoidValue()));
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T> Promise<T>::reject(const std::error_condition& value) {
+    return Promise<T>(std::make_shared<PromiseState>(value));
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline std::tuple<Promise<T>, PromiseResolver<T>> Promise<T>::__makePending() {
+    auto state = std::make_shared<PromiseState>();
+    return std::make_tuple(Promise<T>(state), PromiseResolver<T>(state));
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T>::Promise() noexcept : PromiseCommon() {
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T>::Promise(std::shared_ptr<PromiseState> state) noexcept :
+        PromiseCommon(std::move(state)) {
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T>::Promise(const Promise<T>& arg) noexcept : PromiseCommon(arg) {
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T>::Promise(Promise<T>&& arg) noexcept : PromiseCommon(std::move(arg)) {
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline Promise<T>& Promise<T>::operator=(Promise<T>&& arg) noexcept {
+    std::shared_ptr<PromiseState> tmp{std::move(arg.m_state)};
+    std::swap(m_state, tmp);
+    return *this;
+}
+
+template <typename T>
+template <typename Q>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<
+    !std::is_same<Q, void>::value && std::is_assignable<Q&, T>::value && !std::is_nothrow_assignable<Q&, T>::value,
+    bool>::type
+Promise<T>::getValue(Q& value) const {
+    const auto valuePtr = getResultValue();
+    if (valuePtr) {
+        value = *static_cast<const T*>(valuePtr);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+template <typename T>
+template <typename Q>
+ACSDK_INLINE_VISIBILITY inline
+    typename std::enable_if<!std::is_same<Q, void>::value && std::is_nothrow_assignable<Q&, T>::value, bool>::type
+    Promise<T>::getValue(Q& value) const noexcept {
+    const auto valuePtr = getResultValue();
+    if (valuePtr) {
+        value = *static_cast<const T*>(valuePtr);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+template <typename T>
+template <typename Init>
+ACSDK_INLINE_VISIBILITY inline Promise<T>::Promise(std::shared_ptr<ExecutorInterface> executor, Init&& init) {
+    commonInit(std::move(executor), OnFulfilledAdapter<void>::adapt<T>(std::forward<Init>(init)));
+}
+
+template <typename T>
+template <typename R, typename OnFulfilled, typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline Promise<R> Promise<T>::then(
+    std::shared_ptr<ExecutorInterface> executor,
+    OnFulfilled&& onFulfilled,
+    OnRejected&& onRejected) {
+    return Promise<R>(commonThen(
+        std::move(executor),
+        OnFulfilledAdapter<T>::template adapt<R>(std::forward<OnFulfilled>(onFulfilled)),
+        OnRejectedAdapter::template adapt<R>(std::forward<OnRejected>(onRejected))));
+}
+
+template <typename T>
+template <typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline Promise<T> Promise<T>::thenCatch(
+    std::shared_ptr<ExecutorInterface> executor,
+    OnRejected&& onRejected) {
+    return Promise<T>(commonThenCatch(
+        std::move(executor), OnRejectedAdapter::template adapt<T>(std::forward<OnRejected>(onRejected))));
+}
+
+template <typename T>
+template <typename OnFulfilled, typename OnRejected>
+ACSDK_INLINE_VISIBILITY inline Promise<T>& Promise<T>::finally(
+    std::shared_ptr<ExecutorInterface> executor,
+    OnFulfilled&& onFulfilled,
+    OnRejected&& onRejected) {
+    commonFinally(
+        std::move(executor),
+        OnFulfilledAdapter<T>::adaptFinally(std::forward<OnFulfilled>(onFulfilled)),
+        OnRejectedAdapter::adaptFinally(std::forward<OnRejected>(onRejected)));
+
+    return *this;
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void Promise<T>::swap(Promise<T>& arg) noexcept {
+    std::swap(m_state, arg.m_state);
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY Promise<T>& Promise<T>::await() noexcept {
+    wait();
+    return *this;
+}
+
+template <typename T>
+template <typename Rep, typename Period>
+ACSDK_INLINE_VISIBILITY Promise<T>& Promise<T>::awaitFor(const std::chrono::duration<Rep, Period>& duration) noexcept {
+    waitFor(duration);
+    return *this;
+}
+
+template <typename T>
+template <typename Clock, typename Duration>
+ACSDK_INLINE_VISIBILITY Promise<T>& Promise<T>::awaitUntil(
+    const std::chrono::time_point<Clock, Duration>& timePoint) noexcept {
+    waitUntil(timePoint);
+    return *this;
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+namespace std {
+
+/**
+ * @brief Swap states of two promise objects.
+ *
+ * Method swaps states of two promise objects. This method is an eqiovalent of calling:
+ * @code
+ * promise1.swap(promise2)
+ * @endcode
+ *
+ * @tparam T Eventual result type.
+ *
+ * @param[in, out] promise1  First promise for state swap with @a promise2.
+ * @param[in, out] promise2  Second promise for state swap with @a promise1.
+ */
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void swap(
+    alexaClientSDK::avsCommon::utils::threading::Promise<T>& promise1,
+    alexaClientSDK::avsCommon::utils::threading::Promise<T>& promise2) noexcept {
+    promise1.swap(promise2);
+}
+
+}  // namespace std
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISEIMPL_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseState.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseState.h
new file mode 100644
index 00000000..74c92139
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseState.h
@@ -0,0 +1,706 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISESTATE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISESTATE_H_
+
+#include <chrono>
+#include <condition_variable>
+#include <list>
+#include <memory>
+#include <mutex>
+#include <system_error>
+
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Shared state class for @a Promise<T> and @a PromiseResolver<T>.
+ *
+ * This object manages a state for a promise object. This state can be shared between multiple instances of Promise<T>
+ * and PromiseResolver<T>.
+ *
+ * Shared state can be in one of three states: pending, fulfilled, or rejected.
+ *
+ * When in pending state, the method allows addition of new callback functions for state transition notification and
+ * state transition to pending or rejected state.
+ *
+ * To transition from pending to fulfilled state, client must provide a shared pointer to data. Any further calls to
+ * change the state will be ignored.
+ *
+ * To transition from pending to rejected state, client must provide a reject reason @a std::error_condition. Any
+ * further calls to change the state will be ignored.
+ *
+ * When state changes, object sequentially calls all installed callbacks (from the same thread).
+ *
+ * Shared state object can have one of following states: pending, fulfilled, rejected. Object is in resolved state, if
+ * it is not pending. It is possible to transition states only from pending to fulfilled, or from pending to rejected.
+ * Both fulfilled and rejected states are final, and subsequent object mutations (including object state transitions)
+ * are not possible.
+ *
+ * @note This class is thread safe.
+ * @note This class is using type erasure to reduce memory footprint.
+ *
+ * @see Promise<T>
+ * @see PromiseResolver<T>
+ *
+ * @ingroup PromiseAPI
+ * @private
+ */
+class PromiseState {
+public:
+    /**
+     * @brief Value type.
+     *
+     * PromiseState treats all values as shared pointers to const void.
+     */
+    using Value = const void;
+
+    /**
+     * @brief Eventual result consumer function.
+     *
+     * OnFulfilled functions are invoked whenever state changes to fulfilled. If the state is rejected, the function is
+     * not called.
+     *
+     * Functions are held by reference, and expected to appropriately handle fulfillment value or reject reason and
+     * forward call to managed executor. Callback functions may also have strong references to other shared state
+     * objects. While it is possible to have circular reference loop in this manner, there is no memory leak as long as
+     * the shared state becomes fulfilled or rejected.
+     *
+     * @param[in] dependentState Destination state for the new result if available, or nullptr if there is no dependent
+     *                           state.
+     * @param[in] value          Shared fulfillment value reference. This value is never nullptr.
+     */
+    using OnFulfilled =
+        std::function<void(const std::shared_ptr<PromiseState> dependentState, const std::shared_ptr<Value>& value)>;
+
+    /**
+     * @brief Eventual reject reason consumer function.
+     *
+     * OnRejected functions are invoked whenever state changes to rejected.
+     *
+     * These functions are executed in the thread that fulfills or rejects state, and they must neither block execution,
+     * nor delay it.
+     *
+     * Functions are held by reference, and expected to appropriately handle fulfillment value or reject reason and
+     * forward call to managed executor. Callback functions may also have strong references to other shared state
+     * objects. While it is possible to have circular reference loop in this manner, there is no memory leak as long as
+     * the shared state becomes fulfilled or rejected.
+     *
+     * @param[in] dependentState Destination state for the new result if available, or nullptr if there is no dependent
+     *                           state.
+     * @param[in] rejectReason   Reject reason. The error code is never zero.
+     */
+    using OnRejected = std::function<
+        void(const std::shared_ptr<PromiseState> dependentState, const std::error_condition& rejectReason)>;
+
+    /**
+     * @brief Aggregate types.
+     */
+    enum class Aggregate {
+        /// Aggregate is not used.
+        NONE = 1,
+        /// Aggregate for PromiseCommon::all().
+        ALL,
+        /// Aggregate for PromiseCommon::any().
+        ANY,
+        /// Aggregate for PromiseCommon::race().
+        RACE
+    };
+
+    /**
+     * @brief Provide value with @a void moniker.
+     *
+     * Void values do not occupy memory, but in order to treat void as a regular reference type, we provide a valid
+     * pointer that never changes during application execution.
+     *
+     * @return Shared pointer to void moniker.
+     */
+    static std::shared_ptr<PromiseState::Value> getVoidValue() noexcept;
+
+    /**
+     * @brief Return system executor.
+     *
+     * System executor doesn't give guarantees for task execution order. It can be single- or multi-threaded.
+     *
+     * @return Reference to system executor for Promise API.
+     */
+    static std::shared_ptr<ExecutorInterface> getSystemExecutor() noexcept;
+
+    /**
+     * @brief Helper to execute task with system executor.
+     *
+     * @param[in] task Task to execute.
+     */
+    static void executeInSystemExecutor(std::function<void()>&& task) noexcept;
+
+    /**
+     * @brief Get global mutex.
+     *
+     * Method returns global mutex for all state transitions. Global mutex enables atomic transition of promise state
+     * object graph, so when there are cross-dependencies between different states and eventual result handlers, the
+     * system transitions in a predictable way.
+     *
+     * @return Global mutex.
+     */
+    static std::mutex& getGlobalMutex() noexcept;
+
+    /**
+     * @brief Constructs object.
+     *
+     * Constructs object in pending state.
+     */
+    PromiseState() noexcept;
+
+    /**
+     * @brief Constructs object.
+     *
+     * The object is initialized in fulfilled state with given data. The object isn't aware of the data type.
+     *
+     * @param[in] value Value to store. If @a value is nullptr, constructor sets state to rejected with
+     *                  std::errc::invalid_argument reject reason.
+     */
+    explicit PromiseState(std::shared_ptr<Value> value) noexcept;
+
+    /**
+     * @brief Constructs object in rejected state.
+     *
+     * @param[in] rejectReason Reject reason. If @a rejectReason has zero code, constructor sets state to rejected with
+     *                         std::errc::invalid_argument reject reason.
+     */
+    explicit PromiseState(const std::error_condition& rejectReason) noexcept;
+
+    /**
+     * @brief Destroys object.
+     *
+     * Method destroys the object and releases any result data if present. If the object is in pending state, it is
+     * rejected with std::errc::broken_pipe reject reason and all registered callbacks are notified prior to release.
+     */
+    ~PromiseState() noexcept;
+
+    /**
+     * @brief Check if the state is either fulfilled or rejected.
+     *
+     * This method checks if the object is fulfilled and has a value, or rejected and has an error. This method is
+     * an equivalent of the following:
+     * @code
+     * // Object is resolved if it is fulfilled or rejected.
+     * state.isFulfilled() || state.isRejected()
+     * // Object is resolved if it is not pending.
+     * !state.isPending()
+     * @endcode
+     *
+     * @return True if object either fulfilled and has a value, or rejected and has an error. False if the object is in
+     *         pending state.
+     */
+    bool isResolved() const noexcept;
+
+    /**
+     * @brief Check if the state is pending.
+     *
+     * The method checks if the object is in pending state. This method is an equivalent of the following:
+     * @code
+     * // Object is pending if it is neither fulfilled nor rejected.
+     * !state.isFulfilled() && !state.isRejected()
+     * // Object is pending if it is not resolved.
+     * !state.isResolved()
+     * @endcode
+     *
+     * @return True if object is neither fulfilled nor rejected, false otherwise.
+     */
+    bool isPending() const noexcept;
+
+    /**
+     * @brief Check if the promise is fulfilled.
+     *
+     * This method checks if the promise is fulfilled and has a result value.
+     *
+     * @return True if the object is fulfilled with a value. False if the object is rejected with an error or is in
+     *         pending state.
+     */
+    bool isFulfilled() const noexcept;
+
+    /**
+     * @brief Check if the promise is in rejected state.
+     *
+     * @return True if promise is in rejected state and has an error value. False if the object is fulfilled or is in
+     *         pending state.
+     */
+    bool isRejected() const noexcept;
+
+    /**
+     * @brief Transfer state to rejected.
+     *
+     * Method transfers the object into rejected state and assigns an error value if the state is pending.
+     *
+     * If there are installed handlers, this method triggers an immediate execution of them.
+     *
+     * @param[in] error Error code to set. If the value is 0, the method will attempt to set @c
+     *                  std::errc::invalid_argument error.
+     *
+     * @return True if promise has been transferred into rejected state. False if the object was not in pending state.
+     */
+    bool reject(const std::error_condition& error) noexcept;
+
+    /**
+     * @brief Return error code if available.
+     *
+     * @param[out] rejectReason Error code if the promise is completed with error. If the method fails, the
+     *                          @a rejectReason value is unmodified.
+     *
+     * @return True if state is rejected and value is retrieved into @a rejectReason, false otherwise.
+     */
+    bool getRejectReason(std::error_condition& rejectReason) noexcept;
+
+    /**
+     * @{
+     * @brief Transfer the object into fulfilled state with a value.
+     *
+     * Method checks if the object is in pending state and if so, stores a value @a value and transitions the object
+     * into fulfilled state.
+     *
+     * If there are installed handlers, this method triggers an immediate execution of them.
+     *
+     * @param[in] value Value to store. If @a value is nullptr, the object changes state to rejected with
+     *                  std::errc::invalid_argument error.
+     *
+     * @return True if the state has been transitioned, false otherwise.
+     */
+    bool resolve(std::shared_ptr<Value>&& value) noexcept;
+    bool resolveCopy(const std::shared_ptr<Value>& value) noexcept;
+    /// @}
+
+    /**
+     * @brief Transfer the object into fulfilled state without a value.
+     *
+     * Method checks if the object is in pending state and if so transitions the object into fulfilled state.
+     *
+     * If there are installed handlers, this method triggers an immediate execution of them.
+     *
+     * @return True if the state has been transitioned, false otherwise.
+     */
+    bool fulfillWithVoid() noexcept;
+
+    /**
+     * @brief Get result data pointer.
+     *
+     * The method returns result data pointer if the promise is completed with result. The returned pointer is still
+     * owned by this class.
+     *
+     * @param[out] value Data pointer. On error the @a value is unmodified.
+     *
+     * @return True if the state is fulfilled and the data has been retrieved, false otherwise.
+     */
+    bool getValue(std::shared_ptr<Value>& value) const noexcept;
+
+    // Deleted operations.
+    PromiseState(const PromiseState&) = delete;
+    PromiseState(PromiseState&&) = delete;
+    void operator=(const PromiseState&) = delete;
+    void operator=(PromiseState&&) = delete;
+
+    /**
+     * @brief Register dependent state and result consumers.
+     *
+     * If the current state is pending, the method adds parameters to a list of dependents.
+     *
+     * Whenever promise objects get a result set, all connected result handling/transformation functions are invoked.
+     * If promise object is cancelled or encounters an error, connected result function are not invoked, but child
+     * promises get the same cancellation or error signal.
+     *
+     * If this object is in pending state, the method registers parameters for a later use, otherwise it immediately
+     * schedules an execution of a handler (if specified), or propagates a result into dependent state (if specified).
+     *
+     * It is possible to have empty handlers if the result must be directly propagated into dependent state.
+     *
+     * @param[in] dependentState Optional dependent state. This parameter is used (when available) to propagate
+     *                           fulfillment value or reject reason when appropriate handler is empty, or there is an
+     *                           error. If @a dependentState is not nullptr, either or both handlers may be empty. If
+     *                           @a dependentState is nullptr, one of the handlers must not be empty.
+     * @param[in] executor       Executor interface. This executor is used for scheduling execution of @a onFulfilled or
+     *                           @a onRejected handler. If call to executor fails with an error, the error is propagated
+     *                           to @a dependentState (if specified)
+     * @param[in] onFulfilled    Optional eventual value handler function. The function is responsible to handle the
+     *                           value and updating the dependent state (if any). If @a onFulfilled is not empty, @a
+     *                           executor must not be nullptr.
+     * @param[in] onRejected     Optional eventual error handler function. The function is responsible to handle the
+     *                           reject reason and updating the dependent state (if any). If @a onFulfilled is not
+     *                           empty, @a executor must not be nullptr.
+     */
+    void addResultConsumer(
+        std::shared_ptr<PromiseState> dependentState,
+        std::shared_ptr<ExecutorInterface> executor,
+        OnFulfilled&& onFulfilled,
+        OnRejected&& onRejected);
+
+    /**
+     * @brief Adds aggregate consumer.
+     *
+     * Aggregate consumers are handled differently from consumers with handlers. Whenever a promise gets resolved,
+     * the implementation decides if the result can be propagated. Otherwise, a shared counter must be updated, and the
+     * result must be propagated only when the counter reaches zero.
+     *
+     * @param[in] dependentState Dependent state to resolve.
+     * @param[in] type           Aggregate operation type.
+     * @param[in] count          Shared counter (optional). Not all aggregate operations need a shared counter.
+     */
+    void addResultConsumer(
+        std::shared_ptr<PromiseState> dependentState,
+        Aggregate type,
+        std::shared_ptr<std::size_t> count);
+
+    /**
+     * @brief Blocks the caller's thread until object's state is set to VALUE or ERROR.
+     *
+     * Method blocks caller's thread until this object reaches any of the final states. If the object is in the final
+     * state when the call is made, the method returns immediately.
+     */
+    void wait() noexcept;
+
+    /**
+     * @brief Blocks the caller's thread until object's state is set to VALUE or ERROR or timeout expires.
+     *
+     * Method blocks caller's thread until this object reaches any of the final states or @a duration timeout elapses.
+     * If the object is in the final state when the call is made, the method returns immediately.
+     *
+     * @param[in] duration Maximum time interval to wait for a state change.
+     * @return True if object is in VALUE or ERROR state, and False if timeout expires.
+     */
+    bool waitFor(const std::chrono::steady_clock::duration& duration) noexcept;
+
+    /**
+     * @brief Blocks the caller's thread until object's state is set to VALUE or ERROR or timeout expires.
+     *
+     * Method blocks caller's thread until this object reaches any of the final states or @a timePoint time is reached.
+     * If the object is in the final state when the call is made, the method returns immediately.
+     *
+     * @param[in] timePoint Time point to wait until if the object's state stays is INITIAL.
+     * @return True if object is in VALUE or ERROR state, and False if timeout expires.
+     */
+    bool waitUntil(const std::chrono::steady_clock::time_point& timePoint) noexcept;
+
+    /**
+     * @brief Return object handle.
+     *
+     * All objects are enumerated with non-zero values during application lifecycle. This value can be used for
+     * debugging purposes.
+     *
+     * @return Object handle.
+     */
+    std::uint64_t getHandle() const noexcept;
+
+protected:
+    /**
+     * @brief Object states.
+     */
+    enum class State {
+        /// Object is in pending state.
+        PENDING = 1,
+        /// Object is in final state with an error code.
+        REJECTED,
+        /// Object is in final state with a user data.
+        FULFILLED
+    };
+
+    // Forward declaration.
+    class ResultConsumer;
+
+    /**
+     * @brief List of connected result consumers.
+     *
+     * Result consumers is a list of functions to execute when the state is transitioned from pending into fulfilled or
+     * rejected.
+     */
+    using ResultConsumerList = std::list<ResultConsumer>;
+
+    /**
+     * @brief Result consumer entry.
+     *
+     * Object contains type of entry and destination. This structure is used for maintaining list of connected result
+     * consumers, and for execution of result delivery.
+     */
+    class ResultConsumer {
+    public:
+        /**
+         * @brief Constructs result consumer entry.
+         *
+         * @param[in] dependentState Dependent state for direct result propagation.
+         * @param[in] executor       Executor for scheduling @a onFulfilled or @a onRejected operation.
+         * @param[in] onFulfilled    Handler function to handle eventual value.
+         * @param[in] onRejected     Handler function to handle reject reason.
+         */
+        ResultConsumer(
+            std::shared_ptr<PromiseState>&& dependentState,
+            std::shared_ptr<ExecutorInterface>&& executor,
+            OnFulfilled&& onFulfilled,
+            OnRejected&& onRejected) noexcept;
+
+        /**
+         * @brief Constructs result entry for aggregate operation.
+         *
+         * @param[in] dependentState Dependent state.
+         * @param[in] type           Aggregate operation type.
+         * @param[in] count          Shared counter to track when aggregate operation completes.
+         */
+        ResultConsumer(
+            std::shared_ptr<PromiseState>&& dependentState,
+            Aggregate type,
+            std::shared_ptr<std::size_t>&& count) noexcept;
+
+        /**
+         * @brief Sets a fulfillment value for result handling.
+         *
+         * This method must be called before calling ConsumerResult::notifyLocked().
+         *
+         * @param[in] value Value to set.
+         *
+         * @note This method requires that the caller holds promise state lock (global object). This simplifies logic
+         *       and reduces number of edge cases due to race conditions.
+         */
+        void attachValueLocked(const std::shared_ptr<PromiseState::Value>& value) noexcept;
+
+        /**
+         * @brief Sets a reject result for result handling.
+         *
+         * This method must be called before calling ConsumerResult::notifyLocked().
+         *
+         * @param[in] rejectReason Reject reason to set.
+         *
+         * @note This method requires that the caller holds promise state lock (global object). This simplifies logic
+         *       and reduces number of edge cases due to race conditions.
+         */
+        void attachRejectReasonLocked(const std::error_condition& rejectReason) noexcept;
+
+        /**
+         * @brief Updates state of the target state and fills in propagation backlog.
+         *
+         * If this object has a target state, and target state is not resolved, then this method fulfills the target
+         * state, and moves all result handlers out of it into @a consumerBacklog. Moved entries are updated to have
+         * the same fulfillment value.
+         *
+         * @param[out] consumersBacklog Destination container for result handlers. The entries will be added to this
+         *                              collection without memory allocation operations.
+         */
+        void propagateValueLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /**
+         * @brief Updates state of the target state and fills in propagation backlog.
+         *
+         * If this object has a target state, and target state is not resolved, then this method rejects the target
+         * state, and moves all result handlers out of it into @a consumerBacklog. Moved entries are updated to have
+         * the same reject reason.
+         *
+         * This method requires that caller holds result propagation lock.
+         *
+         * @param[out] consumersBacklog Destination container for result handlers. The entries will be added to this
+         *                              collection without memory allocation operations.
+         */
+        void propagateRejectReasonLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /**
+         * @brief Handle result for resolve operations.
+         *
+         * This method dispatches call to one of more specific handlers. This method requires that either fulfillment
+         * value (through ResultConsumer::attachValueLocked() ) or reject reason (through
+         * ResultConsumer::attachRejectReasonLocked() ) are attached prior to the call.
+         *
+         * The method clears all object properties during execution.
+         *
+         * @param[in] handle           Handler for a state object, that has initiated result propagation operation.
+         * @param[in] consumersBacklog Destination backlog to add more consumers when result can be propagated to them
+         *                             too.
+         *
+         * @note This method requires that the caller holds promise state lock (global object). This simplifies logic
+         *       and reduces number of edge cases due to race conditions.
+         *
+         * @see ResultConsumer::attachValueLocked()
+         * @see ResultConsumer::attachRejectReasonLocked()
+         * @see ResultConsumer::notifyOnNonAggregateLocked()
+         * @see ResultConsumer::notifyOnAllAggregateLocked()
+         * @see ResultConsumer::notifyOnAnyAggregateLocked()
+         */
+        void notifyLocked(std::uint64_t handle, std::list<ResultConsumer>& consumersBacklog);
+
+    private:
+        /**
+         * @brief Handle result for non-aggregate operations.
+         *
+         * Method either schedules execution of handler using stored executor interface or propagates result to
+         * dependent state for non-aggregate operations.
+         *
+         * When propagating result, the function populates target state's consumer entries with result values and moves
+         * them into current backlog. This enables handling state propagation for arbitrary size graphs without
+         * unnecessary memory allocation and without recursion.
+         *
+         * @param[in, out] consumersBacklog Backlog where to move entries from consumer's target backlog when
+         *                                  propagating result.
+         */
+        void notifyOnNonAggregateLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /**
+         * @brief Handle result for Aggregate::ALL operations.
+         *
+         * The method implements logic for computing result of Aggregate::ALL operations. If the current result is
+         * rejected, the destination state is transferred into rejected state, it's consumer entries are updated with
+         * reject reason and moved into backlog. Otherwise a shared counter is decreased. If shared counter value
+         * reaches zero, the destination state is transferred into fulfilled state, it's consumer entries are updated
+         * with fulfillment (void) value and moved into backlog.
+         *
+         * @param[in, out] consumersBacklog Backlog where to move entries from consumer's target backlog when
+         *                                  propagating result.
+         */
+        void notifyOnAllAggregateLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /**
+         * @brief Handle result for Aggregate::ANY operations.
+         *
+         * The method implements logic for computing result of Aggregate::ANY operations. If the current result is
+         * rejected, the shared counter value is decreased if it reaches 0, the destination state is transferred into
+         * rejected state with @a std::errc::cancelled_operation reject reason. After that the result is propagated into
+         * destination state. If the current state is fulfilled, the target state is fulfilled with void and result is
+         * propagated.
+         *
+         * @param[in, out] consumersBacklog Backlog where to move entries from consumer's target backlog when
+         *                                  propagating result.
+         */
+        void notifyOnAnyAggregateLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /**
+         * @brief Handle result for Aggregate::RACE operations.
+         *
+         * The method implements logic for computing result of Aggregate::RACE operations. If the current result is
+         * rejected, the destination state is transferred into rejected state with the same reject reason. If the
+         * current result is fulfilled, the destination state is transferred into fulfilled state with void value. Then
+         * the method updates destination state consumers with the result value and moves them into backlog.
+         *
+         * @param[in, out] consumersBacklog Backlog where to move entries from consumer's target backlog when
+         *                                  propagating result.
+         */
+        void notifyOnRaceAggregateLocked(ResultConsumerList& consumersBacklog) noexcept;
+
+        /// @brief Aggregate type if any.
+        Aggregate m_type;
+
+        /// @brief Dependent state (optional).
+        std::shared_ptr<PromiseState> m_dependentState;
+
+        /// @brief Executor for OnFulfilled and OnRejected handlers (optional).
+        std::shared_ptr<ExecutorInterface> m_executor;
+
+        /// @brief Eventual value handler (optional).
+        OnFulfilled m_onFulfilled;
+
+        /// @brief Eventual reject reason handler (optional).
+        OnRejected m_onRejected;
+
+        /// @brief Counter for aggregate operations.
+        std::shared_ptr<std::size_t> m_aggregateCounter;
+
+        /// @brief Reject reason if the consumer is awaiting for reject reason delivery.
+        std::error_condition m_rejectReason;
+
+        /// @brief Fulfillment value if the consumer is awaiting for value delivery.
+        std::shared_ptr<Value> m_value;
+    };
+
+    /**
+     * @brief Returns next value for object handle.
+     *
+     * All state objects are enumerated through a lifecycle of application. This is done for debugging purposes, as
+     * applications may inspect and log state objects.
+     *
+     * @return Next value for state handle. This value is guaranteed to be non-zero.
+     * @see #getHandle().
+     */
+    static std::uint64_t getNextHandleValue() noexcept;
+
+    /**
+     * @brief Propagate state change event to consumers.
+     *
+     * @param consumers Event consumers.
+     *
+     * @warning This method may be called only when the state is resolved.
+     */
+    void notifyResultConsumersLocked(ResultConsumerList&& consumers) noexcept;
+
+    /**
+     * @brief Internal method to fulfill the object.
+     *
+     * This method atomically transitions object from pending into fulfilled state.
+     *
+     * @param[in] value Value to store.
+     * @param[in] move  Flag if the @a value reference should be moved (true) or copied (false).
+     *
+     * @return True if state transition succeeds, false otherwise.
+     */
+    bool fulfill(std::shared_ptr<Value>& value, bool move) noexcept;
+
+    /// Unique handle for debugging.
+    const uint64_t m_handle;
+
+    /// Condition variable for wait calls.
+    mutable std::condition_variable m_cond;
+
+    /// Object state.
+    volatile State m_state;
+
+    union {
+        /// Fulfillment value. This field is constructed only when state becomes fulfilled.
+        std::shared_ptr<Value> m_value;
+
+        /// Reject reason. This field is constructed only when state becomes rejected.
+        std::error_condition m_rejectReason;
+
+        /// Connected consumers for state change notification. This field is constructed only when state is pending.
+        /// @see ResultConsumerList
+        mutable ResultConsumerList m_resultConsumers;
+    };
+};
+
+/**
+ * @{
+ * @brief Log shared state details.
+ *
+ * Method logs object state and handle.
+ *
+ * @param[in] out   Stream to log into.
+ * @param[in] state Shared state.
+ *
+ * @return Reference to @a out.
+ */
+std::ostream& operator<<(std::ostream& out, const PromiseState& state);
+std::ostream& operator<<(std::ostream& out, const std::shared_ptr<PromiseState>& state);
+/// @}
+
+/**
+ * @brief Prints aggregate operation type.
+ *
+ * @param[in] out  Stream to log data
+ * @param[in] type Aggregate operation type.
+ *
+ * @return Reference to @a out.
+ */
+std::ostream& operator<<(std::ostream& out, PromiseState::Aggregate type);
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISESTATE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h
new file mode 100644
index 00000000..789f1021
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISETYPETRAITS_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISETYPETRAITS_H_
+
+#include <functional>
+#include <memory>
+
+#include <AVSCommon/Utils/Threading/Internal/PromiseState.h>
+#include <AVSCommon/Utils/PlatformDefinitions.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+// Forward declaration
+template <typename T>
+class PromiseResolver;
+template <typename T>
+class Promise;
+
+/**
+ * @brief Type traits for @a Promise<T>.
+ *
+ * This template provides types and adapters for @a Promise<T> when T is not a @a void. The type provides @a onFulfilled
+ * and @a onRejected handler types for non-void @a T and operations to invoke then using type-erased values from
+ * PromiseState.
+ *
+ * @tparam T Promise value type.
+ * @ingroup PromiseAPI
+ * @private
+ */
+template <typename T>
+class PromiseTypeTraits {
+public:
+    /// @copydoc Promise::InitWithResolver
+    using InitWithResolver = std::function<void(PromiseResolver<T> resolver)>;
+
+    /// @copydoc Promise::InitWithPromise
+    using InitWithPromise = std::function<Promise<T>()>;
+
+    /// @copydoc Promise::InitWithValue
+    using InitWithValue = std::function<T()>;
+
+    /// @copydoc Promise::OnFulfilledWithResolver
+    template <typename R>
+    using OnFulfilledWithResolver = std::function<void(const T& value, PromiseResolver<R> resolver)>;
+
+    /// @copydoc Promise::OnRejectedWithResolver
+    template <typename R>
+    using OnRejectedWithResolver =
+        std::function<void(const std::error_condition& rejectReason, PromiseResolver<R> resolver)>;
+
+    /// @copydoc Promise::OnFulfilledFinally
+    using OnFulfilledFinally = std::function<void(const T& value)>;
+
+    /// @copydoc Promise::OnRejectedFinally
+    using OnRejectedFinally = std::function<void(const std::error_condition& rejectReason)>;
+
+    /// @copydoc Promise::OnFulfilledWithPromise
+    template <typename R>
+    using OnFulfilledWithPromise = std::function<Promise<R>(const T& value)>;
+
+    /// @copydoc Promise::OnRejectedWithPromise
+    template <typename R>
+    using OnRejectedWithPromise = std::function<Promise<R>(const std::error_condition& rejectReason)>;
+
+    /// @copydoc Promise::OnFulfilledWithValue
+    template <typename R>
+    using OnFulfilledWithValue = std::function<R(const T& value)>;
+
+    /// @copydoc Promise::OnRejectedWithValue
+    template <typename R>
+    using OnRejectedWithValue = std::function<R(const std::error_condition& rejectReason)>;
+
+    /**
+     * @brief Construct value of @a T with supplied arguments.
+     *
+     * Method creates a shared reference to T using in-place construction with given arguments.
+     *
+     * @tparam Args Argument types for construction.
+     *
+     * @param[in] args Arguments for constructing instance of @a T.
+     *
+     * @return Shared pointer that manages constructed instance of @a T.
+     */
+    template <typename... Args>
+    ACSDK_INLINE_VISIBILITY static std::shared_ptr<PromiseState::Value> emplace(Args&&... args);
+};
+
+/**
+ * @brief Type traits for @a Promise<void>.
+ *
+ * This template provides types and adapters for @a Promise<void>. The type provides @a onFulfilled and @a onRejected
+ * handler types for void eventual result and operations to invoke then using type-erased values from PromiseState.
+ *
+ * @see PromiseTypeTraits
+ * @ingroup PromiseAPI
+ * @private
+ */
+template <>
+class PromiseTypeTraits<void> {
+public:
+    /// @copydoc Promise::InitWithResolver
+    using InitWithResolver = std::function<void(PromiseResolver<void> resolver)>;
+
+    /// @copydoc Promise::InitWithPromise
+    using InitWithPromise = std::function<Promise<void>()>;
+
+    /// @copydoc Promise::InitWithValue
+    using InitWithValue = std::function<void()>;
+
+    /// @copydoc Promise::OnFulfilledWithResolver
+    template <typename R>
+    using OnFulfilledWithResolver = std::function<void(PromiseResolver<R> resolver)>;
+
+    /// @copydoc Promise::OnRejectedWithResolver
+    template <typename R>
+    using OnRejectedWithResolver =
+        std::function<void(const std::error_condition& rejectReason, PromiseResolver<R> resolver)>;
+
+    /// @copydoc Promise::OnFulfilledFinally
+    using OnFulfilledFinally = std::function<void()>;
+
+    /// @copydoc Promise::OnRejectedFinally
+    using OnRejectedFinally = std::function<void(const std::error_condition& rejectReason)>;
+
+    /// @copydoc Promise::OnFulfilledWithPromise
+    template <typename R>
+    using OnFulfilledWithPromise = std::function<Promise<R>()>;
+
+    /// @copydoc Promise::OnRejectedWithPromise
+    template <typename R>
+    using OnRejectedWithPromise = std::function<Promise<R>(const std::error_condition& error)>;
+
+    /// @copydoc Promise::OnFulfilledWithValue
+    template <typename R>
+    using OnFulfilledWithValue = std::function<R()>;
+
+    /// @copydoc Promise::OnRejectedWithValue
+    template <typename R>
+    using OnRejectedWithValue = std::function<R(const std::error_condition& error)>;
+};
+
+template <typename T>
+template <typename... Args>
+ACSDK_INLINE_VISIBILITY inline std::shared_ptr<PromiseState::Value> PromiseTypeTraits<T>::emplace(Args&&... args) {
+    return std::make_shared<T>(std::forward<Args>(args)...);
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_INTERNAL_PROMISETYPETRAITS_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Promise.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Promise.h
new file mode 100644
index 00000000..647ca831
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Promise.h
@@ -0,0 +1,1279 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISE_H_
+
+#include <functional>
+#include <memory>
+#include <tuple>
+#include <type_traits>
+
+#include <AVSCommon/Utils/PlatformDefinitions.h>
+#include <AVSCommon/Utils/Threading/PromiseResolver.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseState.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+// forward declarations
+template <typename T>
+class Promise;
+
+/**
+ * @brief Base type for Promise implementation.
+ *
+ * This type implements functions that are not specific to eventual result type.
+ *
+ * @note This class has the same thread safety as std::shared_ptr<const void>.
+ *
+ * @see Promise<T>
+ *
+ * @ingroup PromiseAPI
+ */
+class PromiseCommon {
+public:
+    /**
+     * @brief Helper to aggregate results from multiple Promise objects into one.
+     *
+     * Method helps to aggregate results from multiple Promise objects into one. If all arguments are resolved, the
+     * returned promise object will get resolved, and the caller can inspect arguments to fetch values. If any of the
+     * arguments are rejected, the returned promise object will get rejected.
+     *
+     * @note If @a args is an empty list, the returned Promise is resolved. If any of the arguments are rejected before
+     *       call is made, the returned Promise object is rejected. If there are multiple arguments rejected before the
+     *       call is made, the result will be rejected with the reject reason from the first rejected argument. If all
+     *       of the arguments are fulfilled before call is made, the returned Promise object is fulfilled.
+     *
+     * @tparam Promises List of Promise objects of any value type.
+     *
+     * @param[in] args Promise objects. If any of the objects are not valid, the result will be rejected with
+     *                 std::errc::invalid_argument reject reason.
+     *
+     * @return Void promise object that gets fulfilled when all arguments get fulfilled, or gets rejected when any of
+     *         arguments get rejected.
+     */
+    template <typename... Promises>
+    ACSDK_INLINE_VISIBILITY static Promise<void> all(Promises&... args);
+
+    /**
+     * @brief Helper to get the first eventual result from multiple Promise objects.
+     *
+     * Method returns a Promise object that fulfills whenever any of the arguments get fulfilled. If all arguments get
+     * rejected, the returned object also gets rejected. The caller can inspect arguments to fetch results.
+     *
+     * @note If @a args is an empty list, the returned Promise is resolved. If all of the arguments are rejected before
+     *       call is made, the returned Promise object is rejected with a reject reason from one of the arguments. If
+     *       any of the arguments are fulfilled when before call is made, the returned Promise object is fulfilled.
+     *
+     * @tparam Promises List of Promise objects of any value type.
+     *
+     * @param[in] args Promise objects. If any of the objects are not valid, the result will be rejected with
+     *                 std::errc::invalid_argument reject reason.
+     *
+     * @return Void promise object that gets fulfilled when all arguments get fulfilled, or gets rejected when any of
+     *         arguments get rejected.
+     */
+    template <typename... Promises>
+    ACSDK_INLINE_VISIBILITY static Promise<void> any(Promises&... args);
+
+    /**
+     * @brief Helper to get resolved when any of the arguments get resolved.
+     *
+     * Method returns a Promise object that gets fulfilled or rejected whenever any of the arguments are fulfilled or
+     * rejected. The caller can inspect arguments to fetch results.
+     *
+     * @note If @a args is an empty list, the returned Promise is resolved. If any of the arguments in the list is
+     *       resolved, the returned object also gets resolved.
+     *
+     * @tparam Promises List of Promise objects of any value type.
+     *
+     * @param[in] args Promise objects. If any of the objects are not valid, the result will be rejected with
+     *                 std::errc::invalid_argument reject reason.
+     *
+     * @return Void promise object that gets fulfilled when any of the arguments are fulfilled, or gets rejected when
+     *         any of the arguments are rejected.
+     */
+    template <typename... Promises>
+    ACSDK_INLINE_VISIBILITY static Promise<void> race(Promises&... args);
+
+    /**
+     * @brief Check if Promise has a referenced shared state.
+     *
+     * Promise object is valid if it has a shared state reference.
+     *
+     * If object is not valid, any methods other than assignment operators will fail.
+     *
+     * @return True if object has a shared state, or false otherwise.
+     */
+    bool isValid() const noexcept;
+
+    /**
+     * @brief Check if Promise is resolved.
+     *
+     * Method checks if object is in rejected or fulfilled state. The method is an equivalent to checks:
+     * @code
+     * promise.isRejected() || promise.isFulfilled()
+     * promise.isValid() && !promise.isPending()
+     * @endcode
+     *
+     * @return True if promise is in rejected or fulfilled state. False if the object is in pending state or not valid.
+     */
+    bool isResolved() const noexcept;
+
+    /**
+     * @brief Check if Promise is pending.
+     *
+     * Method checks if object is neither in rejected nor in fulfilled state. The method is an equivalent to checks:
+     * @code
+     * promise.isValid() && !promise.isRejected() && !promise.isFulfilled()
+     * promise.isValid() && !promise.isResolved()
+     * @endcode
+     *
+     * @return True if promise is in pending state. False if the object is in resolved state or not valid.
+     */
+    bool isPending() const noexcept;
+
+    /**
+     * @brief Check if Promise is in rejected state.
+     *
+     * Method checks if object is in rejected state. The method is an equivalent to check:
+     * @code
+     * promise.isResolved() && !promise.isFulfilled()
+     * @endcode
+     *
+     * @return True if promise was rejected, false if the promise is in pending or fulfilled state or not valid.
+     */
+    bool isRejected() const noexcept;
+
+    /**
+     * @brief Check if Promise is in fulfilled state.
+     *
+     * Method checks if object is in rejected state. The method is an equivalent to check:
+     * @code
+     * promise.isResolved() && !promise.isRejected()
+     * @endcode
+     *
+     * @return True if promise was fulfilled, false if the promise is in pending or rejected state or not valid.
+     */
+    bool isFulfilled() const noexcept;
+
+    /**
+     * @brief Get reject reason.
+     *
+     * This method provides reject reason if the promise has been rejected.
+     *
+     * @param[out] rejectReason Resulting error code. This parameter doesn't change if the method fails.
+     *
+     * @return True if the promise is rejected, false if the promise is pending or fulfilled or not valid.
+     */
+    bool getRejectReason(std::error_condition& rejectReason) const noexcept;
+
+protected:
+    // Friend classes for internal state access.
+    friend class PromiseTestHelper;
+    friend class OnRejectedAdapter;
+    template <typename T>
+    friend class OnFulfilledAdapter;
+    template <typename T>
+    friend class PromiseResolver;
+
+    /**
+     * @{
+     * @brief Helper functions to get rejected state.
+     *
+     * This method provides singleton rejected state for use with templates.
+     *
+     * @return Rejected state with std::errc::state_not_recoverable or std::errc::invalid_argument reject reason.
+     *
+     * @note These methods do not create new state instances and instead reuse single one (for each error) for
+     *       optimization.
+     *
+     * @private
+     */
+    static std::shared_ptr<PromiseState> getStateNotRecoverableState() noexcept;
+    static std::shared_ptr<PromiseState> getInvalidArgumentState() noexcept;
+    /// @}
+
+    /**
+     * @brief Internal implementation to aggregate multiple promise objects into one.
+     *
+     * This method implements type-independent logic for PromiseCommon::all(), PromiseCommon::any(), and
+     * PromiseCommon::race() methods.
+     *
+     * See PromiseCommon::all(), PromiseCommon::any(), and PromiseCommon::any() for detailed description and expected
+     * result.
+     *
+     * @param[in] type   Type of aggregate operation.
+     * @param[in] states Promise states to aggregate.
+     *
+     * @return Promise object
+     */
+    static Promise<void> commonAggregate(
+        PromiseState::Aggregate type,
+        const std::initializer_list<std::shared_ptr<PromiseState>>& states);
+
+    /**
+     * @brief Construct object without state.
+     *
+     * Method constructs object in invalid state. The only valid operations for such object are assignments and @a
+     * std::swap() operation.
+     */
+    PromiseCommon() noexcept;
+
+    /**
+     * @brief Construct object with a given target state.
+     *
+     * @param state Target state to use.
+     */
+    PromiseCommon(std::shared_ptr<PromiseState>&& state) noexcept;
+
+    /**
+     * @brief Get fulfillment value.
+     *
+     * This method retrieves fulfillment value if the object is in fulfilled state.
+     *
+     * @return Pointer to value if object is fulfilled, or nullptr otherwise.
+     */
+    PromiseState::Value* getResultValue() const noexcept;
+
+    /**
+     * @brief Initializes object with a given initialization function.
+     *
+     * This method initiates asynchronous computation of eventual result through the call to @a initFunction in a given
+     * execution context. The method can be used only once right after object is constructed.
+     *
+     * @param[in] executor     Executor to use. If @a executor is nullptr, the constructed instance is rejected with
+     *                         @a std::errc::invalid_argument error.
+     * @param[in] initFunction Function to use. If @a initFunction is empty, the constructed instance is rejected with
+     *                         @a std::errc::invalid_argument error.
+     */
+    void commonInit(std::shared_ptr<ExecutorInterface>&& executor, PromiseState::OnFulfilled&& initFunction);
+
+    /**
+     * @brief Install value and error handlers and return new promise state.
+     *
+     * @param[in] executor    Executor to use. If this parameter is nullptr, the returned state will be rejected
+     *                        with std::errc::invalid_argument error.
+     * @param[in] onFulfilled Adapter function for Promise::then() @a onFulfilled function. If this parameter is
+     *                        empty, the returned state will be rejected with std::errc::invalid_argument error.
+     * @param[in] onRejected  Adapter function for Promise::then() @a onRejected function. If this parameter is
+     *                        empty, when this object gets rejected, the reject reason is propagated into
+     *                        destination state.
+     *
+     * @return Destination shared state for a new Promise instance.
+     */
+    std::shared_ptr<PromiseState> commonThen(
+        std::shared_ptr<ExecutorInterface>&& executor,
+        PromiseState::OnFulfilled&& onFulfilled,
+        PromiseState::OnRejected&& onRejected);
+
+    /**
+     * @brief Install an error handler and return new promise state.
+     *
+     * @param[in] executor    Executor to use. If this parameter is nullptr, the returned state will be rejected
+     *                        with std::errc::invalid_argument error.
+     * @param[in] onRejected  Adapter function for Promise::then() @a onReject function. If this parameter is
+     *                        empty, when this object gets rejected, the reject reason is propagated into
+     *                        destination state.
+     * @return Destination shared state for a new Promise instance.
+     */
+    std::shared_ptr<PromiseState> commonThenCatch(
+        std::shared_ptr<ExecutorInterface>&& executor,
+        PromiseState::OnRejected&& onRejected);
+
+    /**
+     * @brief Install handler functions.
+     *
+     * @param[in] executor    Executor to use. If this parameter is nullptr, the current object state will be rejected
+     *                        with std::errc::invalid_argument error.
+     * @param[in] onFulfilled Optional adapter function for Promise::finally() @a onFulfilled function.
+     * @param[in] onRejected  Optional adapter function for Promise::finally() @a onRejected function.
+     */
+    void commonFinally(
+        std::shared_ptr<ExecutorInterface>&& executor,
+        PromiseState::OnFulfilled&& onFulfilled,
+        PromiseState::OnRejected&& onRejected);
+
+    /**
+     * @brief Internal blocking wait.
+     *
+     * This method blocks the caller thread until object gets fulfilled or rejected. If the object is fulfilled,
+     * rejected, or invalid, the method returns immediately.
+     */
+    void wait() noexcept;
+
+    /**
+     * @brief Internal blocking wait with duration.
+     *
+     * This method blocks the caller thread until object gets fulfilled, rejected, or @a duration elapses. If the object
+     * is fulfilled, rejected, or invalid, the method returns immediately.
+     *
+     * @param duration Maximum duration to wait while object is still in pending state.
+     */
+    void waitFor(const std::chrono::steady_clock::duration& duration) noexcept;
+
+    /**
+     * @brief Internal blocking wait with time point.
+     *
+     * This method blocks the caller thread until object gets fulfilled or rejected. If the object is fulfilled,
+     * rejected, or invalid, the method returns immediately.
+     *
+     * @param timePoint Latest time point to wait while object is still in pending state.
+     */
+    void waitUntil(const std::chrono::steady_clock::time_point& timePoint) noexcept;
+
+private:
+    // Allow sub-classes to access state when performing type conversions.
+    template <typename T>
+    friend class Promise;
+    // Allow type traits to access state when performing type conversions.
+    template <typename T>
+    friend class PromiseTypeTraits;
+
+    /// Shared state.
+    std::shared_ptr<PromiseState> m_state;
+};
+
+/**
+ * @brief Eventual result object.
+ *
+ * Promise is a placeholder object of an eventual result of operation. It is intended for methods, that return a
+ * singular result (value or void) or an error, and it is an alternative to use callback interfaces.
+ *
+ * Promise can be valid or invalid. When valid, the object maintains a reference to a state object. When not valid,
+ * the reference to the state object is nullptr. Invalid object becomes valid after it is assigned a value from a valid
+ * object. Default constructed Promise objects are invalid.
+ *
+ * When valid, Promise can have one of three states: pending, fulfilled, or rejected. Promise is resolved when it is
+ * either fulfilled or rejected. The object may transition from pending into fulfilled or from pending into rejected
+ * state only once. It is also possible to construct Promise object in any of these states.
+ *
+ * When Promise is in pending state, the object doesn't have either value or error. User can query object state and
+ * install handlers to consume the result or produce a new one. These handlers will be invoked after promise gets
+ * fulfilled or rejected.
+ *
+ * Init function is required to create Promise object in pending state. This function must match one of the signatures:
+ * @code
+ * std::function(void(PromiseResolver<T>));
+ * std::function(T());
+ * std::function(Promise<T>());
+ * @endcode
+ *
+ * Init function is provided as a constructor argument and will be invoked using executor. More information is available
+ * in Promise::Promise(std::shared_ptr<ExecutorInterface>, Init&&) method description.
+ *
+ * Constructing Promise object in pending state:
+ * @code
+ * void initFunction(PromiseResolver<std::string> resolver);
+ *
+ * // Creating Promise in pending state.
+ * Promise<std::string> promise1(m_executor, initFunction);
+ *
+ * EXPECT_TRUE(promise1.isValid());
+ * EXPECT_TRUE(promise1.isPending());
+ *
+ * // Creating placeholder in invalid state.
+ * Promise<std::string> promise2;
+ * EXPECT_FALSE(promise2.isValid());
+ *
+ * // Making both promise objects valid and share the same state:
+ * promise2 = promise1;
+ * EXPECT_TRUE(promise2.isValid());
+ * EXPECT_TRUE(promise2.isPending());
+ * @endcode
+ *
+ * When Promise is fulfilled, the object contains a fulfillment value of T (unless T is void). The fulfillment value
+ * can be accessed through Promise::getValue() method or through @a onFulfilled eventual result handlers (see
+ * Promise::then() and Promise::finally()).
+ *
+ * Accessing eventual result using Promise::getValue():
+ * @code
+ * // Creating promise in fulfilled state.
+ * auto promise1 = Promise<std::string>::resolve("test");
+ * std::string value;
+ * EXPECT_TRUE(promise1.getValue(value));
+ * EXPECT_EQ("test", value);
+ * @endcode
+ *
+ * Accessing eventual result using @a onFulfilled handler with Promise::finally():
+ * @code
+ * // Creating promise in fulfilled state and installing onFulfilled handler:
+ * Promise<std::string>::resolve("test").finally(
+ *     m_executor
+ *     [](const std::string& value) {
+ *         ACSDK_INFO(LX("onFulfilled").d("value", value));
+ *     });
+ * @endcode
+ *
+ * When Promise is rejected, the object contains a reject reason (std::error_condition). This value can be accessed
+ * through PromiseCommon::getRejectReason() or through eventual result handlers.
+ *
+ * Accessing reject reason using Promise::getRejectReason():
+ * @code
+ * // Creating promise in rejected state.
+ * auto promise1 = Promise<std::string>::reject(std::errc::invalid_argument);
+ * std::error_condition rejectReason;
+ * EXPECT_TRUE(promise1.getRejectReason(rejectReason));
+ * EXPECT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+ * @endcode
+ *
+ * Accessing reject reason using @a onRejected handler with Promise::finally():
+ * @code
+ * // Creating promise in fulfilled state and installing onFulfilled handler:
+ * Promise<std::string>::reject(std::errc::invalid_argument).finally(
+ *     m_executor
+ *     nullptr, // no onFulfilledHandler
+ *     [](const std::error_condition& rejectReason) {
+ *         ACSDK_INFO(LX("onRejected").d("rejectReason", rejectReason.message()));
+ *     });
+ * @endcode
+ *
+ * Promise allows installation of fulfillment handlers (@a onFulfilled) and reject reason handlers (@a onRejected).
+ * These handlers will be executed asynchronously after Promise gets resolved.
+ *
+ * @a onFulfilled handlers get invoked once when Promise transitions from pending to fulfilled state. These handlers
+ * receive fulfillment value as a parameter (unless @a T is void). If Promise is rejected, @a onFulfilled handlers are
+ * not invoked. If handler is added to Promise in fulfilled state, it is immediately scheduled for execution. If handler
+ * is added to Promise in rejected state, it is dropped.
+ *
+ * @a onRejected handlers get invoked once when Promise transitions from pending to rejected state. These handlers
+ * receive reject reason (std::error_condition) as a parameter. If Promise is fulfilled, @a onRejected handlers are
+ * not invoked. If handler is added to Promise in rejected state, it is immediately scheduled for execution. If handler
+ * is added to Promise in fulfilled state, it is dropped.
+ *
+ * Handlers that consume result do not take additional arguments and do not produce new value. Handlers that transform
+ * the result produce a new eventual result that will get resolved depending on the handler type.
+ *
+ * @code
+ * void initFunction(PromiseResolver<std::string> resolver);
+ * void onFulfilled(const std::string& value);
+ * void onRejected(const std::error_condition& rejectReason);
+ *
+ * Promise<std::string> promise(m_executor, initFunction);
+ * // Installing eventual result consumers.
+ * promise.finally(m_executor,
+ *    onFulfilled,
+ *    onRejected);
+ * @endcode
+ *
+ * Handlers installed through Promise::then() call produce eventual result of a type @a R different from @a T. These
+ * handlers either take PromiseResolver argument, return value of @a R, or return another eventual result (Promise).
+ * Because these handlers may change the result type, the @a onFulfilled handler must always be specified.
+ *
+ * Example of handlers that use PromiseResolver:
+ * @code
+ * void onFulfilled(const std::string& value, PromiseResolver<std::size_t> resolver) {
+ *     ACSDK_INFO(LX(__func__).d("computingSize", value);
+ *     resolver.resolve(value.size());
+ * }
+ * void onRejected(const std::error_condition& rejectReason, PromiseResolver<std::size_t> resolver) {
+ *     ACSDK_INFO(LX(__func__).d("recoveringError", rejectReason.message());
+ *     resolver.resolve(0u);
+ * }
+ *
+ * Promise<std::string> promise1 = ...;
+ * // Installing eventual result consumers.
+ * auto promise2 = promise.then<std::size_t>(m_executor,
+ *     onFulfilled,
+ *     onRejected);
+ * promise2.finally(
+ *     m_executor,
+ *     [](std::size_t value) {
+ *         ACSDK_INFO(LX("result").d("computedValue", value);
+ *     });
+ * @endcode
+ *
+ * Promise::then() handlers may produce eventual result by returning a value of Promise instead of using
+ * PromiseResolver type. When returned Promise object gets resolved, the result is propagated into Promise object
+ * returned from Promise::then() call.
+ *
+ * @code
+ * Promise<std::size_t> onFulfilled(const std::string& value);
+ * Promise<std::size_t> onRejected(const std::error_condition& rejectReason);
+ *
+ * Promise<std::string> promise1 = ...;
+ * // Installing eventual result consumers.
+ * auto promise2 = promise.then<std::size_t>(m_executor,
+ *     onFulfilled,
+ *     onRejected);
+ * promise2.finally(
+ *     m_executor,
+ *     [](std::size_t value) {
+ *         ACSDK_INFO(LX("result").d("computedValue", value);
+ *     });
+ * @endcode
+ *
+ * Also, Promise::then() handlers may produce non-eventual result by returning a value of @a R. When handler returns,
+ * the value is used to fulfill Promise returned from Promise::then().
+ *
+ * @code
+ * Promise<std::size_t> onFulfilled(const std::string& value);
+ * Promise<std::size_t> onRejected(const std::error_condition& rejectReason);
+ *
+ * Promise<std::string> promise1 = ...;
+ * // Installing eventual result consumers.
+ * auto promise2 = promise.then<std::size_t>(m_executor,
+ *     onFulfilled,
+ *     onRejected);
+ * promise2.finally(
+ *     m_executor,
+ *     [](std::size_t value) {
+ *         ACSDK_INFO(LX("result").d("computedValue", value);
+ *     });
+ * @endcode
+ *
+ * For error recovery, user can use Promise::thenCatch() method. This method add only @a onRejected handler, and if the
+ * original promise gets fulfilled, the value is propagated into call result without invoking @a onRejected handler.
+ * @a onRejected handlers in this case cannot change result type, and must either provide a new value of T, or reject
+ * reason.
+ *
+ * @code
+ * Promise<std::string> promise1 = ...;
+ * promise1.thenCatch(
+ *     m_executor,
+ *     [](const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+ *         ACSDK_INFO(LX("onReject").d("recoveringError", rejectReason.message());
+ *         resolver.resolve("");
+ *     }).finally(...);
+ * @endcode
+ *
+ * When adding handlers, caller must supply execution context with std::shared_ptr<ExecutorInterface>. This executor
+ * will be used for handler invocation. When using single-threaded executor, the implementation guarantees that handlers
+ * will be invoked in the order of addition.
+ *
+ * It is possible to construct Promise object that gets resolved when one or more source Promise objects get resolved.
+ * PromiseCommon::all(), PromiseCommon::any(), and PromiseCommon::race() methods enable aggregation of multiple eventual
+ * results into one.
+ *
+ * @note This class has the same thread safety as std::shared_ptr<const void>.
+ *
+ * @ingroup PromiseAPI
+ */
+template <typename T>
+class Promise : public PromiseCommon {
+public:
+    /**
+     * @brief Promise initialization function for Promise with resolver.
+     *
+     * Promise object consumes initialization function on construction. The function takes resolver argument to resolve
+     * constructed object.
+     *
+     * The function doesn't have to provide resolution result during the call. It can store resolver for later use or
+     * pass it to another thread.
+     *
+     * If function throws an exception during execution before it resolves the result, the result will be rejected with
+     * std::errc::interrupted reject reason.
+     *
+     * @param[in] resolver Resolver to fulfill or reject the promise. This object is guaranteed to be valid and
+     *                     connected to constructed Promise object when the call is made.
+     *
+     * @see PromiseResolver
+     * @see Promise::Promise(std::shared_ptr<ExecutorInterface>, Init&&)
+     */
+    using InitWithResolver = typename PromiseTypeTraits<T>::InitWithResolver;
+
+    /**
+     * @brief Promise initialization function for Promise with eventual result.
+     *
+     * Promise object consumes initialization function on construction. The function is expected to return a valid
+     * eventual result, which will be used to resolve constructed object.
+     *
+     * If function throws an exception during execution before it resolves the result, the constructed object will be
+     * rejected with std::errc::interrupted reject reason.
+     *
+     * @see Promise::Promise(std::shared_ptr<ExecutorInterface>, Init&&)
+     */
+    using InitWithPromise = typename PromiseTypeTraits<T>::InitWithPromise;
+
+    /**
+     * @brief Promise initialization function for Promise with non-eventual result.
+     *
+     * Promise object consumes initialization function on construction. The function is expected to return a value to
+     * resolve the constructed object.
+     *
+     * If function throws an exception during execution before it resolves the result, the constructed object will be
+     * rejected with std::errc::interrupted reject reason.
+     *
+     * @see Promise::Promise(std::shared_ptr<ExecutorInterface>, Init&&)
+     */
+    using InitWithValue = typename PromiseTypeTraits<T>::InitWithValue;
+
+    /**
+     * @brief Promise onFulfilled handler with resolver for Promise::then() calls.
+     *
+     * Eventual result handler is called once the promise object is fulfilled. This function takes value and resolver
+     * arguments. Because this function is used for Promise object chaining using Promise<T>::then() method, the
+     * function must must either call one of @a resolver methods to resolve the result of Promise::then() operation, or
+     * store resolver for later resolvement in a different task.
+     *
+     * The function doesn't have to provide resolution result during the call. It can store resolver for later use or
+     * pass it to another thread.
+     *
+     * If function throws an exception during execution before it resolves the result, the result will be rejected with
+     * std::errc::interrupted reject reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() operation.
+     *
+     * @param[in] value    Fulfillment value.
+     * @param[in] resolver Resolver to fulfill or reject the promise. This object is guaranteed to be valid and
+     *                     connected to constructed Promise object when the call is made.
+     *
+     * @see PromiseResolver
+     * @see Promise::then()
+     */
+    template <typename R>
+    using OnFulfilledWithResolver = typename PromiseTypeTraits<T>::template OnFulfilledWithResolver<R>;
+
+    /**
+     * @brief Promise onRejected handler with resolver for Promise::then() and Promise::thenCatch() calls.
+     *
+     * Eventual error handler is called once the promise object is rejected. This function takes reject reason and
+     * returns new Promise instance.
+     *
+     * If function returns invalid Promise object, the resulting Promise from Promise::then() or
+     * Promise::thenCatch() call is rejected with std::errc::invalid_argument error.
+     *
+     * If function throws an exception during execution, the result will be rejected with std::errc::interrupted reject
+     * reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() or Promise::thenCatch()
+     *           operation. For Promise::thenCatch() operation @a R must be @a void.
+     *
+     * @param[in] rejectReason Promise reject reason.
+     * @param[in] resolver Resolver to fulfill or reject the promise. This object is guaranteed to be valid and
+     *                     connected to constructed Promise object when the call is made.
+     *
+     * @return New Promise object for resolving return result from Promise::then() or Promise::thenCatch() call.
+     *
+     * @see Promise::then()
+     * @see Promise::thenCatch()
+     */
+    template <typename R>
+    using OnRejectedWithResolver = typename PromiseTypeTraits<T>::template OnRejectedWithResolver<R>;
+
+    /**
+     * @brief Promise onFulfilled handler with eventual result return for Promise::then() calls.
+     *
+     * Eventual result handler is called once the promise object is fulfilled. This function takes value argument and
+     * returns new Promise instance.
+     *
+     * If function returns invalid Promise object, the resulting Promise from Promise::then() call is
+     * rejected with std::errc::invalid_argument error.
+     *
+     * If function throws an exception during execution, the result will be rejected with std::errc::interrupted reject
+     * reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() operation.
+     *
+     * @param[in] value    Fulfillment value.
+     *
+     * @return New Promise object for resolving return result from Promise::then() call.
+     *
+     * @see Promise::then()
+     */
+    template <typename R>
+    using OnFulfilledWithPromise = typename PromiseTypeTraits<T>::template OnFulfilledWithPromise<R>;
+
+    /**
+     * @brief Promise onRejected handler with resolver for Promise::then() and Promise::thenCatch() calls.
+     *
+     * Eventual error handler is called once the promise object is rejected. This function takes reject reason and
+     * returns new Promise instance.
+     *
+     * If function returns invalid Promise object, the resulting Promise from Promise::then() or Promise::thenCatch()
+     * call is rejected with std::errc::invalid_argument error.
+     *
+     * If function throws an exception during execution, the result will be rejected with std::errc::interrupted reject
+     * reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() or Promise::thenCatch()
+     *           operation. For Promise::thenCatch() operation @a R must be void.
+     *
+     * @param[in] rejectReason Promise reject reason.
+     *
+     * @return New Promise object for resolving return result from Promise::then() or Promise::thenCatch() call.
+     *
+     * @see Promise::then()
+     * @see Promise::thenCatch()
+     */
+    template <typename R>
+    using OnRejectedWithPromise = typename PromiseTypeTraits<T>::template OnRejectedWithPromise<R>;
+
+    /**
+     * @brief Promise onFulfilled handler with value return for Promise::then() calls.
+     *
+     * Eventual result handler is called once the promise object is fulfilled. This function takes value argument and
+     * returns new value to resolve Promise::then() call result.
+     *
+     * If function throws an exception during execution, the result will be rejected with std::errc::interrupted reject
+     * reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() operation.
+     *
+     * @param[in] value Fulfillment value.
+     *
+     * @return Value for resolving return result from Promise::then() call.
+     *
+     * @see Promise::then()
+     */
+    template <typename R>
+    using OnFulfilledWithValue = typename PromiseTypeTraits<T>::template OnFulfilledWithValue<R>;
+
+    /**
+     * @brief Promise onRejected handler with value return for Promise::then() and Promise::thenCatch() calls.
+     *
+     * Eventual error handler is called once the promise object is rejected. This function takes reject reason and
+     * returns new value to resolve Promise::then() or Promise::thenCatch() call result.
+     *
+     * If function throws an exception during execution, the result will be rejected with std::errc::interrupted reject
+     * reason.
+     *
+     * @tparam R Eventual result type for the result of Promise::then() or Promise::thenCatch() operation.
+     *           For Promise::thenCatch() operation @a R must be @a void
+     *
+     * @param[in] rejectReason Promise reject reason.
+     *
+     * @return Value for resolving return result from Promise::then() or Promise::thenCatch() call.
+     *
+     * @see Promise::then()
+     * @see Promise::thenCatch()
+     */
+    template <typename R>
+    using OnRejectedWithValue = typename PromiseTypeTraits<T>::template OnRejectedWithValue<R>;
+
+    /**
+     * @brief Promise onFulfilled handler for Promise::finally() calls.
+     *
+     * Eventual result handler is called once the promise object is fulfilled. This function takes value argument.
+     *
+     * If function throws an exception during execution, it is caught and ignored.
+     *
+     * @param[in] value Fulfillment value.
+     *
+     * @see Promise::finally()
+     */
+    using OnFulfilledFinally = typename PromiseTypeTraits<T>::OnFulfilledFinally;
+
+    /**
+     * @brief Promise onRejected handler for Promise::finally().
+     *
+     * Eventual error handler is called once the promise object is rejected. This function takes reject reason argument.
+     *
+     * If function throws an exception during execution, it is caught and ignored.
+     *
+     * @param[in] rejectReason Promise reject reason.
+     *
+     * @see Promise::finally()
+     */
+    using OnRejectedFinally = typename PromiseTypeTraits<T>::OnRejectedFinally;
+
+    /**
+     * @brief Construct Promise in fulfilled state.
+     *
+     * @tparam T1 Value type. This parameter enables use of std::enable_if() expression, as this method is not available
+     *            when T1 (T) is void.
+     * @param[in] value Value to carry.
+     *
+     * @return Fulfilled Promise instance.
+     * @note This method is available only if @a T is not @a void.
+     */
+    template <typename T1 = T>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<!std::is_same<T1, void>::value, Promise<T>>::type resolve(
+        T1&& value);
+
+    /**
+     * @brief Construct Promise in fulfilled state.
+     *
+     * This method constructs an instance of @a T using provided arguments and uses it for resolving the promise.
+     *
+     * @tparam Args Argument types for T construction.
+     * @param[in] args Argument values.
+     *
+     * @return Fulfilled Promise instance.
+     * @note This method is available only if @a T is not @a void.
+     */
+    template <typename... Args>
+    ACSDK_INLINE_VISIBILITY static Promise<T> resolveEmplace(Args&&... args);
+
+    /**
+     * @brief Construct Promise in fulfilled state.
+     *
+     * @tparam T1 Value type. This parameter enables use of std::enable_if() expression, as this method is available
+     *            only when T1 (T) is void.
+     *
+     * @return Fulfilled Promise instance.
+     * @note This method is available only if @a T is @a void.
+     */
+    template <typename T1 = T>
+    ACSDK_INLINE_VISIBILITY static typename std::enable_if<std::is_same<T1, void>::value, Promise<T>>::type resolve();
+
+    /**
+     * @brief Construct Promise in rejected state.
+     *
+     * @param[in] rejectReason Reject reason. If @a rejectReason has a code of zero, the returned Promise will be
+     *                         rejected with std::errc::invalid_argument reject reason.
+     * @return New Promise in rejected state.
+     */
+    ACSDK_INLINE_VISIBILITY static Promise<T> reject(const std::error_condition& rejectReason);
+
+    /**
+     * @brief Construct Promise in pending state.
+     *
+     * @return Pair of Promise and PromiseResolver.
+     * @note This method should not be used outside of core library.
+     * @private
+     */
+    ACSDK_INLINE_VISIBILITY static std::tuple<Promise<T>, PromiseResolver<T>> __makePending();
+
+    /**
+     * @brief Construct object in without target state.
+     *
+     * Method constructs a Promise with no shared state. After construction @a Promise<T>::isValid() == @a false.
+     */
+    ACSDK_INLINE_VISIBILITY Promise() noexcept;
+
+    /**
+     * @brief Copy constructor.
+     *
+     * Method constructs Promise that shares the target state with @a arg.
+     *
+     * @param[in] arg Original promise to share the target state.
+     */
+    ACSDK_INLINE_VISIBILITY Promise(const Promise<T>& arg) noexcept;
+
+    /**
+     * @brief Move constructor.
+     *
+     * Method constructs Promise that uses the target state with @a arg. If @a arg is not valid, the constructed object
+     * will not be valid. If @a arg is valid when the call is made, it the constructed object will be valid, and @a arg
+     * will become invalid.
+     *
+     * This constructor is an equivalent of the code:
+     * @code
+     * Promise<T> promise1 = ...;
+     * Promise<T> promise2;
+     * std::swap(promise1, promise2);
+     * @endcode
+     *
+     * @param[in, out] arg Original promise for moving target state.
+     */
+    ACSDK_INLINE_VISIBILITY Promise(Promise<T>&& arg) noexcept;
+
+    /**
+     * @brief Copy assignment.
+     *
+     * Method assigns target state from @a arg and then discards previously owned target state.
+     *
+     * @param[in] arg Argument to share target state.
+     * @return Reference to @a *this.
+     */
+    ACSDK_INLINE_VISIBILITY Promise<T>& operator=(const Promise<T>& arg) noexcept = default;
+
+    /**
+     * @brief Move assignment.
+     *
+     * Method moves target state from @a arg, and makes @a arg invalid.
+     *
+     * This method is an equivalent of:
+     * @code
+     * Promise<T> promise1 = ...;
+     * Promise<T> promise2 = ...;
+     * {
+     *     Promise<T> tmp(std::move(promise2));
+     *     std::swap(promise1, tmp);
+     * }
+     * @endcode
+     *
+     * @param[in, out] arg Argument to move target state.
+     * @return
+     */
+    ACSDK_INLINE_VISIBILITY Promise<T>& operator=(Promise<T>&& arg) noexcept;
+
+    /**
+     * @{
+     * @brief Get value if available.
+     *
+     * Method retrieves value if the object is in fulfilled state. This method is available only when T is not void.
+     *
+     * @param[out] value Fulfillment value on success.
+     *
+     * @return True if the operation has been resolved with a value and the result has been retrieved. False if the
+     *         promise object is in pending or rejected states. If method returns false, the @a value contents is not
+     *         modified.
+     */
+    template <typename Q = T>
+    ACSDK_INLINE_VISIBILITY typename std::enable_if<
+        !std::is_same<Q, void>::value && std::is_assignable<Q&, T>::value && !std::is_nothrow_assignable<Q&, T>::value,
+        bool>::type
+    getValue(Q& value) const;
+    template <typename Q = T>
+    ACSDK_INLINE_VISIBILITY
+        typename std::enable_if<!std::is_same<Q, void>::value && std::is_nothrow_assignable<Q&, T>::value, bool>::type
+        getValue(Q& value) const noexcept;
+    /// @}
+
+    /**
+     * @brief Constructs object with result computation function.
+     *
+     * Creates a promise object in pending state with initialization function. The @a initFunction will be called from
+     * an executor, and takes PromiseResolver<T> argument for resolving or rejecting the object.
+     *
+     * User code must eventually call PromiseResolver<T>::resolve() or PromiseResolver<T>::reject() method, but it can
+     * be done asynchronously (outside of @a initFunction scope).
+     *
+     * @tparam Init Initialization callable. The callable is expected to provide a eventual or non-eventual result for
+     *              settling the constructed Promise<T> object. Callable must be assignable to one of the following
+     *              functions:
+     * Function                                | Description
+     * --------------------------------------- | ------------------------------------------
+     * std::function<Promise<T>()>             | Callable returns eventual value.
+     * std::function<void(PromiseResolver<T>)> | Callable uses resolver for eventual result.
+     * std::function<T()>                      | Callable returns non-eventual value.
+     *
+     * @param[in] executor Executor interface for @a init execution. If executor is nullptr, promise object is
+     *                     immediately rejected with std::errc::invalid_argument error.
+     * @param[in] init     Result computation function. If function is empty, promise object is immediately rejected
+     *                     rejected with std::errc::invalid_argument error.
+     *
+     * @see InitWithPromise
+     * @see InitWithResolver
+     * @see InitWithValue
+     */
+    template <typename Init>
+    ACSDK_INLINE_VISIBILITY Promise(std::shared_ptr<ExecutorInterface> executor, Init&& init);
+
+    /**
+     * @brief Install a value result handler/transformer.
+     *
+     * Method installs a value transformer. The installed function gets this promise's result value as an input and
+     * produces new (return) value as a result for a returned promise.
+     *
+     * Example with resolver:
+     * @code
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.then<std::string>(
+     *     m_executor,
+     *     [](const std::string& value, PromiseResolver<std::string> resolver) {
+     *         resolver.resolve(value + " world");
+     *     });
+     *
+     * // The event is fired asynchronously, and if immediately check the result value, it may or may not be available.
+     * // If it is necessary to block current execution thread, use promise2.wait(timeout);
+     *
+     * std::string result;
+     * ASSERT_TRUE(promise2.getValue(result));
+     * ASSERT_EQ("hello world", result);
+     * @endcode
+     *
+     * Example with returning another eventual result:
+     * @code
+     * Promise<std::string> transformResult(const std::string& value);
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.then<std::string>(
+     *     m_executor,
+     *     [](const std::string& value) {
+     *         return transformResult(value);
+     *     });
+     * @endcode
+     *
+     * Example with non-eventual result return:
+     * @code
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.then<std::string>(
+     *     m_executor,
+     *     [](const std::string& value) {
+     *         return value + " world";
+     *     });
+     *
+     * // The event is fired asynchronously, and if immediately check the result value, it may or may not be available.
+     * // If it is necessary to block current execution thread, use promise2.wait(timeout);
+     *
+     * std::string result;
+     * ASSERT_TRUE(promise2.getValue(result));
+     * ASSERT_EQ("hello world", result);
+     * @endcode
+     *
+     * It is possible to install any number of value result handlers/transformers.
+     *
+     * @tparam R Value type for returned promise object. Handler function must either accept a PromiseResolver argument
+     *           for @a R, return value of @a R, or return an eventual result of @a R.
+     *
+     * @tparam OnFulfilled Callable for handling the eventual result value. The handler is expected to provide a new
+     *                     eventual or non-eventual result for settling the returned Promise object. Callable must be
+     *                     assignable to one (and only one) of the following functions.
+     * ___
+     * Functions for void T                    | Description
+     * --------------------------------------- | ------------------------------------------
+     * std::function<Promise<R>()>             | Handler returns eventual value.
+     * std::function<void(PromiseResolver<R>)> | Handler uses resolver for eventual result.
+     * std::function<R()>                      | Handler returns non-eventual value.
+     * ___
+     * Functions for non-void T                       | Description
+     * ---------------------------------------------- | ------------------------------------------
+     * std::function<Promise<R>(const T&)>            | Handler returns eventual value.
+     * std::function<void(const T&, PromiseResolver)> | Handler uses resolver for eventual result.
+     * std::function<R(const T&)>                     | Handler returns non-eventual value.
+     *
+     * @see OnFulfilledWithPromise
+     * @see OnFulfilledWithResolver
+     * @see OnFulfilledWithValue
+     *
+     * @tparam OnRejected Callable for handling the eventual reject reason. The handler is expected to provide a new
+     *                    eventual or non-eventual result for settling the returned Promise object. Callable must be
+     *                    assignable to one (and only one) of the following functions:
+     * Function | Description
+     * -------- | -----------
+     * std::function<Promise<R>(const std::error_condition&)> | Handler returns eventual value.
+     * std::function<void(const std::error_condition&, PromiseResolver<R>)> | Handler uses resolver for eventual result.
+     * std::function<R(const std::error_condition&)> | Handler returns non-eventual value.
+     * @see OnRejectedWithPromise
+     * @see OnRejectedWithResolver
+     * @see OnRejectedWithValue
+     *
+     * @param[in] executor    Executor interface calling @a onFulfilled or @a onRejected handler when this object gets
+     *                        resolved. If this parameter is nullptr, the returned object will be rejected with @a
+     *                        std::errc::invalid_argument error. If Executor::execute() calls fails with error, the
+     *                        error will be propagated to returned object without calling handlers.
+     * @param[in] onFulfilled Function to execute when the promise is fulfilled. If @a onFulfilled function is empty,
+     *                        the method returns rejected Promise object with @a std::errc::invalid_argument error.
+     * @param[in] onRejected  Optional function to execute when the promise is rejected. If @a onRejected function is
+     *                        empty the error is directly propagated to the returned Promise object.
+     *
+     * @return New (chained) promise object with @a R result type. If this promise is fulfilled @a onFulfilled handler
+     *         is executed and the returned promise is fulfilled. If this promise is completed with error, and @a
+     *         onRejected handler is specified, it is executed and the returned promise is updated with a new status. If
+     *         @a onRejected handler is not specified, the returned promise is also rejected.
+     *
+     * @see Promise::thenCatch()
+     */
+    template <typename R, typename OnFulfilled, typename OnRejected = OnRejectedWithResolver<R>>
+    ACSDK_INLINE_VISIBILITY Promise<R> then(
+        std::shared_ptr<ExecutorInterface> executor,
+        OnFulfilled&& onFulfilled,
+        OnRejected&& onRejected = nullptr);
+
+    /**
+     * @brief Attach an error recovery function.
+     *
+     * Error recovery function allows to generate result value of @a T when this promise object is rejected. The method
+     * returns a new promise instance, which will get the same value if this promise is fulfilled, or a value from @a
+     * onRejected handler if this promise is rejected.
+     *
+     * When this promise is rejected, it will schedule execution of @a onRejected using @a executor instance. If
+     * scheduling fails, the returned promise will be rejected with an error code from ExecutorInterface::execute()
+     * call.
+     *
+     * Example with resolver:
+     * @code
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.thenCatch(
+     *     m_executor,
+     *     [](const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+     *         resolver.resolve("Error: " + rejectReason.message());
+     *     });
+     * @endcode
+     *
+     * Example with returning another eventual result:
+     * @code
+     * Promise<std::string> transformResult(const std::error_condition& rejectReason);
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.thenCatch(
+     *     m_executor,
+     *     [](const std::error_condition& rejectReason) {
+     *         return transformResult(rejectReason);
+     *     });
+     * @endcode
+     *
+     * Example with non-eventual result return:
+     * @code
+     * Promise<std::string> promise1 = ...;
+     * Promise<std::string> promise2 = promise1.thenCatch(
+     *     m_executor,
+     *     [](const std::error_condition& rejectReason) {
+     *         return "Error: " + rejectReason.message();
+     *     });
+     * @endcode
+     *
+     * @tparam OnRejected Callable for handling the eventual reject reason. The handler is expected to provide a new
+     *                    eventual or non-eventual result for settling the returned Promise object. Callable must be
+     *                    assignable to one (and only one) of the following functions:
+     * Function                                               | Description
+     * ------------------------------------------------------ | --------------------------------------------------------
+     * std::function<Promise<T>(const std::error_condition&)> | Handler returns eventual value.
+     * std::function<void(const std::error_condition&, PromiseResolver<T>)> | Handler uses resolver for eventual result.
+     * std::function<T(const std::error_condition&)>          | Handler returns non-eventual value.
+     *
+     * @see OnRejectedWithPromise
+     * @see OnRejectedWithResolver
+     * @see OnRejectedWithValue
+     *
+     * @param[in] executor   Executor interface calling @a onRejected handler when this object gets rejected. If this
+     *                       parameter is nullptr, the returned object will be rejected with @a
+     *                       std::errc::invalid_argument error. If ExecutorInterface::execute() calls fails, the
+     *                       error will be propagated to returned object without calling @a onRejected handler.
+     * @param[in] onRejected Handler function that receives reject reason and PromiseResolver<T> to resolve new Promise
+     *                       object. If @a onRejected function is empty, the returned @c Promise<T> object will be
+     *                       rejected with @a std::errc::invalid_argument error.
+     *
+     * @return New promise instance, that will get the same value if this promise is fulfilled, or will get resolved
+     *         with PromiseResolver instance passed into @a onRejected call. If @a executor is nullptr, the returned
+     *         object will be in rejected state with @a std::errc::invalid_argument reject reason.
+     *
+     * @see Promise::then()
+     */
+    template <typename OnRejected>
+    ACSDK_INLINE_VISIBILITY Promise<T> thenCatch(std::shared_ptr<ExecutorInterface> executor, OnRejected&& onRejected);
+
+    /**
+     * @brief Attach result function.
+     *
+     * Result function allows to handle fulfillment value of @a T or an reject reason. This method returns @a *this
+     * reference and it does not create a new Promise instance.
+     *
+     * When @a this promise is fulfilled, it will schedule execution of @a onFulfilled function using @a executor if @a
+     * onFulfilled is not empty.
+     *
+     * When @a this promise is completed with an error, it will schedule execution of @a onRejected using @a executor if
+     * @a onRejected is not empty.
+     *
+     * @code
+     * Promise<std::string> promise(...);
+     * ...
+     * promise.finally(
+     *     m_executor,
+     *     [](const std::string& value) {
+     *        ACSDK_INFO(LX(__func__).d("fulfilled", value);
+     *     },
+     *     [](const std::error_condition& value) {
+     *        ACSDK_ERROR(LX(__func__).d("rejected", error.c_str());
+     *     });
+     * @endcode
+     *
+     * @param[in] executor    Executor interface calling @a onFulfilled or @a onRejected handler when this object gets
+     *                        resolved. If this parameter is nullptr, @a this object will be rejected with @a
+     *                        std::errc::invalid_argument error. If Executor::execute() call fails with error, the
+     *                        handlers will not be called.
+     * @param[in] onFulfilled Optional callable to execute when the promise is fulfilled. This callable may be empty if
+     *                        @a onRejected is not an empty function and not a @c std::nullptr_t.
+     * @param[in] onRejected  Optional function to execute when the promise is rejected. This function may be empty if
+     *                        @a onFulfilled is not an empty function and not a @c std::nullptr_t.
+     *
+     * @return Reference to @a *this. If either @a executor is nullptr, or both @a onFulfilled and @a onRejected are
+     *         either empty functions or @a std::nullptr_t, @a this object is immediately rejected with @a
+     *         std::errc::invalid_argument error.
+     */
+    template <typename OnFulfilled, typename OnRejected = OnRejectedFinally>
+    ACSDK_INLINE_VISIBILITY Promise<T>& finally(
+        std::shared_ptr<ExecutorInterface> executor,
+        OnFulfilled&& onFulfilled,
+        OnRejected&& onRejected = nullptr);
+
+    /**
+     * @brief Swap states.
+     *
+     * Method swaps target state between @a *this and @a arg objects.
+     *
+     * @param[in, out] arg Eventual result object to swap target states.
+     */
+    ACSDK_INLINE_VISIBILITY void swap(Promise<T>& arg) noexcept;
+
+    /**
+     * @brief Block calling thread until this object gets fulfilled or rejected.
+     *
+     * Method blocks caller's thread until object gets fulfilled or rejected. If the object is fulfilled, rejected, or
+     * invalid prior to the call, the method returns immediately.
+     *
+     * @note This method is intended to support migration of existing code and it is not recommended for new
+     *       applications.
+     *
+     * @code
+     * auto promise = ...;
+     *
+     * ASSERT_TRUE(promise.await().isResolved());
+     * @endcode
+     *
+     * @return Reference to @a *this.
+     */
+    ACSDK_INLINE_VISIBILITY Promise<T>& await() noexcept;
+
+    /**
+     * @brief Block calling thread until this object gets fulfilled, rejected, or timeout elapses.
+     *
+     * Method blocks caller's thread until object gets fulfilled, rejected, or timeout elapses. If the object is
+     * fulfilled, rejected, or invalid prior to the call, the method returns immediately.
+     *
+     * @note This method is intended to support migration of existing code and it is not recommended for new
+     *       applications.
+     *
+     * @return Reference to @a *this.
+     *
+     * @tparam Rep An arithmetic type representing the number of ticks.
+     * @tparam Period a std::ratio representing the tick period (i.e. the number of second's fractions per tick).
+     *
+     * @param duration Duration to wait until object gets fulfilled or rejected. The method may block for longer than
+     *                 duration value due to scheduling constraints.
+     *
+     * @return Reference to @a *this.
+     */
+    template <typename Rep, typename Period>
+    ACSDK_INLINE_VISIBILITY Promise<T>& awaitFor(const std::chrono::duration<Rep, Period>& duration) noexcept;
+
+    /**
+     * @brief Block calling thread until this object gets fulfilled, rejected, or time point is reached.
+     *
+     * Method blocks caller's thread until object gets fulfilled, rejected, or time point is reached. If the object is
+     * fulfilled, rejected, or invalid prior to the call, the method returns immediately.
+     *
+     * @note This method is intended to support migration of existing code and it is not recommended for new
+     *       applications.
+     *
+     * @tparam Clock    Clock to measure the time.
+     * @tparam Duration Duration type (std::chrono::duration).
+     *
+     * @param timePoint Time point to wait until object gets fulfilled or rejected.
+     *
+     * @return Reference to @a *this.
+     */
+    template <typename Clock, typename Duration>
+    ACSDK_INLINE_VISIBILITY Promise<T>& awaitUntil(const std::chrono::time_point<Clock, Duration>& timePoint) noexcept;
+
+protected:
+    // All Promise types can use non-public methods.
+    template <typename R>
+    friend class Promise;
+    // Parent class can use non-public methods.
+    friend class PromiseCommon;
+
+    /**
+     * @brief Constructs object with a given state.
+     *
+     * @param[in] state Target state to use.
+     */
+    ACSDK_INLINE_VISIBILITY explicit Promise(std::shared_ptr<PromiseState> state) noexcept;
+};
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+// Include implementation
+#include "Internal/PromiseImpl.h"
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/PromiseResolver.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/PromiseResolver.h
new file mode 100644
index 00000000..67915209
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/PromiseResolver.h
@@ -0,0 +1,331 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISERESOLVER_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISERESOLVER_H_
+
+#include <functional>
+#include <memory>
+
+#include <AVSCommon/Utils/PlatformDefinitions.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseState.h>
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+// forward declarations
+template <class T>
+class PromiseTypeTraits;
+template <class T>
+class PromiseResolver;
+template <class T>
+class Promise;
+
+/**
+ * @brief Base class for PromiseResolver.
+ *
+ * This class provides PromiseResolver operations that do not depend on particular type @a T.
+ *
+ * @note This class has the same thread safety as std::shared_ptr<const void>.
+ * @see PromiseResolver
+ *
+ * @ingroup PromiseAPI
+ */
+class PromiseResolverCommon {
+public:
+    /**
+     * @brief Rejects promise with an error.
+     *
+     * This method transfers attached Promise object into rejected state only if the object is in pending state. If
+     * there is no object attached, or object is resolved, the method does nothing.
+     *
+     * @param[in] error Error value to use as a rejection result and as a parameter to child error handlers. The
+     * error cannot have zero error code value.
+     *
+     * @return True if object state has been changed into error, false if the object is not in pending state prior
+     * to the call, or if @a error has a zero value.
+     */
+    bool reject(const std::error_condition& error) const noexcept;
+
+    /**
+     * @brief Test if resolver are valid.
+     *
+     * Resolver is valid, when this object is attached to a Promise object.
+     *
+     * @return True if resolver are valid, false otherwise.
+     */
+    bool isValid() const noexcept;
+
+    /**
+     * @brief Invalidate resolver.
+     *
+     * Method invalidates resolver and releases a reference to Promise object.
+     */
+    void reset() noexcept;
+
+protected:
+    friend class PromiseTestHelper;
+
+    /**
+     * @brief Constructs object without target state.
+     */
+    PromiseResolverCommon() noexcept = default;
+
+    /**
+     * @brief Constructs object with a given shared state.
+     *
+     * @param[in] state Shared state.
+     */
+    PromiseResolverCommon(std::shared_ptr<PromiseState>&& state) noexcept;
+
+    /**
+     * @brief Resolve promise with value.
+     *
+     * @param value Value to set when fulfilling Promise object.
+     *
+     * @return True if promise object gets fulfilled. False if the promise object is either not pending (resolved), or
+     *         not valid.
+     */
+    bool resolveWithValue(std::shared_ptr<PromiseState::Value>&& value) const noexcept;
+
+    /**
+     * @brief Resolve void promise.
+     *
+     * @return True if promise object gets fulfilled. False if the promise object is either not pending (resolved), or
+     *         not valid.
+     */
+    bool resolveWithVoid() const noexcept;
+
+    /**
+     * @brief Resolve with an eventual result.
+     *
+     * @param[in] state    Target state to connect to.
+     */
+    void resolveWithPromise(const std::shared_ptr<PromiseState>& state) const noexcept;
+
+    /// Target state reference. It can be nullptr.
+    std::shared_ptr<PromiseState> m_state;
+};
+
+/**
+ * @brief Type for resolving Promise objects.
+ *
+ * PromiseResolver is an interface to resolve (fulfill or reject) a Promise object. The communication between Promise
+ * and PromiseResolver is handled through a shared state object.
+ *
+ * Resolver can have two states: valid and invalid. Resolver is valid when it is associated with a Promise instance
+ * through shared state (PromiseState), and it can be used for setting Promise object.
+ *
+ * PromiseResolver is a typed frontend for operations with PromiseState. The attached PromiseState state is called
+ * target state and it may be connected to any number of Promise or PromiseResolver objects.
+ *
+ * @tparam T Value type
+ *
+ * @note This class has the same thread safety as std::shared_ptr<const void>.
+ * @see PromiseResolverCommon for type-agnostic methods.
+ * @see Promise
+ *
+ * @ingroup PromiseAPI
+ */
+template <typename T>
+class PromiseResolver : public PromiseResolverCommon {
+public:
+    /**
+     * @brief Create resolver without shared state.
+     *
+     * Method creates resolver in invalid state. This resolver cannot be used for resolving or rejecting a @a
+     * Promise object until it is assigned a value from a valid resolver object through copy or move assignment.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver() noexcept = default;
+
+    /**
+     * @brief Copy constructor.
+     *
+     * After this constructor is executed both @a arg and @a *this instances will share the same state if @a arg is
+     * valid, or both will be invalid otherwise.
+     *
+     * @param[in] arg Resolver object to share state.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver(const PromiseResolver<T>& arg) noexcept = default;
+
+    /**
+     * @brief Move constructor.
+     *
+     * This constructor transfers state ownership from @a arg to @a *this. The constructed object will be valid only
+     * if
+     * @a arg was valid before the call.
+     *
+     * @param[in] arg Source resolver object to move state ownership.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver(PromiseResolver<T>&& arg) noexcept = default;
+
+    /**
+     * @brief Constructs object with a given state.
+     *
+     * @param[in] state Target state to use or nullptr.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver(std::shared_ptr<PromiseState> state) noexcept;
+
+    /**
+     * @brief Copy assignment.
+     *
+     * Method assigns a state from @a arg, and then drops previously owned state.
+     *
+     * @param[in] arg Resolver object to share state.
+     *
+     * @return Reference to @a *this.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver<T>& operator=(const PromiseResolver<T>& arg) noexcept = default;
+
+    /**
+     * @brief Move assignment.
+     *
+     * Method move a state from @a arg, and then drops previously owned state.
+     *
+     * @param[in] arg Source resolver object to move state ownership.
+     *
+     * @return Reference to @a *this.
+     */
+    ACSDK_INLINE_VISIBILITY PromiseResolver<T>& operator=(PromiseResolver<T>&& arg) noexcept = default;
+
+    /**
+     * @brief Resolve promise with a value.
+     *
+     * This method attempts to resolve the promise with a value. The completion will be successful only if the
+     * promise is in a pending state.
+     *
+     * When promise is fulfilled, this event is propagated to all child promises. All onFulfill handlers are
+     * executed. onReject handlers are not invoked, but their promise objects get the same value as a result.
+     *
+     * @param[in] value Value to set.
+     * @return True if promise has been fulfilled by this call, false otherwise.
+     */
+    template <typename T1 = T>
+    ACSDK_INLINE_VISIBILITY typename std::enable_if<!std::is_same<T1, void>::value, bool>::type resolve(
+        T1&& value) const noexcept;
+
+    /**
+     * @brief Construct a value and resolve promise with it..
+     *
+     * This method attempts to resolve the promise with a value. The completion will be successful only if the
+     * promise is in a pending state.
+     *
+     * When promise is fulfilled, this event is propagated to all child promises. All onFulfill handlers are
+     * executed. onReject handlers are not invoked, but their promise objects get the same value as a result.
+     *
+     * @tparam Args Type of input arguments to construct instance of @a T.
+     *
+     * @param[in] args Value to set.
+     *
+     * @return True if promise has been fulfilled by this call, false otherwise.
+     */
+    template <typename... Args, typename T1 = T>
+    ACSDK_INLINE_VISIBILITY typename std::enable_if<!std::is_same<T1, void>::value, bool>::type resolveEmplace(
+        Args&&... args) const noexcept;
+
+    /**
+     * @brief Resolve void promise.
+     *
+     * This method attempts to fulfill void promise. The completion will be successful only if the promise
+     * is in a pending state.
+     *
+     * When promise is fulfilled, this event is propagated to all child promises. All fulfill handlers are executed.
+     * Reject handlers are not invoked, but their promise objects get the same value as a result.
+     *
+     * @return True if promise has been fulfilled by this call, false otherwise.
+     */
+    template <typename T1 = T>
+    ACSDK_INLINE_VISIBILITY typename std::enable_if<std::is_same<T1, void>::value, bool>::type resolve() const noexcept;
+
+    /**
+     * @brief Resolve promise with an eventual result.
+     *
+     * This method uses system executor for forwarding results.
+     *
+     * @param[in] promise Promise object to use for resolving target.
+     */
+    ACSDK_INLINE_VISIBILITY void resolve(Promise<T>& promise) const noexcept;
+
+    /**
+     * @brief Swap target state.
+     *
+     * @param[in, out] arg Resolver to swap target state.
+     */
+    ACSDK_INLINE_VISIBILITY void swap(PromiseResolver<T>& arg) noexcept;
+};
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline PromiseResolver<T>::PromiseResolver(std::shared_ptr<PromiseState> state) noexcept :
+        PromiseResolverCommon{std::move(state)} {
+}
+
+template <typename T>
+template <typename T1>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<T1, void>::value, bool>::type PromiseResolver<
+    T>::resolve(T1&& value) const noexcept {
+    return resolveWithValue(PromiseTypeTraits<T>::emplace(std::forward<T1>(value)));
+}
+
+template <typename T>
+template <typename... Args, typename T1>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<!std::is_same<T1, void>::value, bool>::type PromiseResolver<
+    T>::resolveEmplace(Args&&... args) const noexcept {
+    return resolveWithValue(PromiseTypeTraits<T>::emplace(std::forward<Args>(args)...));
+}
+
+template <typename T>
+template <typename T1>
+ACSDK_INLINE_VISIBILITY inline typename std::enable_if<std::is_same<T1, void>::value, bool>::type PromiseResolver<
+    T>::resolve() const noexcept {
+    return resolveWithVoid();
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void PromiseResolver<T>::resolve(Promise<T>& promise) const noexcept {
+    return resolveWithPromise(promise.m_state);
+}
+
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void PromiseResolver<T>::swap(PromiseResolver<T>& arg) noexcept {
+    std::swap(m_state, arg.m_state);
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+namespace std {
+
+/**
+ * @brief Swaps states of two resolver objects.
+ *
+ * @tparam T Eventual result type.
+ * @param[in, out] resolver1  First resolver for value swap with @a resolver2.
+ * @param[in, out] resolver2  Second resolver for value swap with @a resolver1.
+ */
+template <typename T>
+ACSDK_INLINE_VISIBILITY inline void swap(
+    alexaClientSDK::avsCommon::utils::threading::PromiseResolver<T>& resolver1,
+    alexaClientSDK::avsCommon::utils::threading::PromiseResolver<T>& resolver2) noexcept {
+    resolver1.swap(resolver2);
+}
+
+}  // namespace std
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_THREADING_PROMISERESOLVER_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/TaskThread.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/TaskThread.h
index 3a26dffe..8c4af0e1 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/TaskThread.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/TaskThread.h
@@ -53,9 +53,12 @@ public:
      *
      * @param jobRunner Function that should execute jobs. The function should return @c true if there's more tasks
      * to be executed.
+     * @param moniker Thread moniker to use when executing @a jobRunner. All logging messages will use provided
+     * moniker for identifying the execution owner.
+     *
      * @return @c true if it succeeds to start the new jobRunner thread; @c false if it fails.
      */
-    bool start(std::function<bool()> jobRunner);
+    bool start(std::function<bool()> jobRunner, const std::string& moniker);
 
 private:
     /**
@@ -81,9 +84,6 @@ private:
     /// Flag used to indicate that there is a new job starting.
     std::atomic_bool m_alreadyStarting;
 
-    /// The task thread moniker.
-    std::string m_moniker;
-
     /// ThreadPool to use for obtaining threads.
     std::shared_ptr<ThreadPool> m_threadPool;
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ThreadPool.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ThreadPool.h
index c6ab1f83..469298ca 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ThreadPool.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/ThreadPool.h
@@ -18,9 +18,6 @@
 
 #include <condition_variable>
 #include <list>
-#ifdef THREAD_AFFINITY
-#include <map>
-#endif
 #include <string>
 
 #include "WorkerThread.h"
@@ -57,10 +54,12 @@ public:
     /**
      * Obtain a worker thread to operate on.
      *
-     * @param optionalMoniker the moniker of the worker desired.
-     * @return the worker thread obtained.
+     * This method returns a reference to worker object. If thread pool has worker objects in the pool, it returns one
+     * of them. If thread pool is empty, a newly constructed object is returned.
+     *
+     * @return Worker thread object.
      */
-    std::unique_ptr<WorkerThread> obtainWorker(std::string optionalMoniker = "");
+    std::unique_ptr<WorkerThread> obtainWorker();
 
     /**
      * Release a worker
@@ -103,10 +102,6 @@ public:
     static std::shared_ptr<ThreadPool> getDefaultThreadPool();
 
 private:
-#ifdef THREAD_AFFINITY
-    /// Map of Worker thread monikers to worker thread iterator in the worker queue.
-    std::map<std::string, std::list<std::unique_ptr<WorkerThread>>::iterator> m_workerMap;
-#endif
     /// Queue of worker threads to vend.
     std::list<std::unique_ptr<WorkerThread>> m_workerQueue;
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/WorkerThread.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/WorkerThread.h
index 8ee992a4..3daaa3b1 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/WorkerThread.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/WorkerThread.h
@@ -57,10 +57,11 @@ public:
     void cancel();
 
     /**
-     * Return the moniker for the worker thread.
-     * @return the worker thread moniker.
+     * Return thread id.
+     *
+     * @return Thread id for the allocated thread.
      */
-    std::string getMoniker() const;
+    std::thread::id getThreadId() const;
 
 private:
     /**
@@ -68,9 +69,6 @@ private:
      */
     void runInternal();
 
-    /// The thread moniker for the worker thread.
-    const std::string m_moniker;
-
     /// Flag indicating the thread is stopping.
     std::atomic<bool> m_stop;
 
@@ -88,6 +86,9 @@ private:
 
     /// Condition variable for waking the thread.
     std::condition_variable m_workReady;
+
+    /// Platform-specific thread identifier.
+    std::thread::id m_threadId;
 };
 
 }  // namespace threading
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/MultiTimer.h b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/MultiTimer.h
index 169a80b5..84ee4a64 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/MultiTimer.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/MultiTimer.h
@@ -94,6 +94,10 @@ private:
     /// Alias for the time point used in this class.
     using TimePoint = std::chrono::time_point<std::chrono::steady_clock>;
 
+    /// Moniker for timer tasks.
+    /// Whenever timer runs a task, it guarantees that task's thread has this value set with @c ThreadMoniker.
+    const std::string m_timerMoniker;
+
     /// The condition variable used to wait for the next task.
     std::condition_variable m_waitCondition;
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/TimerDelegate.h b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/TimerDelegate.h
index 3a98f15b..5795d429 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/TimerDelegate.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/TimerDelegate.h
@@ -57,13 +57,15 @@ private:
      * @param periodType The type of period to use when making subsequent task calls.
      * @param maxCount The desired number of times to call task.
      * @param task A callable type representing a task.
+     * @param moniker Moniker value to use for a new thread.
      */
     void timerLoop(
         std::chrono::nanoseconds delay,
         std::chrono::nanoseconds period,
         PeriodType periodType,
         size_t maxCount,
-        std::function<void()> task);
+        std::function<void()> task,
+        std::string moniker);
 
     /// Cleanup logic which waits for the thread to join if possible. @c m_callMutex must be held before calling.
     void cleanupLocked();
diff --git a/AVSCommon/Utils/privateInclude/AVSCommon/Utils/Threading/private/SharedExecutor.h b/AVSCommon/Utils/privateInclude/AVSCommon/Utils/Threading/private/SharedExecutor.h
new file mode 100644
index 00000000..d9472c43
--- /dev/null
+++ b/AVSCommon/Utils/privateInclude/AVSCommon/Utils/Threading/private/SharedExecutor.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_PRIVATEINCLUDE_AVSCOMMON_UTILS_THREADING_PRIVATE_SHAREDEXECUTOR_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_PRIVATEINCLUDE_AVSCOMMON_UTILS_THREADING_PRIVATE_SHAREDEXECUTOR_H_
+
+#include <atomic>
+#include <condition_variable>
+#include <chrono>
+#include <deque>
+#include <functional>
+#include <future>
+#include <memory>
+#include <mutex>
+#include <utility>
+
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/Threading/TaskThread.h>
+#include <AVSCommon/Utils/Power/PowerResource.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Shared executor implementation.
+ *
+ * This implementation is managed by std::shared_ptr<ExecutorInterface>.
+ */
+class SharedExecutor : public virtual ExecutorInterface {
+public:
+    /**
+     * @brief Constructs an object.
+     */
+    SharedExecutor() noexcept;
+
+    /**
+     * @brief Destructs an Executor.
+     *
+     * This method awaits till all running tasks are completed, and drops all enqueued tasks that haven't started
+     * execution.
+     *
+     * @see #shutdown()
+     * @see #waitForSubmittedTasks()
+     */
+    ~SharedExecutor() noexcept;
+
+    /// @name Methods from ExecutorInterface.
+    /// @{
+    std::error_condition execute(std::function<void()>&& function) noexcept override;
+    std::error_condition execute(const std::function<void()>& function) noexcept override;
+    /// @}
+
+    /**
+     * Waits for any previously submitted tasks to complete.
+     */
+    void waitForSubmittedTasks() noexcept;
+
+    /// Clears the executor of outstanding tasks and refuses any additional tasks to be submitted.
+    void shutdown() noexcept;
+
+    /**
+     * @brief Returns whether or not the executor is shutdown.
+     *
+     * @return True if Executor::shutdown() has been called.
+     */
+    bool isShutdown() noexcept;
+
+private:
+    // Friend declaration.
+    friend class Executor;
+
+    /// Alias for queue position.
+    using QueuePosition = Executor::QueuePosition;
+
+    /// The queue type to use for holding tasks.
+    using Queue = std::deque<std::function<void()>>;
+
+    /**
+     * Executes the next job in the queue.
+     *
+     * @return @c true if there's a next job; @c false if the job queue is empty.
+     */
+    bool runNext() noexcept;
+
+    /**
+     * Checks if the job queue is empty and that no job is added in the grace period determined by @c m_timeout.
+     *
+     * @return @c true if there's at least one job left in the queue; @c false if the job queue is empty.
+     */
+    bool hasNext() noexcept;
+
+    /**
+     * Returns and removes the task at the front of the queue. If there are no tasks, this call will return an empty
+     * function.
+     *
+     * @returns A function that represents a new task. The function will be empty if the queue has no job.
+     */
+    std::function<void()> pop() noexcept;
+
+    /**
+     * @brief Schedules a function for execution.
+     *
+     * Submits a function to be executed on an Executor thread.
+     *
+     * @param[in] function Function to execute.
+     * @param[in] queuePosition Position in the queue for the new task.
+     *
+     * @return Portable error code. If successful, value is zero.
+     */
+    std::error_condition execute(std::function<void()>&& function, QueuePosition queuePosition) noexcept;
+
+    /// Moniker for executed tasks.
+    /// Whenever executor runs a task, it guarantees that task's thread has this value set with @c ThreadMoniker.
+    const std::string m_executorMoniker;
+
+    /// The queue of tasks
+    Queue m_queue;
+
+    /// Flag to indicate if the taskThread already have an executing job.
+    bool m_threadRunning;
+
+    /// A mutex to protect access to the tasks in m_queue.
+    std::mutex m_queueMutex;
+
+    /// A flag for whether or not the queue is expecting more tasks.
+    std::atomic_bool m_shutdown;
+
+    /// A @c PowerResource.
+    std::shared_ptr<power::PowerResource> m_powerResource;
+
+    /// The thread to execute tasks on. The thread must be declared last to be destructed first.
+    TaskThread m_taskThread;
+};
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_PRIVATEINCLUDE_AVSCOMMON_UTILS_THREADING_PRIVATE_SHAREDEXECUTOR_H_
diff --git a/AVSCommon/Utils/src/Executor.cpp b/AVSCommon/Utils/src/Executor.cpp
deleted file mode 100644
index ac14bfc8..00000000
--- a/AVSCommon/Utils/src/Executor.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
-#include "AVSCommon/Utils/Memory/Memory.h"
-#include "AVSCommon/Utils/Power/PowerMonitor.h"
-#include "AVSCommon/Utils/Threading/Executor.h"
-
-namespace alexaClientSDK {
-namespace avsCommon {
-namespace utils {
-namespace threading {
-
-/// An id for identifying instances.
-static std::atomic<uint64_t> g_id{0};
-
-Executor::~Executor() {
-    shutdown();
-}
-
-Executor::Executor(const std::chrono::milliseconds& delayExit) :
-        m_threadRunning{false},
-        m_timeout{delayExit},
-        m_shutdown{false},
-        m_id{g_id++} {
-    m_powerResource = power::PowerMonitor::getInstance()->createLocalPowerResource("Executor:" + std::to_string(m_id));
-}
-
-void Executor::waitForSubmittedTasks() {
-    std::unique_lock<std::mutex> lock{m_queueMutex};
-    if (m_threadRunning) {
-        // wait for thread to exit.
-        std::promise<void> flushedPromise;
-        auto flushedFuture = flushedPromise.get_future();
-        m_queue.emplace_back([&flushedPromise]() { flushedPromise.set_value(); });
-
-        lock.unlock();
-        m_delayedCondition.notify_one();
-        flushedFuture.wait();
-    }
-}
-
-std::function<void()> Executor::pop() {
-    std::lock_guard<std::mutex> lock{m_queueMutex};
-    if (!m_queue.empty()) {
-        auto task = std::move(m_queue.front());
-        m_queue.pop_front();
-        return task;
-    }
-    return std::function<void()>();
-}
-
-bool Executor::hasNext() {
-    std::unique_lock<std::mutex> lock{m_queueMutex};
-
-    m_delayedCondition.wait_for(lock, m_timeout, [this] { return !m_queue.empty() || m_shutdown; });
-    m_threadRunning = !m_queue.empty();
-    return m_threadRunning;
-}
-
-bool Executor::runNext() {
-    auto task = pop();
-    if (task) {
-        task();
-    }
-
-    if (m_powerResource) {
-        m_powerResource->release();
-    }
-
-    // It is acceptable that we enter LPM before
-    // the wait. TaskThread will still wait the intended m_timeout relative to the system
-    // not in LPM.
-
-    return hasNext();
-}
-
-void Executor::shutdown() {
-    std::unique_lock<std::mutex> lock{m_queueMutex};
-    m_queue.clear();
-    m_shutdown = true;
-    lock.unlock();
-    waitForSubmittedTasks();
-}
-
-bool Executor::isShutdown() {
-    return m_shutdown;
-}
-
-}  // namespace threading
-}  // namespace utils
-}  // namespace avsCommon
-}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
index 363ae08b..572799d3 100644
--- a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
+++ b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
@@ -13,55 +13,144 @@
  * permissions and limitations under the License.
  */
 
+#include <algorithm>
 #include <atomic>
+#include <cstring>
 #include <iomanip>
-#include <mutex>
 #include <sstream>
+
+#if defined(_WIN32) || defined(__QNX__)
+#include <mutex>
 #include <thread>
 #include <unordered_map>
+#endif
 
-#include "AVSCommon/Utils/Logger/ThreadMoniker.h"
+#include <AVSCommon/Utils/Logger/ThreadMoniker.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace utils {
 namespace logger {
 
-/// Counter to generate (small) unique thread monikers.
-static std::atomic<int> g_nextThreadMoniker(1);
+/// Space character for moniker formatting.
+static constexpr char CHAR_SPACE = ' ';
 
-ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{moniker.empty() ? generateMoniker() : moniker} {
-}
+/// Colon character for moniker prefix separation.
+static constexpr char CHAR_COLON = ':';
 
-std::string ThreadMoniker::generateMoniker() {
-    std::ostringstream stream;
-    stream << std::setw(3) << std::hex << std::right << g_nextThreadMoniker++;
-    return stream.str();
-}
+/// Size of formatted moniker in characters.
+static constexpr size_t MONIKER_SIZE_CHARS = 5u;
 
-const ThreadMoniker& ThreadMoniker::getMonikerObjectFromMap(const std::string& moniker) {
-    /// Map each thread to a moniker.
-    static std::unordered_map<std::thread::id, ThreadMoniker> threadMonikers;
-    /// Map each moniker to a thread.
-    static std::unordered_map<std::string, std::thread::id> monikerThreads;
-    /// Lock used to synchronize access to the local maps.
-    static std::mutex monikerMutex;
+#if defined(_WIN32) || defined(__QNX__)
+/// Map each thread to a moniker.
+static std::unordered_map<std::thread::id, std::string> monikerMap;
+/// Lock used to synchronize access to the local maps.
+static std::mutex monikerMutex;
 
-    std::lock_guard<std::mutex> lock{monikerMutex};
+/**
+ * Return the moniker value reference for the current thread for OS that don't support thread local variables.
+ *
+ * @return The moniker for the @c std::this_thread.
+ */
+static inline std::string getMonikerValue() noexcept {
     auto id = std::this_thread::get_id();
-    auto entry = threadMonikers.find(id);
-    if (entry == threadMonikers.end()) {
-        auto oldEntry = monikerThreads.find(moniker);
-        if (oldEntry != monikerThreads.end()) {
-            threadMonikers.erase(oldEntry->second);
-        }
-        auto& object = threadMonikers.emplace(std::make_pair(id, ThreadMoniker(moniker))).first->second;
-        monikerThreads[object.m_moniker] = id;
-        return object;
+    std::lock_guard<std::mutex> lock{monikerMutex};
+    auto entry = monikerMap.find(id);
+    if (entry == monikerMap.end()) {
+        entry = monikerMap.emplace(std::make_pair(id, ThreadMoniker::generateMoniker())).first;
     }
     return entry->second;
 }
 
+/**
+ * @brief Set the moniker value reference for the current thread for OS that doesn't support thread local variables.
+ *
+ * @param moniker Moniker value to set.
+ */
+static inline void setMonikerValue(const std::string& moniker) noexcept {
+    auto id = std::this_thread::get_id();
+    std::lock_guard<std::mutex> lock{monikerMutex};
+    auto entry = monikerMap.find(id);
+    if (entry == monikerMap.end()) {
+        monikerMap.emplace(std::make_pair(id, moniker));
+    } else {
+        entry->second = moniker;
+    }
+}
+#else
+
+/**
+ * @brief Thread-local moniker value.
+ *
+ * Thread local destructors are called before static member destructors. If client code contains any static instance,
+ * that attempts to use Logging API from destructor, and exit() call is issued, the @a threadMoniker variable is
+ * released and running threads attempt to access string data through dangling pointers.
+ *
+ * To address the issue we use a type with a trivial destructor.
+ *
+ * @note This variable is defined only for platforms, that support @a thread_local.
+ *
+ * @see [basic.start.term]/p1 from C++ spec.
+ * @private
+ */
+static thread_local struct {
+    // Number of characters in @a value. It can be between 0 and sizeof(value) - 1.
+    std::size_t len;
+    // Moniker value. This value is not null-terminated.
+    char value[16];
+} threadMoniker = {0, {0}};
+
+/**
+ * @brief Changes moniker value for the caller's thread.
+ *
+ * @param moniker Value to set.
+ */
+static inline void setMonikerValue(const std::string& moniker) noexcept {
+    auto& tm = threadMoniker;
+    tm.len = std::min(sizeof(tm.value), moniker.length());
+    std::memcpy(tm.value, moniker.data(), tm.len);
+}
+
+/**
+ * @brief Returns reference to this thread's moniker value.
+ */
+static inline std::string getMonikerValue() noexcept {
+    auto& tm = threadMoniker;
+    if (!tm.len) {
+        setMonikerValue(ThreadMoniker::generateMoniker());
+    }
+    return std::string(tm.value, tm.value + tm.len);
+}
+
+#endif
+
+std::string ThreadMoniker::generateMoniker(char prefix) noexcept {
+    /// Counter to generate (small) unique thread monikers.
+    static std::atomic<int> g_nextThreadMoniker(1);
+
+    std::stringstream ss;
+    if (prefix) {
+        ss << prefix << CHAR_COLON;
+    }
+    ss << std::hex << g_nextThreadMoniker++;
+    auto nextMoniker = ss.str();
+
+    if (nextMoniker.size() < MONIKER_SIZE_CHARS) {
+        nextMoniker.reserve(MONIKER_SIZE_CHARS);
+        nextMoniker.insert(nextMoniker.begin(), MONIKER_SIZE_CHARS - nextMoniker.size(), CHAR_SPACE);
+    }
+
+    return nextMoniker;
+}
+
+std::string ThreadMoniker::getThisThreadMoniker() noexcept {
+    return getMonikerValue();
+}
+
+void ThreadMoniker::setThisThreadMoniker(const std::string& moniker) noexcept {
+    setMonikerValue(moniker);
+}
+
 }  // namespace logger
 }  // namespace utils
 }  // namespace avsCommon
diff --git a/AVSCommon/Utils/src/MultiTimer.cpp b/AVSCommon/Utils/src/MultiTimer.cpp
index a5ba08c6..82a10666 100644
--- a/AVSCommon/Utils/src/MultiTimer.cpp
+++ b/AVSCommon/Utils/src/MultiTimer.cpp
@@ -15,9 +15,9 @@
 #include <algorithm>
 
 #include <AVSCommon/Utils/Timing/MultiTimer.h>
-
-#include "AVSCommon/Utils/Logger/Logger.h"
-#include "AVSCommon/Utils/Timing/Timer.h"
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Logger/ThreadMoniker.h>
+#include <AVSCommon/Utils/Timing/Timer.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -30,7 +30,7 @@ static const std::string TAG("MultiTimer");
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
- * @param The event string for this @c LogEntry.
+ * @param event The event string for this @c LogEntry.
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
@@ -41,7 +41,12 @@ std::shared_ptr<MultiTimer> MultiTimer::createMultiTimer() {
     return std::make_shared<MultiTimer>();
 }
 
-MultiTimer::MultiTimer() : m_isRunning{false}, m_isBeingDestroyed{false}, m_nextToken{0} {
+MultiTimer::MultiTimer() :
+        m_timerMoniker{utils::logger::ThreadMoniker::generateMoniker(utils::logger::ThreadMoniker::PREFIX_TIMER)},
+        m_isRunning{false},
+        m_isBeingDestroyed{false},
+        m_nextToken{0} {
+    ACSDK_DEBUG5(LX("init").d("moniker", m_timerMoniker));
 }
 
 MultiTimer::~MultiTimer() {
@@ -69,7 +74,7 @@ MultiTimer::Token MultiTimer::submitTask(const std::chrono::milliseconds& delay,
     // Kick-off task execution if needed.
     if (!m_isRunning) {
         m_isRunning = true;
-        m_timerThread.start(std::bind(&MultiTimer::executeTimer, this));
+        m_timerThread.start(std::bind(&MultiTimer::executeTimer, this), m_timerMoniker);
     } else {
         // Wake up timer thread if the new task is the next to expire.
         if (m_timers.begin()->second == token) {
diff --git a/AVSCommon/Utils/src/TaskThread.cpp b/AVSCommon/Utils/src/TaskThread.cpp
index af362ac9..0022bddd 100644
--- a/AVSCommon/Utils/src/TaskThread.cpp
+++ b/AVSCommon/Utils/src/TaskThread.cpp
@@ -15,9 +15,9 @@
 
 #include <chrono>
 
-#include "AVSCommon/Utils/Logger/Logger.h"
-#include "AVSCommon/Utils/Logger/ThreadMoniker.h"
-#include "AVSCommon/Utils/Threading/TaskThread.h"
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Logger/ThreadMoniker.h>
+#include <AVSCommon/Utils/Threading/TaskThread.h>
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("TaskThread");
@@ -25,7 +25,7 @@ static const std::string TAG("TaskThread");
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
- * @param The event string for this @c LogEntry.
+ * @param event The event string for this @c LogEntry.
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
@@ -62,7 +62,7 @@ TaskThread::~TaskThread() {
     }
 }
 
-bool TaskThread::start(std::function<bool()> jobRunner) {
+bool TaskThread::start(std::function<bool()> jobRunner, const std::string& moniker) {
     if (!jobRunner) {
         ACSDK_ERROR(LX("startFailed").d("reason", "invalidFunction"));
         return false;
@@ -82,11 +82,11 @@ bool TaskThread::start(std::function<bool()> jobRunner) {
         ACSDK_ERROR(LX("startFailed").d("reason", "shuttingDown"));
         return false;
     }
-    m_workerThread = m_threadPool->obtainWorker(m_moniker);
+    m_workerThread = m_threadPool->obtainWorker();
 
-    m_moniker = m_workerThread->getMoniker();
-    m_workerThread->run([this, jobRunner] {
-        TaskThread::run(jobRunner);
+    m_workerThread->run([this, jobRunner, moniker] {
+        utils::logger::ThreadMoniker::setThisThreadMoniker(moniker);
+        TaskThread::run(std::move(jobRunner));
         return false;
     });
     return true;
@@ -94,15 +94,15 @@ bool TaskThread::start(std::function<bool()> jobRunner) {
 
 void TaskThread::run(std::function<bool()> jobRunner) {
     std::lock_guard<std::mutex> guard(m_mutex);
-    ACSDK_DEBUG9(LX("startThread")
-                     .d("moniker", m_moniker)
-                     .d("duration", duration_cast<microseconds>(steady_clock::now() - m_startTime).count()));
+    ACSDK_DEBUG9(
+        LX("startThread").d("duration", duration_cast<microseconds>(steady_clock::now() - m_startTime).count()));
     // Reset stop flag and already starting flag.
     m_stop = false;
     m_alreadyStarting = false;
 
     while (!m_stop && jobRunner())
         ;
+
     m_threadPool->releaseWorker(std::move(m_workerThread));
 }
 
diff --git a/AVSCommon/Utils/src/ThreadPool.cpp b/AVSCommon/Utils/src/ThreadPool.cpp
index bb9abbf6..f10c8f10 100644
--- a/AVSCommon/Utils/src/ThreadPool.cpp
+++ b/AVSCommon/Utils/src/ThreadPool.cpp
@@ -14,10 +14,8 @@
  */
 
 #include <memory>
-#include <functional>
 
 #include "AVSCommon/Utils/Logger/Logger.h"
-#include "AVSCommon/Utils/Logger/ThreadMoniker.h"
 #include "AVSCommon/Utils/Memory/Memory.h"
 #include "AVSCommon/Utils/Threading/ThreadPool.h"
 
@@ -27,7 +25,7 @@ static const std::string TAG("ThreadPool");
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
- * @param The event string for this @c LogEntry.
+ * @param event The event string for this @c LogEntry.
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
@@ -39,8 +37,6 @@ namespace threading {
 using namespace std;
 using namespace logger;
 
-static ThreadPool SINGLETON_THREAD_POOL{};
-
 ThreadPool::ThreadPool(size_t maxThreads) :
         m_maxPoolThreads{maxThreads},
         m_created{0},
@@ -55,7 +51,7 @@ ThreadPool::~ThreadPool() {
     m_workerQueue.clear();
 }
 
-unique_ptr<WorkerThread> ThreadPool::obtainWorker(string optionalMoniker) {
+unique_ptr<WorkerThread> ThreadPool::obtainWorker() {
     std::lock_guard<mutex> lock(m_queueMutex);
     ACSDK_DEBUG9(LX("obtainWorker")
                      .d("created", m_created)
@@ -69,21 +65,9 @@ unique_ptr<WorkerThread> ThreadPool::obtainWorker(string optionalMoniker) {
         m_created++;
         ret = memory::make_unique<WorkerThread>();
     } else {
-#ifdef THREAD_AFFINITY
-        bool containsMoniker = false;
-        if (!optionalMoniker.empty()) {
-            containsMoniker = m_workerMap.count(optionalMoniker) > 0;
-        }
-        auto workerIterator = containsMoniker ? m_workerMap[optionalMoniker] : m_workerQueue.begin();
-#else
         auto workerIterator = m_workerQueue.begin();
-#endif
         ret = std::move(*workerIterator);
         m_workerQueue.erase(workerIterator);
-#ifdef THREAD_AFFINITY
-        std::string moniker = (*workerIterator)->getMoniker();
-        m_workerMap.erase(moniker);
-#endif
     }
 
     return ret;
@@ -91,7 +75,6 @@ unique_ptr<WorkerThread> ThreadPool::obtainWorker(string optionalMoniker) {
 
 void ThreadPool::releaseWorker(std::unique_ptr<WorkerThread> workerThread) {
     std::lock_guard<mutex> lock(m_queueMutex);
-
     if (m_workerQueue.size() >= m_maxPoolThreads) {
         // In order to allow this to be called from the thread being released,
         // we release the first thread in the queue when we want to stop growing.
@@ -101,10 +84,6 @@ void ThreadPool::releaseWorker(std::unique_ptr<WorkerThread> workerThread) {
         m_releasedToPool++;
     }
     m_workerQueue.push_back(std::move(workerThread));
-#ifdef THREAD_AFFINITY
-    std::string moniker = workerThread->getMoniker();
-    m_workerMap[moniker] = --m_workerQueue.end();
-#endif
 }
 
 void ThreadPool::setMaxThreads(size_t maxThreads) {
diff --git a/AVSCommon/Utils/src/Threading/Executor.cpp b/AVSCommon/Utils/src/Threading/Executor.cpp
new file mode 100644
index 00000000..9f3aa04d
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/Executor.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/Threading/private/SharedExecutor.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "ExecutorWrapper"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+Executor::Executor() noexcept : m_executor{std::make_shared<SharedExecutor>()} {
+    if (!m_executor) {
+        ACSDK_ERROR(LX("initError"));
+    }
+}
+
+Executor::~Executor() noexcept {
+    m_executor.reset();
+}
+
+bool Executor::execute(std::function<void()>&& function) noexcept {
+    return execute(std::move(function), QueuePosition::Back);
+}
+
+bool Executor::execute(std::function<void()>&& function, QueuePosition queuePosition) noexcept {
+    if (m_executor) {
+        auto error = m_executor->execute(std::move(function), queuePosition);
+        return !error;
+    }
+    return false;
+}
+
+bool Executor::execute(const std::function<void()>& function) noexcept {
+    return execute(std::function<void()>(function), QueuePosition::Back);
+}
+
+void Executor::waitForSubmittedTasks() noexcept {
+    if (m_executor) {
+        m_executor->waitForSubmittedTasks();
+    }
+}
+
+void Executor::shutdown() noexcept {
+    if (m_executor) {
+        m_executor->shutdown();
+    }
+}
+
+bool Executor::isShutdown() noexcept {
+    if (m_executor) {
+        return m_executor->isShutdown();
+    }
+    return true;
+}
+
+Executor::operator std::shared_ptr<ExecutorInterface>() const noexcept {
+    return m_executor;
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Threading/ExecutorFactory.cpp b/AVSCommon/Utils/src/Threading/ExecutorFactory.cpp
new file mode 100644
index 00000000..45eeb75e
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/ExecutorFactory.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Threading/private/SharedExecutor.h>
+#include <AVSCommon/Utils/Threading/ExecutorFactory.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "ExecutorFactory"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+std::shared_ptr<ExecutorInterface> createSingleThreadExecutor() noexcept {
+    auto res = std::make_shared<SharedExecutor>();
+    if (!res) {
+        ACSDK_ERROR(LX("createExecutorFailed"));
+    }
+    return res;
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Threading/PromiseCommon.cpp b/AVSCommon/Utils/src/Threading/PromiseCommon.cpp
new file mode 100644
index 00000000..f001fdd6
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/PromiseCommon.cpp
@@ -0,0 +1,394 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+/**
+ * @brief Macro to create a log entry for PromiseState with a function name.
+ * @param tag Module tag.
+ * @private
+ */
+#define LX_(tag) alexaClientSDK::avsCommon::utils::logger::LogEntry(tag, __func__)
+
+/**
+ * @brief Macro to create a log entry for PromiseState with a function name for PromiseCommon tag.
+ * @private
+ */
+#define LX() LX_("PromiseCommon")
+
+/**
+ * @brief Macro to create a log entry for PromiseState with a function name and id.
+ * @private
+ */
+#define LX_S() LX().d("state", m_state)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+using namespace std::placeholders;
+
+/**
+ * @brief Internal helper type for source promise handle.
+ *
+ * This type is used to log source handles.
+ * @private
+ */
+struct SourceHandle {
+    /// Handle value.
+    std::uint64_t value;
+};
+
+/**
+ * @brief Operator to log @a SourceHandle.
+ *
+ * @param[in] out    Destination stream.
+ * @param[in] handle Source handle to log.
+ *
+ * @return Output stream @a out.
+ *
+ * @note This operator is used only if logging is enabled.
+ * @private
+ */
+std::ostream& operator<<(std::ostream& out, SourceHandle handle) {
+    return out << "PromiseState(" << std::hex << handle.value << ")";
+}
+
+/**
+ * @brief Helper function to intercept exceptions inside OnFulfilled handlers.
+ *
+ * If exceptions are enabled, this method wraps PromiseState::OnFulfilled function into function with the same
+ * signature, that rejects target state with std::errc::operation_cancelled error.
+ *
+ * If exceptions are disabled, method returns @a onFulfilled as is.
+ *
+ * @param[in] onFulfilled OnFulfilled handler function.
+ * @return Handler functions that intercepts exceptions and rejects destination state if exceptions are enabled, or @a
+ *         onFulfilled otherwise.
+ */
+static PromiseState::OnFulfilled addExceptionHandlers(PromiseState::OnFulfilled&& onFulfilled) {
+#if __cpp_exceptions || defined(__EXCEPTIONS)
+    onFulfilled = [onFulfilled](
+                      const std::shared_ptr<PromiseState>& state, const std::shared_ptr<PromiseState::Value>& value) {
+        try {
+            onFulfilled(state, value);
+        } catch (const std::exception& ex) {
+            ACSDK_ERROR(LX().d("taskException", ex.what()));
+            state->reject(std::errc::operation_canceled);
+        } catch (...) {
+            ACSDK_ERROR(LX().d("taskException", "other"));
+            state->reject(std::errc::operation_canceled);
+        }
+    };
+#endif
+
+    return std::move(onFulfilled);
+}
+
+/**
+ * @brief Helper function to intercept exceptions inside OnRejected handlers.
+ *
+ * If exceptions are enabled, this method wraps PromiseState::OnRejected function into function with the same
+ * signature, that rejects target state with std::errc::operation_cancelled error.
+ *
+ * If exceptions are disabled, method returns @a onFulfilled as is.
+ *
+ * @param[in] onRejected OnRejected handler function.
+ * @return Handler functions that intercepts exceptions and rejects destination state if exceptions are enabled and
+ *         @a onRejected is not empty, or @a onRejected otherwise.
+ */
+static PromiseState::OnRejected addExceptionHandlers(PromiseState::OnRejected&& onRejected) {
+#if __cpp_exceptions || defined(__EXCEPTIONS)
+    if (onRejected) {
+        onRejected = [onRejected](
+                         const std::shared_ptr<PromiseState>& state, const std::error_condition& rejectReason) {
+            try {
+                onRejected(state, rejectReason);
+            } catch (const std::exception& ex) {
+                state->reject(std::errc::operation_canceled);
+                ACSDK_ERROR(LX().d("taskException", ex.what()));
+            } catch (...) {
+                state->reject(std::errc::operation_canceled);
+                ACSDK_ERROR(LX().d("taskException", "other"));
+            }
+        };
+    }
+#endif
+
+    return std::move(onRejected);
+}
+
+std::shared_ptr<PromiseState> PromiseCommon::getStateNotRecoverableState() noexcept {
+    /**
+     * @brief Static reference of state.
+     *
+     * This instance is initialized by default and allows use of Promise instances in global objects and functions.
+     * @private
+     */
+    static const std::shared_ptr<PromiseState> rejectedState =
+        std::make_shared<PromiseState>(std::errc::state_not_recoverable);
+
+    return rejectedState;
+}
+
+std::shared_ptr<PromiseState> PromiseCommon::getInvalidArgumentState() noexcept {
+    /**
+     * @brief Static reference of state.
+     *
+     * This instance is initialized by default and allows use of Promise instances in global objects and functions.
+     * @private
+     */
+    static const std::shared_ptr<PromiseState> rejectedState =
+        std::make_shared<PromiseState>(std::errc::invalid_argument);
+
+    return rejectedState;
+}
+
+Promise<void> PromiseCommon::commonAggregate(
+    PromiseState::Aggregate type,
+    const std::initializer_list<std::shared_ptr<PromiseState>>& states) {
+    if (!states.size()) {
+        return Promise<void>::resolve();
+    }
+    auto it = std::find(states.begin(), states.end(), nullptr);
+    if (it != states.end()) {
+        ACSDK_ERROR(LX().d("invalidPromiseObjectIndex", it - states.begin()));
+        return Promise<void>(PromiseCommon::getInvalidArgumentState());
+    }
+
+    auto resultState = std::make_shared<PromiseState>();
+    Promise<void> result{resultState};
+    std::shared_ptr<std::size_t> counter;
+    switch (type) {
+        case PromiseState::Aggregate::ALL:  // fall through
+        case PromiseState::Aggregate::ANY:
+            counter = std::make_shared<std::size_t>(states.size());
+            break;
+        case PromiseState::Aggregate::RACE:
+            break;
+        default:
+            ACSDK_ERROR(LX().d("invalidAggregate", type));
+            return Promise<void>(PromiseCommon::getInvalidArgumentState());
+    }
+
+    for (auto& state : states) {
+        state->addResultConsumer(resultState, type, counter);
+    }
+
+    return result;
+}
+
+bool PromiseCommon::isValid() const noexcept {
+    return m_state.operator bool();
+}
+
+bool PromiseCommon::isResolved() const noexcept {
+    return m_state && m_state->isResolved();
+}
+
+bool PromiseCommon::isPending() const noexcept {
+    return m_state && m_state->isPending();
+}
+
+bool PromiseCommon::isRejected() const noexcept {
+    return m_state && m_state->isRejected();
+}
+
+bool PromiseCommon::isFulfilled() const noexcept {
+    return m_state && m_state->isFulfilled();
+}
+
+bool PromiseCommon::getRejectReason(std::error_condition& rejectReason) const noexcept {
+    if (m_state) {
+        return m_state->getRejectReason(rejectReason);
+    }
+    return false;
+}
+
+PromiseCommon::PromiseCommon() noexcept {
+    // Object constructed in detached state.
+}
+
+PromiseCommon::PromiseCommon(std::shared_ptr<PromiseState>&& state) noexcept : m_state(std::move(state)) {
+}
+
+PromiseState::Value* PromiseCommon::getResultValue() const noexcept {
+    if (m_state) {
+        std::shared_ptr<PromiseState::Value> value;
+        if (m_state->getValue(value)) {
+            return value.get();
+        }
+    }
+    return nullptr;
+}
+
+void PromiseCommon::commonInit(
+    std::shared_ptr<ExecutorInterface>&& executor,
+    PromiseState::OnFulfilled&& initFunction) {
+    if (!executor || !initFunction) {
+        ACSDK_ERROR(LX_S().m("invalidArgument"));
+        m_state = PromiseCommon::getInvalidArgumentState();
+        return;
+    }
+    m_state = std::make_shared<PromiseState>();
+
+    initFunction = addExceptionHandlers(std::move(initFunction));
+
+    /**
+     * Internal context for lambda execution.
+     *
+     * This type is a workaround to move values into executor context as C++11 does not support move captures.
+     * @private
+     */
+    struct InitContext {
+        /**
+         * Construct instance.
+         *
+         * @param state Destination promise state.
+         * @param init Initialization function adapter.
+         */
+        InitContext(std::shared_ptr<PromiseState> state, PromiseState::OnFulfilled&& init) noexcept :
+                state{std::move(state)},
+                init{std::move(init)} {
+        }
+
+        /**
+         * @brief Execute init function.
+         */
+        void execute() {
+            init(state, nullptr);
+        }
+
+        /// Shared state reference.
+        const std::shared_ptr<PromiseState> state;
+
+        /// User-supplied function to execute.
+        const PromiseState::OnFulfilled init;
+    };
+
+    auto executorError =
+        executor->execute(std::bind(&InitContext::execute, InitContext(m_state, std::move(initFunction))));
+    if (executorError) {
+        ACSDK_ERROR(LX_S().d("executorError", executorError.message()));
+        m_state->reject(executorError);
+    }
+}
+
+std::shared_ptr<PromiseState> PromiseCommon::commonThen(
+    std::shared_ptr<ExecutorInterface>&& executor,
+    PromiseState::OnFulfilled&& onFulfilled,
+    PromiseState::OnRejected&& onRejected) {
+    if (!executor) {
+        ACSDK_ERROR(LX_S().d("reason", "executorNull"));
+        return getInvalidArgumentState();
+    }
+    if (!onFulfilled) {
+        ACSDK_ERROR(LX_S().d("reason", "onFulfilledEmpty"));
+        return getInvalidArgumentState();
+    }
+    if (!m_state) {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+        return getInvalidArgumentState();
+    }
+
+    onFulfilled = addExceptionHandlers(std::move(onFulfilled));
+    onRejected = addExceptionHandlers(std::move(onRejected));
+
+    auto resultState = std::make_shared<PromiseState>();
+    m_state->addResultConsumer(resultState, std::move(executor), std::move(onFulfilled), std::move(onRejected));
+
+    return resultState;
+}
+
+std::shared_ptr<PromiseState> PromiseCommon::commonThenCatch(
+    std::shared_ptr<ExecutorInterface>&& executor,
+    PromiseState::OnRejected&& onRejected) {
+    if (!m_state) {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+        return getStateNotRecoverableState();
+    }
+    if (!executor) {
+        ACSDK_ERROR(LX_S().d("reason", "executorNull"));
+        return getInvalidArgumentState();
+    }
+    if (!onRejected) {
+        ACSDK_ERROR(LX_S().d("reason", "onRejectedEmpty"));
+        return getInvalidArgumentState();
+    }
+
+    auto resultState = std::make_shared<PromiseState>();
+    m_state->addResultConsumer(
+        resultState,
+        std::move(executor),
+        nullptr,  // OnFulfilled
+        std::move(onRejected));
+
+    return resultState;
+}
+
+void PromiseCommon::commonFinally(
+    std::shared_ptr<ExecutorInterface>&& executor,
+    PromiseState::OnFulfilled&& onFulfilled,
+    PromiseState::OnRejected&& onRejected) {
+    if (!m_state) {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+        return;
+    }
+    if (!executor) {
+        ACSDK_ERROR(LX_S().d("reason", "executorNull"));
+        m_state->reject(std::errc::invalid_argument);
+        return;
+    }
+    if (!onFulfilled && !onRejected) {
+        ACSDK_ERROR(LX_S().d("reason", "onFulfilledAndOnRejectedEmpty"));
+        m_state->reject(std::errc::invalid_argument);
+        return;
+    }
+
+    m_state->addResultConsumer(nullptr, std::move(executor), std::move(onFulfilled), std::move(onRejected));
+}
+
+void PromiseCommon::wait() noexcept {
+    if (m_state) {
+        m_state->wait();
+    } else {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+    }
+}
+
+void PromiseCommon::waitFor(const std::chrono::steady_clock::duration& duration) noexcept {
+    if (m_state) {
+        m_state->waitFor(duration);
+    } else {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+    }
+}
+
+void PromiseCommon::waitUntil(const std::chrono::steady_clock::time_point& timePoint) noexcept {
+    if (m_state) {
+        m_state->waitUntil(timePoint);
+    } else {
+        ACSDK_ERROR(LX_S().d("reason", "noState"));
+    }
+}
+
+}  //  namespace threading
+}  //  namespace utils
+}  //  namespace avsCommon
+}  //  namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Threading/PromiseResolverCommon.cpp b/AVSCommon/Utils/src/Threading/PromiseResolverCommon.cpp
new file mode 100644
index 00000000..7c23ac96
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/PromiseResolverCommon.cpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Threading/PromiseResolver.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+PromiseResolverCommon::PromiseResolverCommon(std::shared_ptr<PromiseState>&& state) noexcept :
+        m_state(std::move(state)) {
+}
+
+bool PromiseResolverCommon::isValid() const noexcept {
+    return m_state.operator bool();
+}
+
+void PromiseResolverCommon::reset() noexcept {
+    m_state.reset();
+}
+
+bool PromiseResolverCommon::reject(const std::error_condition& error) const noexcept {
+    return m_state && m_state->reject(error);
+}
+
+bool PromiseResolverCommon::resolveWithValue(std::shared_ptr<PromiseState::Value>&& value) const noexcept {
+    return m_state && m_state->resolve(std::move(value));
+}
+
+bool PromiseResolverCommon::resolveWithVoid() const noexcept {
+    return m_state && m_state->fulfillWithVoid();
+}
+
+void PromiseResolverCommon::resolveWithPromise(const std::shared_ptr<PromiseState>& state) const noexcept {
+    if (!state) {
+        reject(std::errc::invalid_argument);
+        return;
+    }
+
+    state->addResultConsumer(m_state, nullptr, nullptr, nullptr);
+}
+
+}  //  namespace threading
+}  //  namespace utils
+}  //  namespace avsCommon
+}  //  namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Threading/PromiseState.cpp b/AVSCommon/Utils/src/Threading/PromiseState.cpp
new file mode 100644
index 00000000..fd6e9d16
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/PromiseState.cpp
@@ -0,0 +1,529 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <atomic>
+#include <cstdint>
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Threading/ExecutorFactory.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseState.h>
+
+/**
+ * @brief Macro to create a log entry for PromiseState with a function name.
+ * @private
+ */
+#define LX() alexaClientSDK::avsCommon::utils::logger::LogEntry("PromiseState", __func__)
+
+/**
+ * @brief Macro to create a log entry for PromiseState with a function name and id.
+ * @private
+ */
+#define LX_P() LX().d("id", m_handle)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+PromiseState::ResultConsumer::ResultConsumer(
+    std::shared_ptr<PromiseState>&& dependentState,
+    std::shared_ptr<ExecutorInterface>&& executor,
+    OnFulfilled&& onFulfilled,
+    OnRejected&& onRejected) noexcept :
+        m_type{Aggregate::NONE},
+        m_dependentState{std::move(dependentState)},
+        m_executor{std::move(executor)},
+        m_onFulfilled{std::move(onFulfilled)},
+        m_onRejected{std::move(onRejected)} {
+}
+
+PromiseState::ResultConsumer::ResultConsumer(
+    std::shared_ptr<PromiseState>&& dependentState,
+    Aggregate type,
+    std::shared_ptr<std::size_t>&& count) noexcept :
+        m_type{type},
+        m_dependentState{std::move(dependentState)},
+        m_aggregateCounter{std::move(count)} {
+}
+
+void PromiseState::ResultConsumer::attachValueLocked(const std::shared_ptr<PromiseState::Value>& value) noexcept {
+    m_value = value;
+}
+
+void PromiseState::ResultConsumer::attachRejectReasonLocked(const std::error_condition& rejectReason) noexcept {
+    m_rejectReason = rejectReason;
+}
+
+void PromiseState::ResultConsumer::propagateValueLocked(ResultConsumerList& consumersBacklog) noexcept {
+    if (m_dependentState && State::PENDING == m_dependentState->m_state) {
+        m_dependentState->m_state = State::FULFILLED;
+        for (auto& consumer2 : m_dependentState->m_resultConsumers) {
+            consumer2.m_value = m_value;
+        }
+        consumersBacklog.splice(consumersBacklog.end(), m_dependentState->m_resultConsumers);
+        // Destroy consumer list and construct fulfillment value in its memory area instead.
+        m_dependentState->m_resultConsumers.~ResultConsumerList();
+        new (&m_dependentState->m_value) std::shared_ptr<Value>(m_value);
+    }
+}
+
+void PromiseState::ResultConsumer::propagateRejectReasonLocked(ResultConsumerList& consumersBacklog) noexcept {
+    if (m_dependentState && State::PENDING == m_dependentState->m_state) {
+        m_dependentState->m_state = State::REJECTED;
+        for (auto& consumer2 : m_dependentState->m_resultConsumers) {
+            consumer2.m_rejectReason = m_rejectReason;
+        }
+        consumersBacklog.splice(consumersBacklog.end(), m_dependentState->m_resultConsumers);
+        // Destroy consumer list and construct reject reason in its memory area instead.
+        m_dependentState->m_resultConsumers.~ResultConsumerList();
+        new (&m_dependentState->m_rejectReason) std::error_condition(m_rejectReason);
+    }
+}
+
+void PromiseState::ResultConsumer::notifyLocked(std::uint64_t handle, std::list<ResultConsumer>& consumersBacklog) {
+    ACSDK_DEBUG9(LX().d("id", handle).d("aggregateType", m_type));
+    switch (m_type) {
+        case Aggregate::NONE:
+            notifyOnNonAggregateLocked(consumersBacklog);
+            break;
+        case Aggregate::ALL:
+            notifyOnAllAggregateLocked(consumersBacklog);
+            break;
+        case Aggregate::ANY:
+            notifyOnAnyAggregateLocked(consumersBacklog);
+            break;
+        case Aggregate::RACE:
+            notifyOnRaceAggregateLocked(consumersBacklog);
+            break;
+        default:
+            ACSDK_ERROR(LX().d("id", handle).m("aggregateStateEntryError"));
+            break;
+    }
+}
+
+void PromiseState::ResultConsumer::notifyOnAnyAggregateLocked(ResultConsumerList& consumersBacklog) noexcept {
+    if (m_rejectReason) {
+        if (!--*m_aggregateCounter) {
+            m_rejectReason = std::errc::operation_canceled;
+            propagateRejectReasonLocked(consumersBacklog);
+        }
+    } else {
+        m_value = getVoidValue();
+        propagateValueLocked(consumersBacklog);
+    }
+}
+
+void PromiseState::ResultConsumer::notifyOnNonAggregateLocked(ResultConsumerList& consumersBacklog) noexcept {
+    std::error_condition directRejectReason;
+
+    if (m_rejectReason) {
+        m_onFulfilled = nullptr;
+        if (m_executor && m_onRejected) {
+            auto executorError = m_executor->execute(
+                std::bind(&OnRejected::operator(), std::move(m_onRejected), m_dependentState, m_rejectReason));
+            if (executorError) {
+                directRejectReason = executorError;
+            }
+        } else {
+            directRejectReason = m_rejectReason;
+        }
+    } else {
+        m_onRejected = nullptr;
+        if (m_executor && m_onFulfilled) {
+            auto executorError = m_executor->execute(
+                std::bind(&OnFulfilled::operator(), std::move(m_onFulfilled), m_dependentState, m_value));
+            if (executorError) {
+                directRejectReason = executorError;
+            }
+        } else {
+            propagateValueLocked(consumersBacklog);
+            return;
+        }
+    }
+
+    if (directRejectReason) {
+        m_rejectReason = directRejectReason;
+        propagateRejectReasonLocked(consumersBacklog);
+    }
+}
+
+void PromiseState::ResultConsumer::notifyOnAllAggregateLocked(ResultConsumerList& consumersBacklog) noexcept {
+    if (m_rejectReason) {
+        propagateRejectReasonLocked(consumersBacklog);
+    } else if (!--*m_aggregateCounter) {
+        m_value = getVoidValue();
+        propagateValueLocked(consumersBacklog);
+    }
+}
+
+void PromiseState::ResultConsumer::notifyOnRaceAggregateLocked(ResultConsumerList& consumersBacklog) noexcept {
+    if (m_rejectReason) {
+        propagateRejectReasonLocked(consumersBacklog);
+    } else {
+        m_value = getVoidValue();
+        propagateValueLocked(consumersBacklog);
+    }
+}
+
+std::shared_ptr<PromiseState::Value> PromiseState::getVoidValue() noexcept {
+    /**
+     * @brief Moniker value for handling void type.
+     * @private
+     */
+    static const auto voidMoniker = 1;
+
+    static const std::shared_ptr<Value> voidValue(reinterpret_cast<Value*>(&voidMoniker), [](Value*) {});
+    return voidValue;
+}
+
+std::shared_ptr<ExecutorInterface> PromiseState::getSystemExecutor() noexcept {
+    static std::mutex mutex;
+    // TODO we need multi-threaded executor here.
+    static const std::shared_ptr<ExecutorInterface> executor = createSingleThreadExecutor();
+
+    std::lock_guard<std::mutex> lock{mutex};
+    return executor;
+}
+
+std::mutex& PromiseState::getGlobalMutex() noexcept {
+    static std::mutex mutex;
+    return mutex;
+}
+
+void PromiseState::executeInSystemExecutor(std::function<void()>&& task) noexcept {
+    auto error = getSystemExecutor()->execute(std::move(task));
+    if (error) {
+        ACSDK_CRITICAL(LX().d("systemExecutorError", error.message()));
+    }
+}
+
+PromiseState::PromiseState() noexcept : m_handle(getNextHandleValue()), m_state{State::PENDING} {
+    new (&m_resultConsumers) ResultConsumerList();
+}
+
+PromiseState::PromiseState(std::shared_ptr<Value> value) noexcept :
+        m_handle(getNextHandleValue()),
+        m_state{State::FULFILLED} {
+    if (value) {
+        new (&m_value) std::shared_ptr<Value>{std::move(value)};
+    } else {
+        ACSDK_ERROR(LX_P().m("invalidValueReference"));
+        m_state = State::REJECTED;
+        new (&m_rejectReason) std::error_condition(std::errc::invalid_argument);
+    }
+}
+
+PromiseState::PromiseState(const std::error_condition& rejectReason) noexcept :
+        m_handle(getNextHandleValue()),
+        m_state{State::REJECTED} {
+    if (rejectReason) {
+        new (&m_rejectReason) std::error_condition(rejectReason);
+    } else {
+        ACSDK_ERROR(LX_P().m("invalidRejectReason"));
+        new (&m_rejectReason) std::error_condition(std::errc::invalid_argument);
+    }
+}
+
+PromiseState::~PromiseState() noexcept {
+    switch (m_state) {
+        case State::PENDING:
+            ACSDK_ERROR(LX_P().m("promiseNotResolvedBeforeRelease"));
+            reject(std::errc::broken_pipe);
+            // Fall through
+        case State::REJECTED:
+            m_rejectReason.~error_condition();
+            break;
+        case State::FULFILLED:
+            m_value.~shared_ptr<Value>();
+            break;
+        default:
+            ACSDK_CRITICAL(LX_P().m("stateError"));
+    }
+}
+
+bool PromiseState::reject(const std::error_condition& rejectReason) noexcept {
+    bool rejected;
+    {
+        std::unique_lock<std::mutex> lock{getGlobalMutex()};
+        if (State::PENDING == m_state) {
+            auto resultConsumers = std::move(m_resultConsumers);
+            m_resultConsumers.~ResultConsumerList();
+            m_state = State::REJECTED;
+            if (rejectReason) {
+                new (&m_rejectReason) std::error_condition(rejectReason);
+            } else {
+                ACSDK_ERROR(LX_P().m("invalidRejectReason"));
+                new (&m_rejectReason) std::error_condition(std::errc::invalid_argument);
+            }
+            rejected = true;
+            // Propagate result state to all linked error states.
+            notifyResultConsumersLocked(std::move(resultConsumers));
+        } else {
+            rejected = false;
+        }
+    }
+    if (rejected) {
+        // Unblock any threads in wait state.
+        m_cond.notify_all();
+    }
+    return rejected;
+}
+
+bool PromiseState::getRejectReason(std::error_condition& rejectReason) noexcept {
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    if (State::REJECTED == m_state) {
+        rejectReason = m_rejectReason;
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool PromiseState::resolve(std::shared_ptr<Value>&& value) noexcept {
+    return fulfill(value, true);
+}
+
+bool PromiseState::resolveCopy(const std::shared_ptr<Value>& value) noexcept {
+    return fulfill(const_cast<std::shared_ptr<Value>&>(value), false);
+}
+
+bool PromiseState::isResolved() const noexcept {
+    return !isPending();
+}
+
+bool PromiseState::isPending() const noexcept {
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    return (State::PENDING == m_state);
+}
+
+bool PromiseState::isRejected() const noexcept {
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    return (State::REJECTED == m_state);
+}
+
+bool PromiseState::isFulfilled() const noexcept {
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    return (State::FULFILLED == m_state);
+}
+
+bool PromiseState::fulfill(std::shared_ptr<Value>& value, bool move) noexcept {
+    bool resolved;
+    {
+        std::unique_lock<std::mutex> lock{getGlobalMutex()};
+        if (State::PENDING == m_state) {
+            auto resultConsumers = std::move(m_resultConsumers);
+            m_resultConsumers.~ResultConsumerList();
+            if (value) {
+                m_state = State::FULFILLED;
+                if (move) {
+                    new (&m_value) std::shared_ptr<Value>(std::move(value));
+                } else {
+                    new (&m_value) std::shared_ptr<Value>(value);
+                }
+            } else {
+                ACSDK_ERROR(LX_P().m("nullValue"));
+                m_state = State::REJECTED;
+                new (&m_rejectReason) std::error_condition(std::errc::invalid_argument);
+            }
+            resolved = true;
+            notifyResultConsumersLocked(std::move(resultConsumers));
+        } else {
+            resolved = false;
+        }
+    }
+    if (resolved) {
+        // Unblock any threads in wait state.
+        m_cond.notify_all();
+    }
+    return resolved;
+}
+
+bool PromiseState::fulfillWithVoid() noexcept {
+    auto voidValue = getVoidValue();
+    return fulfill(voidValue, true);
+}
+
+bool PromiseState::getValue(std::shared_ptr<Value>& data) const noexcept {
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    if (State::FULFILLED == m_state) {
+        data = m_value;
+        return true;
+    } else {
+        return false;
+    }
+}
+
+void PromiseState::addResultConsumer(
+    std::shared_ptr<PromiseState> dependentState,
+    std::shared_ptr<ExecutorInterface> executor,
+    OnFulfilled&& onFulfilled,
+    OnRejected&& onRejected) {
+    if (!dependentState && !executor) {
+        ACSDK_ERROR(LX_P().m("nullTargetStateAndNullExecutor"));
+        return;
+    }
+    if (!executor && (onFulfilled || onRejected)) {
+        ACSDK_ERROR(LX_P().m("executorNullAndOnFulfilledOnRejectedNotEmpty"));
+        return;
+    }
+    if (executor && (!onFulfilled && !onRejected)) {
+        executor.reset();
+    }
+
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    if (State::PENDING == m_state) {
+        m_resultConsumers.emplace_back(
+            std::move(dependentState), std::move(executor), std::move(onFulfilled), std::move(onRejected));
+    } else {
+        ResultConsumerList consumers;
+        consumers.emplace_back(
+            std::move(dependentState), std::move(executor), std::move(onFulfilled), std::move(onRejected));
+        notifyResultConsumersLocked(std::move(consumers));
+    }
+}
+
+void PromiseState::addResultConsumer(
+    std::shared_ptr<PromiseState> dependentState,
+    Aggregate type,
+    std::shared_ptr<std::size_t> count) {
+    if (!dependentState) {
+        ACSDK_ERROR(LX_P().m("nullTargetState"));
+        return;
+    }
+
+    std::unique_lock<std::mutex> lock{getGlobalMutex()};
+    if (State::PENDING == m_state) {
+        m_resultConsumers.emplace_back(std::move(dependentState), type, std::move(count));
+    } else {
+        ResultConsumerList consumers;
+        consumers.emplace_back(std::move(dependentState), type, std::move(count));
+        notifyResultConsumersLocked(std::move(consumers));
+    }
+}
+
+void PromiseState::wait() noexcept {
+    std::unique_lock<std::mutex> lock(getGlobalMutex());
+    m_cond.wait(lock, [this]() { return m_state != State::PENDING; });
+}
+
+bool PromiseState::waitFor(const std::chrono::steady_clock::duration& duration) noexcept {
+    std::unique_lock<std::mutex> lock(getGlobalMutex());
+    return m_cond.wait_for(lock, duration, [this]() { return m_state != State::PENDING; });
+}
+
+bool PromiseState::waitUntil(const std::chrono::steady_clock::time_point& timePoint) noexcept {
+    std::unique_lock<std::mutex> lock(getGlobalMutex());
+    return m_cond.wait_until(lock, timePoint, [this]() { return m_state != State::PENDING; });
+}
+
+std::uint64_t PromiseState::getHandle() const noexcept {
+    return m_handle;
+}
+
+std::uint64_t PromiseState::getNextHandleValue() noexcept {
+    static std::atomic<std::uint64_t> handleCounter;
+    auto result = ++handleCounter;
+    if (!result) {
+        // Never return 0.
+        result = ++handleCounter;
+    }
+    return result;
+}
+
+void PromiseState::notifyResultConsumersLocked(ResultConsumerList&& consumers) noexcept {
+    // Backlog of consumers to invoke in FIFO order (BFS).
+    // This list will grow when traversing a graph of dependent states to update.
+    auto consumersBacklog = std::move(consumers);
+
+    switch (m_state) {
+        case State::FULFILLED:
+            std::for_each(
+                consumersBacklog.begin(),
+                consumersBacklog.end(),
+                std::bind(&ResultConsumer::attachValueLocked, std::placeholders::_1, m_value));
+
+            break;
+        case State::REJECTED:
+            std::for_each(
+                consumersBacklog.begin(),
+                consumersBacklog.end(),
+                std::bind(&ResultConsumer::attachRejectReasonLocked, std::placeholders::_1, m_rejectReason));
+            break;
+        default:
+            ACSDK_CRITICAL(LX_P().m("stateError"));
+            std::error_condition rejectReason{std::errc::state_not_recoverable};
+            std::for_each(
+                consumersBacklog.begin(),
+                consumersBacklog.end(),
+                std::bind(&ResultConsumer::attachRejectReasonLocked, std::placeholders::_1, rejectReason));
+            break;
+    }
+
+    while (!consumersBacklog.empty()) {
+        auto consumer = std::move(consumersBacklog.front());
+        consumersBacklog.pop_front();
+
+        consumer.notifyLocked(m_handle, consumersBacklog);
+    }
+}
+
+std::ostream& operator<<(std::ostream& out, const PromiseState& state) {
+    const char* stateStr;
+    if (state.isPending()) {
+        stateStr = "pending";
+    } else if (state.isFulfilled()) {
+        stateStr = "fulfilled";
+    } else if (state.isRejected()) {
+        stateStr = "rejected";
+    } else {
+        stateStr = "unknown";
+    }
+
+    return out << "PromiseState(" << std::hex << state.getHandle() << "/" << stateStr << ")";
+}
+
+std::ostream& operator<<(std::ostream& out, const std::shared_ptr<PromiseState>& state) {
+    if (state) {
+        return out << *state;
+    } else {
+        return out << "PromiseState(nullptr)";
+    }
+}
+
+std::ostream& operator<<(std::ostream& out, PromiseState::Aggregate type) {
+    const char* str = nullptr;
+    switch (type) {
+        case PromiseState::Aggregate::NONE:
+            str = "none";
+            break;
+        case PromiseState::Aggregate::ALL:
+            str = "all";
+            break;
+        case PromiseState::Aggregate::ANY:
+            str = "any";
+            break;
+        case PromiseState::Aggregate::RACE:
+            str = "race";
+            break;
+        default:
+            return out << "Unknown(" << static_cast<int>(type) << ")";
+    }
+    return out << str;
+}
+
+}  //  namespace threading
+}  //  namespace utils
+}  //  namespace avsCommon
+}  //  namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Threading/SharedExecutor.cpp b/AVSCommon/Utils/src/Threading/SharedExecutor.cpp
new file mode 100644
index 00000000..633a8203
--- /dev/null
+++ b/AVSCommon/Utils/src/Threading/SharedExecutor.cpp
@@ -0,0 +1,200 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+#include <exception>
+#include <cctype>
+
+#include <AVSCommon/Utils/Logger/ThreadMoniker.h>
+#include <AVSCommon/Utils/Memory/Memory.h>
+#include <AVSCommon/Utils/Power/PowerMonitor.h>
+#include <AVSCommon/Utils/Threading/private/SharedExecutor.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "Executor"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+template std::future<void> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<void()>&& function) noexcept;
+template std::future<bool> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<bool()>&& function) noexcept;
+template std::future<std::string> Executor::pushFunction(
+    QueuePosition queuePosition,
+    std::function<std::string()>&& function) noexcept;
+
+/// Prefix for power resource owned by @c Executor instance.
+/// @private
+static constexpr auto POWER_RESOURCE_PREFIX = "Executor:";
+
+/**
+ * Helper method to create power resource id from a moniker.
+ *
+ * This method concatenates @a POWER_RESOURCE_PREFIX with @a moniker without trailing spaces.
+ *
+ * @param moniker Moniker value to use.
+ * @return Power resource identifier.
+ * @private
+ */
+static std::string createPowerResourceName(const std::string& moniker) noexcept {
+    std::string::const_iterator it = moniker.begin();
+    while (it != moniker.end() && std::isspace(*it)) {
+        ++it;
+    }
+    std::string result;
+    constexpr auto powerResourcePrefixLen = sizeof(POWER_RESOURCE_PREFIX) - 1;
+    result.reserve(std::distance(it, moniker.end()) + powerResourcePrefixLen);
+    result.append(POWER_RESOURCE_PREFIX, powerResourcePrefixLen);
+    std::copy(it, moniker.end(), back_inserter(result));
+    return result;
+}
+
+SharedExecutor::SharedExecutor() noexcept :
+        m_executorMoniker{utils::logger::ThreadMoniker::generateMoniker(utils::logger::ThreadMoniker::PREFIX_EXECUTOR)},
+        m_threadRunning{false},
+        m_shutdown{false} {
+    ACSDK_DEBUG5(LX("created").d("moniker", m_executorMoniker));
+    m_powerResource =
+        power::PowerMonitor::getInstance()->createLocalPowerResource(createPowerResourceName(m_executorMoniker));
+}
+
+SharedExecutor::~SharedExecutor() noexcept {
+    shutdown();
+    ACSDK_DEBUG5(LX("destroyed").d("moniker", m_executorMoniker));
+}
+
+std::error_condition SharedExecutor::execute(std::function<void()>&& function) noexcept {
+    return execute(std::move(function), QueuePosition::Back);
+}
+
+std::error_condition SharedExecutor::execute(const std::function<void()>& function) noexcept {
+    // Forward copy of function reference.
+    return execute(std::function<void()>(function), QueuePosition::Back);
+}
+
+void SharedExecutor::waitForSubmittedTasks() noexcept {
+    std::unique_lock<std::mutex> lock{m_queueMutex};
+    if (m_threadRunning) {
+        // wait for thread to exit.
+        std::promise<void> flushedPromise;
+        auto flushedFuture = flushedPromise.get_future();
+        m_queue.emplace_back([&flushedPromise]() { flushedPromise.set_value(); });
+
+        lock.unlock();
+        flushedFuture.wait();
+    }
+}
+
+std::error_condition SharedExecutor::execute(std::function<void()>&& function, QueuePosition queuePosition) noexcept {
+    if (!function) {
+        ACSDK_ERROR(LX(__func__).d("reason", "emptyFunction"));
+        return std::errc::invalid_argument;
+    }
+    if (QueuePosition::Back != queuePosition && QueuePosition::Front != queuePosition) {
+        ACSDK_ERROR(LX(__func__).d("reason", "badQueuePosition"));
+        return std::errc::invalid_argument;
+    }
+
+    std::lock_guard<std::mutex> queueLock{m_queueMutex};
+    if (m_shutdown) {
+        ACSDK_WARN(LX(__func__).d("reason", "shutdownState"));
+        return std::errc::operation_not_permitted;
+    }
+
+    if (m_powerResource) {
+        m_powerResource->acquire();
+    }
+    m_queue.emplace(QueuePosition::Front == queuePosition ? m_queue.begin() : m_queue.end(), std::move(function));
+
+    if (!m_threadRunning) {
+        m_threadRunning = true;
+        // Restart task thread.
+        m_taskThread.start(std::bind(&SharedExecutor::runNext, this), m_executorMoniker);
+    }
+
+    return std::error_condition();
+}
+
+std::function<void()> SharedExecutor::pop() noexcept {
+    std::lock_guard<std::mutex> lock{m_queueMutex};
+    if (!m_queue.empty()) {
+        auto task = std::move(m_queue.front());
+        m_queue.pop_front();
+        return task;
+    }
+    return std::function<void()>();
+}
+
+bool SharedExecutor::hasNext() noexcept {
+    std::unique_lock<std::mutex> lock{m_queueMutex};
+    m_threadRunning = !m_queue.empty();
+    return m_threadRunning;
+}
+
+bool SharedExecutor::runNext() noexcept {
+    auto task = pop();
+    if (task) {
+#if __cpp_exceptions || defined(__EXCEPTIONS)
+        try {
+#endif
+            task();
+            // Ensure the task is released after executed.
+            task = nullptr;
+
+#if __cpp_exceptions || defined(__EXCEPTIONS)
+        } catch (const std::exception& ex) {
+            ACSDK_ERROR(LX(__func__).d("taskException", ex.what()));
+        } catch (...) {
+            ACSDK_ERROR(LX(__func__).d("taskException", "other"));
+        }
+#endif
+
+        if (m_powerResource) {
+            m_powerResource->release();
+        }
+    }
+
+    return hasNext();
+}
+
+void SharedExecutor::shutdown() noexcept {
+    std::unique_lock<std::mutex> lock{m_queueMutex};
+    m_queue.clear();
+    m_shutdown = true;
+    lock.unlock();
+    waitForSubmittedTasks();
+}
+
+bool SharedExecutor::isShutdown() noexcept {
+    return m_shutdown;
+}
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/Timing/TimerDelegate.cpp b/AVSCommon/Utils/src/Timing/TimerDelegate.cpp
index 2c818ad6..8fc1caf5 100644
--- a/AVSCommon/Utils/src/Timing/TimerDelegate.cpp
+++ b/AVSCommon/Utils/src/Timing/TimerDelegate.cpp
@@ -14,8 +14,9 @@
  */
 
 #include <AVSCommon/Utils/Error/FinallyGuard.h>
-#include "AVSCommon/Utils/Timing/TimerDelegate.h"
 #include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Logger/ThreadMoniker.h>
+#include <AVSCommon/Utils/Timing/TimerDelegate.h>
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("TimerDelegate");
@@ -32,6 +33,8 @@ namespace avsCommon {
 namespace utils {
 namespace timing {
 
+using utils::logger::ThreadMoniker;
+
 TimerDelegate::TimerDelegate() : m_running{false}, m_stopping{false} {
 }
 
@@ -45,10 +48,14 @@ void TimerDelegate::start(
     PeriodType periodType,
     size_t maxCount,
     std::function<void()> task) {
+    auto moniker = ThreadMoniker::generateMoniker(ThreadMoniker::PREFIX_TIMER);
+    ACSDK_DEBUG5(LX("init").d("moniker", moniker));
+
     std::lock_guard<std::mutex> lock(m_callMutex);
     cleanupLocked();
     activateLocked();
-    m_thread = std::thread(&TimerDelegate::timerLoop, this, delay, period, periodType, maxCount, task);
+    m_thread =
+        std::thread(&TimerDelegate::timerLoop, this, delay, period, periodType, maxCount, task, std::move(moniker));
 }
 
 void TimerDelegate::timerLoop(
@@ -56,9 +63,13 @@ void TimerDelegate::timerLoop(
     std::chrono::nanoseconds period,
     PeriodType periodType,
     size_t maxCount,
-    std::function<void()> task) {
+    std::function<void()> task,
+    std::string moniker) {
+    ThreadMoniker::setThisThreadMoniker(std::move(moniker));
+
     // Timepoint to measure delay/period against.
     auto now = std::chrono::steady_clock::now();
+    using utils::logger::ThreadMoniker;
 
     // Flag indicating whether we've drifted off schedule.
     bool offSchedule = false;
diff --git a/AVSCommon/Utils/src/WorkerThread.cpp b/AVSCommon/Utils/src/WorkerThread.cpp
index e82640b7..349f8c5d 100644
--- a/AVSCommon/Utils/src/WorkerThread.cpp
+++ b/AVSCommon/Utils/src/WorkerThread.cpp
@@ -23,10 +23,7 @@ namespace avsCommon {
 namespace utils {
 namespace threading {
 
-WorkerThread::WorkerThread() :
-        m_moniker{alexaClientSDK::avsCommon::utils::logger::ThreadMoniker::generateMoniker()},
-        m_stop{false},
-        m_cancel{false} {
+WorkerThread::WorkerThread() : m_stop{false}, m_cancel{false} {
     m_thread = std::thread{std::bind(&WorkerThread::runInternal, this)};
 }
 
@@ -45,14 +42,14 @@ WorkerThread::~WorkerThread() {
     }
 }
 
-std::string WorkerThread::getMoniker() const {
-    return m_moniker;
-}
-
 void WorkerThread::cancel() {
     m_cancel = true;
 }
 
+std::thread::id WorkerThread::getThreadId() const {
+    return m_thread.get_id();
+}
+
 void WorkerThread::run(std::function<bool()> workFunc) {
     std::lock_guard<std::mutex> lock(m_mutex);
     m_cancel = false;
@@ -61,7 +58,6 @@ void WorkerThread::run(std::function<bool()> workFunc) {
 }
 
 void WorkerThread::runInternal() {
-    alexaClientSDK::avsCommon::utils::logger::ThreadMoniker::setThisThreadMoniker(m_moniker);
     std::unique_lock<std::mutex> lock(m_mutex);
     do {
         // If run is called before the thread starts, it will notify before we wait, so we guard against that by
diff --git a/AVSCommon/Utils/test/ExecutorTest.cpp b/AVSCommon/Utils/test/ExecutorTest.cpp
index abd87894..68a0dc97 100644
--- a/AVSCommon/Utils/test/ExecutorTest.cpp
+++ b/AVSCommon/Utils/test/ExecutorTest.cpp
@@ -13,8 +13,13 @@
  * permissions and limitations under the License.
  */
 
-#include <list>
+#include <chrono>
+#include <condition_variable>
 #include <gtest/gtest.h>
+#include <list>
+#include <mutex>
+#include <system_error>
+#include <thread>
 
 #include "ExecutorTestUtils.h"
 #include "AVSCommon/Utils/Threading/Executor.h"
@@ -26,6 +31,9 @@ namespace utils {
 namespace threading {
 namespace test {
 
+/// Maximum timeout for blocking wait when expecting a signal.
+static const std::chrono::seconds EXECUTOR_SIGNAL_WAIT_TIMEOUT{30};
+
 class ExecutorTest : public ::testing::Test {
 public:
     Executor executor;
@@ -34,24 +42,28 @@ public:
 TEST_F(ExecutorTest, testTimer_submitStdFunctionAndVerifyExecution) {
     std::function<void()> function = []() {};
     auto future = executor.submit(function);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
 
 TEST_F(ExecutorTest, testTimer_submitStdBindAndVerifyExecution) {
     auto future = executor.submit(std::bind(exampleFunctionParams, 0));
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
 
 TEST_F(ExecutorTest, testTimer_submitLambdaAndVerifyExecution) {
     auto future = executor.submit([]() {});
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
 
 TEST_F(ExecutorTest, testTimer_submitFunctionPointerAndVerifyExecution) {
     auto future = executor.submit(&exampleFunction);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
@@ -59,6 +71,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionPointerAndVerifyExecution) {
 TEST_F(ExecutorTest, testTimer_submitFunctorAndVerifyExecution) {
     ExampleFunctor exampleFunctor;
     auto future = executor.submit(exampleFunctor);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
@@ -66,6 +79,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctorAndVerifyExecution) {
 TEST_F(ExecutorTest, testTimer_submitFunctionWithPrimitiveReturnTypeNoArgsAndVerifyExecution) {
     int value = VALUE;
     auto future = executor.submit([=]() { return value; });
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get(), value);
@@ -74,6 +88,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithPrimitiveReturnTypeNoArgsAndVer
 TEST_F(ExecutorTest, testTimer_submitFunctionWithObjectReturnTypeNoArgsAndVerifyExecution) {
     SimpleObject value(VALUE);
     auto future = executor.submit([=]() { return value; });
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get().getValue(), value.getValue());
@@ -82,6 +97,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithObjectReturnTypeNoArgsAndVerify
 TEST_F(ExecutorTest, testTimer_submitFunctionWithNoReturnTypePrimitiveArgsAndVerifyExecution) {
     int value = VALUE;
     auto future = executor.submit([](int number) {}, value);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
@@ -89,6 +105,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithNoReturnTypePrimitiveArgsAndVer
 TEST_F(ExecutorTest, testTimer_submitFunctionWithNoReturnTypeObjectArgsAndVerifyExecution) {
     SimpleObject arg(0);
     auto future = executor.submit([](SimpleObject object) {}, arg);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
 }
@@ -97,6 +114,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithPrimitiveReturnTypeObjectArgsAn
     int value = VALUE;
     SimpleObject arg(0);
     auto future = executor.submit([=](SimpleObject object) { return value; }, arg);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get(), value);
@@ -106,6 +124,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithObjectReturnTypePrimitiveArgsAn
     int arg = 0;
     SimpleObject value(VALUE);
     auto future = executor.submit([=](int primitive) { return value; }, arg);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get().getValue(), value.getValue());
@@ -115,6 +134,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithPrimitiveReturnTypePrimitiveArg
     int arg = 0;
     int value = VALUE;
     auto future = executor.submit([=](int number) { return value; }, arg);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get(), value);
@@ -124,6 +144,7 @@ TEST_F(ExecutorTest, testTimer_submitFunctionWithObjectReturnTypeObjectArgsAndVe
     SimpleObject value(VALUE);
     SimpleObject arg(0);
     auto future = executor.submit([=](SimpleObject object) { return value; }, arg);
+    ASSERT_TRUE(future.valid());
     auto future_status = future.wait_for(SHORT_TIMEOUT_MS);
     ASSERT_EQ(future_status, std::future_status::ready);
     ASSERT_EQ(future.get().getValue(), value.getValue());
@@ -223,15 +244,14 @@ TEST_F(ExecutorTest, testTimer_futureWaitsForTaskCleanup) {
     SlowDestructor slowDestructor;
 
     // Submit a lambda to execute which captures a parameter by value that is slow to destruct.
-    executor
-        .submit([slowDestructor, &cleanedUp] {
-            // Update the captured copy of slowDestructor so that it will delay destruction and update the cleanedUp
-            // flag.
-            slowDestructor.cleanedUp = &cleanedUp;
-        }
-                // wait for the promise to be fulfilled.
-                )
-        .wait();
+    auto future = executor.submit([slowDestructor, &cleanedUp] {
+        // Update the captured copy of slowDestructor so that it will delay destruction and update the cleanedUp
+        // flag.
+        slowDestructor.cleanedUp = &cleanedUp;
+    });
+    ASSERT_TRUE(future.valid());
+    // wait for the promise to be fulfilled.
+    ASSERT_EQ(std::future_status::ready, future.wait_for(SHORT_TIMEOUT_MS * 2));
 
     ASSERT_TRUE(cleanedUp);
 }
@@ -264,7 +284,7 @@ TEST_F(ExecutorTest, testTimer_shutdown) {
     EXPECT_TRUE(executor.isShutdown());
 
     // verify that the task has now completed
-    EXPECT_TRUE(done.valid());
+    ASSERT_TRUE(done.valid());
     done.get();
 
     // try to submit a new task and verify that it is rejected
@@ -294,7 +314,10 @@ TEST_F(ExecutorTest, testTimer_shutdownCancelJob) {
     auto jobToWaitDrop = [&jobToDropResult, &waitSetUp, &waitJobStart] {
         waitJobStart.wakeUp();
         waitSetUp.wait(SHORT_TIMEOUT_MS);
-        jobToDropResult.wait_for(SHORT_TIMEOUT_MS);
+        // prevent unit test crash if jobToDropResult is not valid. It is checked below.
+        if (jobToDropResult.valid()) {
+            jobToDropResult.wait_for(SHORT_TIMEOUT_MS);
+        }
     };
 
     // 1st job waits for setup to be done then wait for the second job to be cancelled.
@@ -302,6 +325,7 @@ TEST_F(ExecutorTest, testTimer_shutdownCancelJob) {
 
     // 2nd job that should never run. When cancelled, its return will become available.
     jobToDropResult = executor.submit(jobToDrop);
+    ASSERT_TRUE(jobToDropResult.valid());
 
     // Wake up first job and wait for it to start running.
     const std::chrono::seconds DEFAULT_TIMEOUT{5};
@@ -322,9 +346,9 @@ TEST_F(ExecutorTest, test_forwardPromise) {
         src.set_value(42);
 
         auto future = src.get_future();
-        auto dst = std::make_shared<std::promise<int>>();
-        forwardPromise(dst, &future);
-        EXPECT_EQ(dst->get_future().get(), 42);
+        std::promise<int> dst;
+        forwardPromise(dst, future);
+        EXPECT_EQ(dst.get_future().get(), 42);
     }
     // Should forward the void value
     {
@@ -332,9 +356,9 @@ TEST_F(ExecutorTest, test_forwardPromise) {
         src.set_value();
 
         auto future = src.get_future();
-        auto dst = std::make_shared<std::promise<void>>();
-        forwardPromise(dst, &future);
-        EXPECT_NO_THROW(dst->get_future().get());
+        std::promise<void> dst;
+        forwardPromise(dst, future);
+        EXPECT_NO_THROW(dst.get_future().get());
     }
     // Should forward the exception
     {
@@ -342,9 +366,9 @@ TEST_F(ExecutorTest, test_forwardPromise) {
         src.set_exception(std::make_exception_ptr(std::exception()));
 
         auto future = src.get_future();
-        auto dst = std::make_shared<std::promise<int>>();
-        forwardPromise(dst, &future);
-        EXPECT_THROW(dst->get_future().get(), std::exception);
+        std::promise<int> dst;
+        forwardPromise(dst, future);
+        EXPECT_THROW(dst.get_future().get(), std::exception);
     }
     // Should forward the exception
     {
@@ -352,15 +376,16 @@ TEST_F(ExecutorTest, test_forwardPromise) {
         src.set_exception(std::make_exception_ptr(std::exception()));
 
         auto future = src.get_future();
-        auto dst = std::make_shared<std::promise<void>>();
-        forwardPromise(dst, &future);
-        EXPECT_THROW(dst->get_future().get(), std::exception);
+        std::promise<void> dst;
+        forwardPromise(dst, future);
+        EXPECT_THROW(dst.get_future().get(), std::exception);
     }
 }
 
 TEST_F(ExecutorTest, test_taskException) {
     {
         auto future = executor.submit([] { throw std::exception(); });
+        ASSERT_TRUE(future.valid());
         EXPECT_THROW(future.get(), std::exception);
     }
     {
@@ -370,10 +395,133 @@ TEST_F(ExecutorTest, test_taskException) {
                 return param;
             },
             42);
+        ASSERT_TRUE(future.valid());
         EXPECT_THROW(future.get(), std::runtime_error);
     }
 }
 
+/// Verify that empty function is not accepted by executor using movable function.
+TEST_F(ExecutorTest, test_executeEmptyMove) {
+    std::function<void()> fn;
+    ASSERT_FALSE(executor.execute(std::move(fn)));
+}
+
+/// Verify that empty function is not accepted by executor using const reference function.
+TEST_F(ExecutorTest, test_executeEmptyRef) {
+    const std::function<void()> fn;
+    ASSERT_FALSE(executor.execute(fn));
+}
+
+/// Verify that after task execution, the lambda is released if movable function is used.
+TEST_F(ExecutorTest, test_executeLambdaMove) {
+    std::mutex mutex;
+    std::condition_variable cond;
+    volatile bool executed = false;
+    volatile bool canExecute = false;
+    volatile bool started = false;
+    std::error_condition error;
+
+    auto shared = std::make_shared<std::string>();
+    auto weak = std::weak_ptr<std::string>(shared);
+    auto lambda = [&, shared] {
+        std::unique_lock<std::mutex> lock{mutex};
+        started = true;
+        cond.notify_all();
+        if (cond.wait_for(lock, EXECUTOR_SIGNAL_WAIT_TIMEOUT, [&] { return canExecute; })) {
+            executed = true;
+        } else {
+            error = std::errc::timed_out;
+        }
+        (void)&shared;
+    };
+
+    // Release strong reference and verify weak one is still valid (hold by lambda).
+    shared.reset();
+    ASSERT_FALSE(shared);
+    ASSERT_TRUE(weak.lock());
+
+    // Initiate execution but block executor thread in lambda.
+    ASSERT_TRUE(executor.execute(std::move(lambda)));
+    // Ensure lambda execution has started and blocked. If there is a bug in lambda, the executed flag may be set only
+    // if we give enough time for new thread start.
+    {
+        std::unique_lock<std::mutex> lock{mutex};
+        ASSERT_TRUE(cond.wait_for(lock, EXECUTOR_SIGNAL_WAIT_TIMEOUT, [&] { return started; }));
+    }
+    ASSERT_FALSE(executed);
+
+    // Check the reference is still valid.
+    ASSERT_TRUE(weak.lock());
+
+    // Allow lambda to complete
+    {
+        std::unique_lock<std::mutex> lock{mutex};
+        canExecute = true;
+    }
+    cond.notify_all();
+    executor.waitForSubmittedTasks();
+
+    // Verify the task is completed and shared object is released.
+    ASSERT_TRUE(executed);
+    ASSERT_FALSE(weak.lock());
+    ASSERT_FALSE(error);
+}
+
+/// Verify that after task execution, the lambda is not released if movable function is not used.
+TEST_F(ExecutorTest, test_executeLambdaRef) {
+    std::mutex mutex;
+    std::condition_variable cond;
+    volatile bool executed = false;
+    volatile bool canExecute = false;
+    volatile bool started = false;
+    std::error_condition error;
+
+    auto shared = std::make_shared<std::string>();
+    auto weak = std::weak_ptr<std::string>(shared);
+    const auto lambda = [&, shared] {
+        std::unique_lock<std::mutex> lock{mutex};
+        started = true;
+        cond.notify_all();
+        if (cond.wait_for(lock, EXECUTOR_SIGNAL_WAIT_TIMEOUT, [&] { return canExecute; })) {
+            executed = true;
+        } else {
+            error = std::errc::timed_out;
+        }
+        (void)&shared;
+    };
+
+    // Release strong reference and verify weak one is still valid (hold by lambda).
+    shared.reset();
+    ASSERT_FALSE(shared);
+    ASSERT_TRUE(weak.lock());
+
+    // Initiate execution but block executor thread in lambda.
+    ASSERT_TRUE(executor.execute(lambda));
+    // Ensure lambda execution has started and blocked. If there is a bug in lambda, the executed flag may be set only
+    // if we give enough time for new thread start.
+    {
+        std::unique_lock<std::mutex> lock{mutex};
+        ASSERT_TRUE(cond.wait_for(lock, EXECUTOR_SIGNAL_WAIT_TIMEOUT, [&] { return started; }));
+    }
+    ASSERT_FALSE(executed);
+
+    // Check the reference is still valid.
+    ASSERT_TRUE(weak.lock());
+
+    // Allow lambda to complete
+    {
+        std::unique_lock<std::mutex> lock{mutex};
+        canExecute = true;
+    }
+    cond.notify_all();
+    executor.waitForSubmittedTasks();
+
+    // Verify task is completed and we still have shared object through lambda
+    ASSERT_TRUE(executed);
+    ASSERT_TRUE(weak.lock());
+    ASSERT_FALSE(error);
+}
+
 }  // namespace test
 }  // namespace threading
 }  // namespace utils
diff --git a/AVSCommon/Utils/test/TaskThreadTest.cpp b/AVSCommon/Utils/test/TaskThreadTest.cpp
index d87c3973..6a277e10 100644
--- a/AVSCommon/Utils/test/TaskThreadTest.cpp
+++ b/AVSCommon/Utils/test/TaskThreadTest.cpp
@@ -27,6 +27,10 @@ namespace test {
 
 /// Timeout used while waiting for synchronization events.
 const std::chrono::milliseconds MY_WAIT_TIMEOUT{100};
+/// Default thread moniker to use in tests.
+const auto THREAD_MONIKER = "1a1";
+/// Another thread moniker to use in tests.
+const auto THREAD_MONIKER2 = "1a2";
 
 using namespace logger;
 
@@ -39,7 +43,7 @@ TEST(TaskThreadTest, test_waitForNothing) {
 TEST(TaskThreadTest, test_startFailsDueToEmptyFunction) {
     TaskThread taskThread;
     std::function<bool()> emptyFunction;
-    EXPECT_FALSE(taskThread.start(emptyFunction));
+    EXPECT_FALSE(taskThread.start(emptyFunction, THREAD_MONIKER));
 }
 
 /// Test that start will trigger the provided job and thread will exit once the job is done and return @c false.
@@ -54,7 +58,7 @@ TEST(TaskThreadTest, test_simpleJob) {
 
     {
         TaskThread taskThread;
-        EXPECT_TRUE(taskThread.start(simpleJob));
+        EXPECT_TRUE(taskThread.start(simpleJob, THREAD_MONIKER));
         EXPECT_TRUE(waitEvent.wait(MY_WAIT_TIMEOUT));
     }
 
@@ -78,7 +82,7 @@ TEST(TaskThreadTest, test_sequenceJobs) {
 
     {
         TaskThread taskThread;
-        EXPECT_TRUE(taskThread.start(jobSequence));
+        EXPECT_TRUE(taskThread.start(jobSequence, THREAD_MONIKER));
         EXPECT_TRUE(waitEvent.wait(MY_WAIT_TIMEOUT));
     }
 
@@ -108,10 +112,10 @@ TEST(TaskThreadTest, test_startNewJob) {
     };
 
     TaskThread taskThread;
-    EXPECT_TRUE(taskThread.start(increment));
+    EXPECT_TRUE(taskThread.start(increment, THREAD_MONIKER));
 
     EXPECT_TRUE(waitEvent.wait(MY_WAIT_TIMEOUT));
-    EXPECT_TRUE(taskThread.start(decrement));
+    EXPECT_TRUE(taskThread.start(decrement, THREAD_MONIKER));
     EXPECT_TRUE(waitEvent2.wait(MY_WAIT_TIMEOUT));
     EXPECT_TRUE(taskCounter == 0);
 }
@@ -126,11 +130,11 @@ TEST(TaskThreadTest, testTimer_startFailDueTooManyThreads) {
     };
 
     TaskThread taskThread;
-    EXPECT_TRUE(taskThread.start(simpleJob));
+    EXPECT_TRUE(taskThread.start(simpleJob, THREAD_MONIKER));
 
     // Wait until first job has started.
-    waitStart.wait(MY_WAIT_TIMEOUT);
-    EXPECT_TRUE(taskThread.start([] { return false; }));
+    EXPECT_TRUE(waitStart.wait(MY_WAIT_TIMEOUT));
+    EXPECT_TRUE(taskThread.start([] { return false; }, THREAD_MONIKER));
 
     // Starting a thread again immediately should fail, unless the system is so fast in starting
     // the thread on the other core that it starts and runs a few instructions before this can
@@ -138,7 +142,7 @@ TEST(TaskThreadTest, testTimer_startFailDueTooManyThreads) {
     int threadStartCount;
     for (threadStartCount = 0; threadStartCount < 100; threadStartCount++) {
         // This should fail since the task thread is starting.
-        if (!taskThread.start([] { return false; })) {
+        if (!taskThread.start([] { return false; }, THREAD_MONIKER)) {
             break;
         }
     }
@@ -147,7 +151,7 @@ TEST(TaskThreadTest, testTimer_startFailDueTooManyThreads) {
     waitEnqueue.wakeUp();
 }
 
-/// Test that threads related to this task thread will always have the same moniker.
+/// Test that threads related to this task thread will always have specified moniker.
 TEST(TaskThreadTest, DISABLED_test_moniker) {
     WaitEvent waitGetMoniker, waitValidateMoniker;
     std::string moniker;
@@ -157,18 +161,22 @@ TEST(TaskThreadTest, DISABLED_test_moniker) {
         return false;
     };
 
-    auto validateMoniker = [&moniker, &waitValidateMoniker] {
-        EXPECT_EQ(moniker, ThreadMoniker::getThisThreadMoniker());
+    std::string moniker2;
+    auto validateMoniker = [&moniker2, &waitValidateMoniker] {
+        moniker2 = ThreadMoniker::getThisThreadMoniker();
         waitValidateMoniker.wakeUp();
         return false;
     };
 
     TaskThread taskThread;
-    EXPECT_TRUE(taskThread.start(getMoniker));
-    waitGetMoniker.wait(MY_WAIT_TIMEOUT);
+    EXPECT_TRUE(taskThread.start(getMoniker, THREAD_MONIKER));
+    EXPECT_TRUE(waitGetMoniker.wait(MY_WAIT_TIMEOUT));
 
-    EXPECT_TRUE(taskThread.start(validateMoniker));
-    waitValidateMoniker.wait(MY_WAIT_TIMEOUT);
+    EXPECT_TRUE(taskThread.start(validateMoniker, THREAD_MONIKER2));
+    EXPECT_TRUE(waitValidateMoniker.wait(MY_WAIT_TIMEOUT));
+
+    EXPECT_EQ(THREAD_MONIKER, moniker);
+    EXPECT_EQ(THREAD_MONIKER2, moniker2);
 }
 
 /// Test that threads from different @c TaskThreads will have different monikers.
@@ -183,19 +191,23 @@ TEST(TaskThreadTest, test_monikerDifferentObjects) {
         return false;
     };
 
-    auto validateMoniker = [&moniker, &waitValidateMoniker] {
-        EXPECT_NE(moniker, ThreadMoniker::getThisThreadMoniker());
+    std::string moniker2;
+    auto validateMoniker = [&moniker2, &waitValidateMoniker] {
+        moniker2 = ThreadMoniker::getThisThreadMoniker();
         waitValidateMoniker.wakeUp();
         return false;
     };
 
     TaskThread taskThread1;
     TaskThread taskThread2;
-    EXPECT_TRUE(taskThread1.start(getMoniker));
-    EXPECT_TRUE(taskThread2.start(validateMoniker));
+    EXPECT_TRUE(taskThread1.start(getMoniker, THREAD_MONIKER));
+    EXPECT_TRUE(taskThread2.start(validateMoniker, THREAD_MONIKER2));
     waitThread2Start.wakeUp();
-    waitGetMoniker.wait(MY_WAIT_TIMEOUT);
-    waitValidateMoniker.wait(MY_WAIT_TIMEOUT);
+    EXPECT_TRUE(waitGetMoniker.wait(MY_WAIT_TIMEOUT));
+    EXPECT_TRUE(waitValidateMoniker.wait(MY_WAIT_TIMEOUT));
+
+    EXPECT_EQ(THREAD_MONIKER, moniker);
+    EXPECT_EQ(THREAD_MONIKER2, moniker2);
 }
 
 }  // namespace test
diff --git a/AVSCommon/Utils/test/Threading/OnFulfilledAdapterTest.cpp b/AVSCommon/Utils/test/Threading/OnFulfilledAdapterTest.cpp
new file mode 100644
index 00000000..f3ba5d17
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/OnFulfilledAdapterTest.cpp
@@ -0,0 +1,350 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+/// Error value for unit tests.
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for OnFulfilledAdapter<T>::adapt<R>() methods.
+ *
+ * This test verifies adapters for OnFulfilled callables for Promise<T>::then<R>() operations.
+ */
+class PromiseTypeTraitsAdaptOnFulfilledTest : public Test {};
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithResolverAndFulfill) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::string state1Value;
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<std::string>::adapt<std::string>(
+        [&state1Value, &state2Resolver](const std::string& value, PromiseResolver<std::string> resolver) {
+            state1Value = value;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    ASSERT_EQ("test1", state1Value);
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test2")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test2", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnFulfilledWithResolver<R> functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithResolverAndReject) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<std::string>::adapt<std::string>(
+        [&state1Value, &state2Resolver](const std::string& value, PromiseResolver<std::string> resolver) {
+            state1Value = value;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithResolverAndFulfillForVoidResultType) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<std::string>::adapt<void>(
+        [&state1Value, &state2Resolver](const std::string& value, PromiseResolver<void> resolver) {
+            state1Value = value;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve()) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithResolverAndRejectForVoidResultType) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<std::string>::adapt<void>(
+        [&state1Value, &state2Resolver](const std::string& value, PromiseResolver<void> resolver) {
+            state1Value = value;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithPRomise<R>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithPromiseAndFulfill) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::string state1Value;
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled =
+        OnFulfilledAdapter<std::string>::adapt<std::string>([&state1Value, &state2Resolver](const std::string& value) {
+            state1Value = value;
+            Promise<std::string> promise2;
+            std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    ASSERT_EQ("test1", state1Value);
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test2")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test2", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnFulfilledWithResolver<R> functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithPromiseAndReject) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled =
+        OnFulfilledAdapter<std::string>::adapt<std::string>([&state1Value, &state2Resolver](const std::string& value) {
+            state1Value = value;
+            Promise<std::string> promise2;
+            std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithPromiseAndFulfillForVoidResultType) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled =
+        OnFulfilledAdapter<std::string>::adapt<void>([&state1Value, &state2Resolver](const std::string& value) {
+            state1Value = value;
+            Promise<void> promise2;
+            std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve()) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithPromiseAndRejectForVoidResultType) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled =
+        OnFulfilledAdapter<std::string>::adapt<void>([&state1Value, &state2Resolver](const std::string& value) {
+            state1Value = value;
+            Promise<void> promise2;
+            std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithPRomise<R>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithValue) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::string state1Value;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<std::string>::adapt<std::string>([&state1Value](const std::string& value) {
+        state1Value = value;
+        return "test2";
+    });
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    ASSERT_EQ("test1", state1Value);
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test2", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(PromiseTypeTraitsAdaptOnFulfilledTest, test_adaptWithValueForVoidResultType) {
+    std::string state1Value;
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled =
+        OnFulfilledAdapter<std::string>::adapt<void>([&state1Value](const std::string& value) { state1Value = value; });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+
+    onFulfilled(state2, PromiseTypeTraits<std::string>::emplace("test1"));
+
+    EXPECT_EQ("test1", state1Value) << "Value must be correctly passed into handler";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/OnFulfilledWithVoidValueAdapterTest.cpp b/AVSCommon/Utils/test/Threading/OnFulfilledWithVoidValueAdapterTest.cpp
new file mode 100644
index 00000000..8037e951
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/OnFulfilledWithVoidValueAdapterTest.cpp
@@ -0,0 +1,313 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for OnFulfilledAdapter<void>::adapt<R>() methods.
+ *
+ * This test verifies adapters for OnFulfilled callables for Promise<T>::then<R>() operations.
+ */
+class OnFulfilledAdapterWithVoldValueTest : public Test {};
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithResolverAndFulfill) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<std::string>(
+        [&state2Resolver](PromiseResolver<std::string> resolver) { state2Resolver = std::move(resolver); });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<void>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithResolverAndReject) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<std::string>(
+        [&state2Resolver](PromiseResolver<std::string> resolver) { state2Resolver = std::move(resolver); });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithResolverAndFulfillForVoidResultType) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<void>(
+        [&state2Resolver](PromiseResolver<void> resolver) { state2Resolver = std::move(resolver); });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve()) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<void>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithResolverAndRejectForVoidResultType) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<void>(
+        [&state2Resolver](PromiseResolver<void> resolver) { state2Resolver = std::move(resolver); });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithPromiseAndFulfill) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<std::string>([&state2Resolver]() {
+        Promise<std::string> promise2;
+        std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+        return promise2;
+    });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<void>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithPromiseAndReject) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<std::string>([&state2Resolver]() {
+        Promise<std::string> promise2;
+        std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+        return promise2;
+    });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithPromiseAndFulfillForVoidResultType) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<void>([&state2Resolver]() {
+        Promise<void> promise2;
+        std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+        return promise2;
+    });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve()) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<void>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithPromiseAndRejectForVoidResultType) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<void>([&state2Resolver]() {
+        Promise<void> promise2;
+        std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+        return promise2;
+    });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<R>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithValue) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<std::string>([]() { return "test"; });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnFulfilledWithResolver<void>
+ * functions.
+ */
+TEST_F(OnFulfilledAdapterWithVoldValueTest, test_adaptWithValueForVoidResultType) {
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::shared_ptr<PromiseState::Value> state2Value;
+    auto onFulfilledCalled = false;
+
+    auto onFulfilled = OnFulfilledAdapter<void>::adapt<void>([&onFulfilledCalled]() { onFulfilledCalled = true; });
+
+    ASSERT_TRUE(onFulfilled) << "Adapter must not be empty";
+    ASSERT_FALSE(onFulfilledCalled) << "Resolver must not be set at this stage";
+
+    onFulfilled(state2, PromiseState::getVoidValue());
+
+    ASSERT_TRUE(onFulfilledCalled) << "Handler must be called";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/OnRejectedAdapterTest.cpp b/AVSCommon/Utils/test/Threading/OnRejectedAdapterTest.cpp
new file mode 100644
index 00000000..e63626e6
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/OnRejectedAdapterTest.cpp
@@ -0,0 +1,355 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+/// Error value for unit tests.
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for PromiseTypeTraits<T>::adapt<R>() methods.
+ *
+ * This test verifies adapters for OnRejected callables for Promise<T>::then<R>() and Promise<T>::thenCatch()
+ * operations.
+ */
+class OnRejectedAdapterTest : public Test {};
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnRejectedWithResolver<R> functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithResolverAndFulfill) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](
+            const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+            state1RejectReason = rejectReason;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnRejectedWithResolver<R> functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithResolverAndReject) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](
+            const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+            state1RejectReason = rejectReason;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnRejectedWithResolver<void>
+ * functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithResolverAndFulfillForVoidResultType) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](
+            const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+            state1RejectReason = rejectReason;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnRejectedWithResolver<void>
+ * functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithResolverAndRejectForVoidResultType) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](
+            const std::error_condition& rejectReason, PromiseResolver<std::string> resolver) {
+            state1RejectReason = rejectReason;
+            state2Resolver = std::move(resolver);
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnRejectedWithResolver<R> functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithPromiseAndFulfill) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](const std::error_condition& rejectReason) {
+            state1RejectReason = rejectReason;
+            Promise<std::string> promise2;
+            std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve("test")) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnRejectedWithResolver<R> functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithPromiseAndReject) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onRejected = OnRejectedAdapter::adapt<std::string>(
+        [&state1RejectReason, &state2Resolver](const std::error_condition& rejectReason) {
+            state1RejectReason = rejectReason;
+            Promise<std::string> promise2;
+            std::tie(promise2, state2Resolver) = Promise<std::string>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnRejectedWithResolver<void>
+ * functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithPromiseAndFulfillForVoidResultType) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected = OnRejectedAdapter::adapt<void>(
+        [&state1RejectReason, &state2Resolver](const std::error_condition& rejectReason) {
+            state1RejectReason = rejectReason;
+            Promise<void> promise2;
+            std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.resolve()) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+/**
+ * @brief Verify destination state can be rejected through adapter for Promise<T>::OnRejectedWithResolver<void>
+ * functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithPromiseAndRejectForVoidResultType) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    PromiseResolver<void> state2Resolver;
+    std::error_condition state2RejectReason;
+
+    auto onRejected = OnRejectedAdapter::adapt<void>(
+        [&state1RejectReason, &state2Resolver](const std::error_condition& rejectReason) {
+            state1RejectReason = rejectReason;
+            Promise<void> promise2;
+            std::tie(promise2, state2Resolver) = Promise<void>::__makePending();
+            return promise2;
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+    ASSERT_FALSE(state2Resolver.isValid()) << "Resolver must not be set at this stage";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2Resolver.isValid()) << "Resolver must be set at this stage";
+    ASSERT_TRUE(state2->isPending()) << "state2 must be pending before resolver call";
+
+    ASSERT_TRUE(state2Resolver.reject(std::errc::invalid_argument)) << "Resolver call must succeed";
+    ASSERT_TRUE(state2->isRejected()) << "state2 must be rejected after resolver call";
+    ASSERT_TRUE(state2->getRejectReason(state2RejectReason)) << "reject reason must be present in state object";
+    ASSERT_EQ(INVALID_ARGUMENT, state2RejectReason);
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<T>::OnRejectedWithResolver<R> functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithValue) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected =
+        OnRejectedAdapter::adapt<std::string>([&state1RejectReason](const std::error_condition& rejectReason) {
+            state1RejectReason = rejectReason;
+            return "test";
+        });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ("test", *static_cast<const std::string*>(state2Value.get()));
+}
+
+/**
+ * @brief Verify destination state can be fulfilled through adapter for Promise<void>::OnRejectedWithResolver<void>
+ * functions.
+ */
+TEST_F(OnRejectedAdapterTest, test_adaptWithValueAndFulfillForVoidResultType) {
+    std::error_condition state1RejectReason;
+
+    // Result will be stored in state2.
+    auto state2 = std::make_shared<PromiseState>();
+    std::shared_ptr<PromiseState::Value> state2Value;
+
+    auto onRejected = OnRejectedAdapter::adapt<void>(
+        [&state1RejectReason](const std::error_condition& rejectReason) { state1RejectReason = rejectReason; });
+
+    ASSERT_TRUE(onRejected) << "Adapter must not be empty";
+
+    onRejected(state2, std::errc::invalid_argument);
+
+    ASSERT_TRUE(state2->isFulfilled()) << "state2 must be fulfilled after resolver call";
+    ASSERT_TRUE(state2->getValue(state2Value)) << "value must be present in state object";
+    ASSERT_EQ(PromiseState::getVoidValue(), state2Value);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseCommonAllTest.cpp b/AVSCommon/Utils/test/Threading/PromiseCommonAllTest.cpp
new file mode 100644
index 00000000..2f4f89a8
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseCommonAllTest.cpp
@@ -0,0 +1,297 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gmock/gmock.h>
+#include <future>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/**
+ * @brief Test fixture for PromiseCommon::all() method tests.
+ */
+class PromiseCommonAllTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit1Executor() noexcept;
+
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit2Executor() noexcept;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init1Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init1Scheduled;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init2Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init2Scheduled;
+};
+
+void PromiseCommonAllTest::SetUp() {
+    // Executor for Promise::Promise().
+    m_init1Executor = std::make_shared<MockExecutorInterface>();
+    // Executor for Promise::then().
+    m_init2Executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseCommonAllTest::configureDefaultInit1Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init1Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init1Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init1Executor, executeRef(_)).Times(0);
+}
+
+void PromiseCommonAllTest::configureDefaultInit2Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init2Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init2Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init2Executor, executeRef(_)).Times(0);
+}
+
+TEST_F(PromiseCommonAllTest, test_NoPromiseFulfilled) {
+    auto combinedPromise = PromiseCommon::all();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAllTest, test_AnySinglePromiseFulfilled) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(0); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1);
+
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAllTest, test_AnySinglePromiseRejected) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::timed_out); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::timed_out), rejectReason);
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseFirstFulfilledSecondFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    // Combined
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    ASSERT_FALSE(combinedPromise.isResolved());
+    m_init2Scheduled();
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseFirstRejectedSecondFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    m_init2Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseFirstFulfilledSecondRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    m_init2Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseFirstRejectedSecondRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::bad_address); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    m_init2Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::bad_address), rejectReason);
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseSecondFulfilledFirstFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+    ASSERT_FALSE(combinedPromise.isFulfilled());
+    m_init1Scheduled();
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseSecondRejectedFirstFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+    m_init1Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+TEST_F(PromiseCommonAllTest, test_AnyDualPromiseSecondRejectedFirstRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::bad_address); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+    m_init1Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+// Verify if argument list contains invalid object, the result is rejected.
+TEST_F(PromiseCommonAllTest, test_InvalidPromiseArgument) {
+    auto promise1 = Promise<void>::resolve();
+    Promise<int> promise2;
+
+    auto combinedPromise = PromiseCommon::all(promise1, promise2);
+    ASSERT_TRUE(combinedPromise.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseCommonAnyTest.cpp b/AVSCommon/Utils/test/Threading/PromiseCommonAnyTest.cpp
new file mode 100644
index 00000000..3268155c
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseCommonAnyTest.cpp
@@ -0,0 +1,251 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gmock/gmock.h>
+#include <future>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+// Error code for unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::bad_address};
+
+/**
+ * @brief Test fixture for PromiseCommon::any() method tests.
+ */
+class PromiseCommonAnyTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit1Executor() noexcept;
+
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit2Executor() noexcept;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init1Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init1Scheduled;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init2Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init2Scheduled;
+};
+
+void PromiseCommonAnyTest::SetUp() {
+    // Executor for Promise::Promise().
+    m_init1Executor = std::make_shared<MockExecutorInterface>();
+    // Executor for Promise::then().
+    m_init2Executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseCommonAnyTest::configureDefaultInit1Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init1Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init1Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init1Executor, executeRef(_)).Times(0);
+}
+
+void PromiseCommonAnyTest::configureDefaultInit2Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init2Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init2Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init2Executor, executeRef(_)).Times(0);
+}
+
+TEST_F(PromiseCommonAnyTest, test_NoPromiseFulfilled) {
+    auto combinedPromise = PromiseCommon::any();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnySinglePromiseFulfilled) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(0); });
+    // clang-format on
+    auto combinedPromise = PromiseCommon::any(promise1);
+
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnySinglePromiseRejected) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::timed_out); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::any(promise1);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}  // namespace avsCommon
+
+TEST_F(PromiseCommonAnyTest, test_AnyDualPromiseFirstFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    // Combined
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnyDualPromiseFirstRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    ASSERT_FALSE(combinedPromise.isResolved());
+    m_init2Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnyDualPromiseSecondFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnyDualPromiseSecondRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+    ASSERT_FALSE(combinedPromise.isResolved());
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonAnyTest, test_AnyDualPromiseBothRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::invalid_argument); });
+    Promise<int> promise2(
+        m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::invalid_argument); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+    ASSERT_FALSE(combinedPromise.isResolved());
+    m_init2Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+// Verify if argument list contains invalid object, the result is rejected.
+TEST_F(PromiseCommonAnyTest, test_InvalidPromiseArgument) {
+    auto promise1 = Promise<void>::resolve();
+    Promise<int> promise2;
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_TRUE(combinedPromise.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseCommonRaceTest.cpp b/AVSCommon/Utils/test/Threading/PromiseCommonRaceTest.cpp
new file mode 100644
index 00000000..890357a1
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseCommonRaceTest.cpp
@@ -0,0 +1,228 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gmock/gmock.h>
+#include <future>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+// Error code for unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::bad_address};
+
+/**
+ * @brief Test fixture for PromiseCommon::race() method tests.
+ */
+class PromiseCommonRaceTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit1Executor() noexcept;
+
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInit2Executor() noexcept;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init1Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init1Scheduled;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_init2Executor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_init2Scheduled;
+};
+
+void PromiseCommonRaceTest::SetUp() {
+    // Executor for Promise::Promise().
+    m_init1Executor = std::make_shared<MockExecutorInterface>();
+    // Executor for Promise::then().
+    m_init2Executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseCommonRaceTest::configureDefaultInit1Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init1Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init1Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init1Executor, executeRef(_)).Times(0);
+}
+
+void PromiseCommonRaceTest::configureDefaultInit2Executor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_init2Executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_init2Scheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_init2Executor, executeRef(_)).Times(0);
+}
+
+TEST_F(PromiseCommonRaceTest, test_NoPromiseFulfilled) {
+    auto combinedPromise = PromiseCommon::race();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnySinglePromiseFulfilled) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(0); });
+    // clang-format on
+    auto combinedPromise = PromiseCommon::race(promise1);
+
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnySinglePromiseRejected) {
+    configureDefaultInit1Executor();
+
+    // clang-format off
+    Promise<int> promise1(
+        m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.reject(std::errc::timed_out); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::race(promise1);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::timed_out), rejectReason);
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnyDualPromiseFirstFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    // Combined
+    auto combinedPromise = PromiseCommon::race(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnyDualPromiseFirstRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::race(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init1Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnyDualPromiseSecondFulfilled) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(1); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::race(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+
+    ASSERT_TRUE(combinedPromise.isFulfilled());
+}
+
+TEST_F(PromiseCommonRaceTest, test_AnyDualPromiseSecondRejected) {
+    configureDefaultInit1Executor();
+    configureDefaultInit2Executor();
+
+    // clang-format off
+    Promise<int> promise1(m_init1Executor, [&](PromiseResolver<int> resolver) noexcept { resolver.resolve(2); });
+    Promise<int> promise2(m_init2Executor, [&](PromiseResolver<int> resolver) noexcept {
+        resolver.reject(std::errc::operation_canceled);
+    });
+    // clang-format on
+
+    auto combinedPromise = PromiseCommon::race(promise1, promise2);
+    ASSERT_FALSE(combinedPromise.isResolved());
+
+    m_init2Scheduled();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+// Verify if argument list contains invalid object, the result is rejected.
+TEST_F(PromiseCommonRaceTest, test_InvalidPromiseArgument) {
+    auto promise1 = Promise<void>::resolve();
+    Promise<int> promise2;
+
+    auto combinedPromise = PromiseCommon::any(promise1, promise2);
+    ASSERT_TRUE(combinedPromise.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(combinedPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseFactoryTest.cpp b/AVSCommon/Utils/test/Threading/PromiseFactoryTest.cpp
new file mode 100644
index 00000000..526dc01b
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseFactoryTest.cpp
@@ -0,0 +1,135 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <acsdk/Threading/Test/PromiseTestHelper.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace alexaClientSDK::avsCommon::utils::threading::test;
+
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for Promise type.
+ */
+class PromiseFactoryTest : public Test {};
+
+// Validate constructed fulfilled promise for non-void type.
+TEST_F(PromiseFactoryTest, test_makeFulfilledPromise) {
+    auto promise = Promise<std::string>::resolve("test");
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Validate constructed fulfilled promise for void type.
+TEST_F(PromiseFactoryTest, test_makeVoidFulfilledPromise) {
+    auto promise = Promise<void>::resolve();
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+}
+
+// Validate constructed rejected promise for non-void type.
+TEST_F(PromiseFactoryTest, test_makeRejectedPromise) {
+    auto promise = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate constructed rejected promise for non-void type with bad argument.
+TEST_F(PromiseFactoryTest, test_makeRejectedPromiseWithBadArgument) {
+    auto promise = Promise<std::string>::reject(std::error_condition());
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Validate constructed rejected promise for void.
+TEST_F(PromiseFactoryTest, test_makeVoidRejectedPromise) {
+    auto promise = Promise<void>::reject(CUSTOM_ERROR);
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate constructed rejected promise for void with bad argument.
+TEST_F(PromiseFactoryTest, test_makeVoidRejectedPromiseWithBadArgument) {
+    auto promise = Promise<void>::reject(std::error_condition());
+
+    // Post-construction state
+    auto state = PromiseTestHelper::getState(promise);
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Validate constructed pending promise can be fulfilled by init handler.
+TEST_F(PromiseFactoryTest, test_makePendingPromise) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> promiseResolver;
+
+    std::tie(promise, promiseResolver) = Promise<std::string>::__makePending();
+
+    // Post-construction state
+    auto promiseState = PromiseTestHelper::getState(promise);
+    auto resolverState = PromiseTestHelper::getState(promiseResolver);
+    ASSERT_EQ(promiseState, resolverState);
+    ASSERT_TRUE(promiseState->isPending());
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseFinallyTest.cpp b/AVSCommon/Utils/test/Threading/PromiseFinallyTest.cpp
new file mode 100644
index 00000000..98bce0be
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseFinallyTest.cpp
@@ -0,0 +1,329 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseFinallyTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// Error code for use with unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/**
+ * @brief Test fixture for Promise::finally() method.
+ */
+class PromiseFinallyTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::finally() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onFulfilled or
+     * onRejected handlers.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution is leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor() noexcept;
+
+    /**
+     * @brief Executor mock for Promise::finally() methods.
+     *
+     * This executor is used to either invoke onFulfilled or onRejected handler.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief Scheduled function from m_executor executor.
+     *
+     * This function contains either a user-supplied onFulfilled or onRejected handler.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseFinallyTest::SetUp() {
+    // Executor for Promise::finally().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseFinallyTest::configureExecutor() noexcept {
+    // Store lambda on initExecutor->finally() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+}
+
+// Verify Promise::finally() onFulfilled handler for non-void type.
+TEST_F(PromiseFinallyTest, test_finallyValueResultToValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    std::string fulfillValue;
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled, &fulfillValue](const std::string& value) {
+            onFulfilledCalled = true;
+            fulfillValue = value;
+        },
+        [&onRejectedCalled](const std::error_condition& error) { onRejectedCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_EQ("test", fulfillValue);
+}
+
+// Verify Promise::finally() onFulfilled handler for void type.
+TEST_F(PromiseFinallyTest, test_finallyVoidFulfill) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled]() { onFulfilledCalled = true; },
+        [&onRejectedCalled](const std::error_condition&) { onRejectedCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+}
+
+// Verify Promise::finally() onRejected handler for non-void type.
+TEST_F(PromiseFinallyTest, test_finallyErrorResult) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+    std::error_condition rejectReason;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) { onFulfilledCalled = true; },
+        [&onRejectedCalled, &rejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            rejectReason = error;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Verify Promise::finally() onRejected handler for void type.
+TEST_F(PromiseFinallyTest, test_finallyOnErrorForVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+    std::error_condition rejectReason;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled]() { onFulfilledCalled = true; },
+        [&onRejectedCalled, &rejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            rejectReason = error;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Verify finally() immediately rejects promise if executor is nullptr.
+TEST_F(PromiseFinallyTest, test_finallyObjectIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    promise1.finally(nullptr, [](const std::string& value) {});
+
+    std::error_condition error;
+    ASSERT_TRUE(promise1.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify finally() immediately rejects promise if both onFulfilled and onRejected handlers are empty.
+TEST_F(PromiseFinallyTest, test_finallyObjectIsRejectedOnNullValueHandlers) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    promise1.finally(m_executor, nullptr, nullptr);
+
+    std::error_condition error;
+    ASSERT_TRUE(promise1.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify onFulfilled execution is scheduled immediately for fulfilled promise.
+TEST_F(PromiseFinallyTest, test_finallyValueHandlerExecutedForFulfilledPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::resolve("test");
+
+    std::string resultValue;
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled, &resultValue](const std::string& value) {
+            onFulfilledCalled = true;
+            resultValue = value;
+        },
+        [&onRejectedCalled](const std::error_condition&) { onRejectedCalled = true; });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_EQ("test", resultValue);
+}
+
+// Verify onRejected execution is scheduled immediately for rejected promise.
+TEST_F(PromiseFinallyTest, test_finallyErrorHandlerExecutedForRejectedPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition rejectReason;
+    auto onFulfilledCalled = false;
+    auto onRejectedCalled = false;
+
+    promise1.finally(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) { onFulfilledCalled = true; },
+        [&onRejectedCalled, &rejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            rejectReason = error;
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseInitTest.cpp b/AVSCommon/Utils/test/Threading/PromiseInitTest.cpp
new file mode 100644
index 00000000..f82be215
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseInitTest.cpp
@@ -0,0 +1,447 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseInitTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for Promise::Promise() init constructors.
+ */
+class PromiseInitTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for promise initial value.
+     */
+    void configureDefaultInitExecutor() noexcept;
+
+    /// Executor mock for Promise constructors.
+    std::shared_ptr<MockExecutorInterface> m_initExecutor;
+
+    /// Scheduled function from Promise::Promise() call.
+    std::function<void()> m_initScheduled;
+};
+
+void PromiseInitTest::SetUp() {
+    // Executor for Promise::Promise().
+    m_initExecutor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseInitTest::configureDefaultInitExecutor() noexcept {
+    // Store lambda on initExecutor->execute() invocation.
+    EXPECT_CALL(*m_initExecutor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_initScheduled = std::move(fn);
+        return std::error_condition{};
+    }));
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndFulfill) {
+    configureDefaultInitExecutor();
+
+    Promise<std::string> promise(
+        m_initExecutor, [](PromiseResolver<std::string> resolver) { resolver.resolve("test"); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+    std::string fulfillValue;
+    ASSERT_TRUE(promise.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndFulfillWithValue) {
+    configureDefaultInitExecutor();
+
+    Promise<std::string> promise(m_initExecutor, []() { return "test"; });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+    std::string fulfillValue;
+    ASSERT_TRUE(promise.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndFulfillWithEventualValue) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<std::string> resolver;
+    Promise<std::string> promise(m_initExecutor, [&resolver]() {
+        Promise<std::string> result;
+        std::tie(result, resolver) = Promise<std::string>::__makePending();
+        return result;
+    });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    ASSERT_TRUE(resolver.isValid());
+    ASSERT_TRUE(resolver.resolve("test"));
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+    std::string fulfillValue;
+    ASSERT_TRUE(promise.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndFulfill) {
+    configureDefaultInitExecutor();
+
+    Promise<void> promise(m_initExecutor, [](PromiseResolver<void> resolver) { resolver.resolve(); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndFulfillWithValue) {
+    configureDefaultInitExecutor();
+
+    Promise<void> promise(m_initExecutor, []() {});
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+}
+
+// Validate promise can be fulfilled in init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndFulfillWithEventualValue) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<void> resolver;
+    Promise<void> promise(m_initExecutor, [&resolver]() {
+        Promise<void> result;
+        std::tie(result, resolver) = Promise<void>::__makePending();
+        return result;
+    });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    ASSERT_TRUE(resolver.isValid());
+    ASSERT_TRUE(resolver.resolve());
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+}
+
+// Validate promise can be fulfilled outside of scope of init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndFulfillOutOfScope) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<std::string> promiseResolver;
+    Promise<std::string> promise(m_initExecutor, [&promiseResolver](PromiseResolver<std::string> resolver) {
+        promiseResolver = std::move(resolver);
+    });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Post init state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(promiseResolver.isValid());
+
+    // Fulfill
+    promiseResolver.resolve("test");
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+    std::string fulfillValue;
+    ASSERT_TRUE(promise.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+// Validate void promise can be fulfilled outside of scope of init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndFulfillOutOfScope) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<void> promiseResolver;
+    Promise<void> promise(
+        m_initExecutor, [&promiseResolver](PromiseResolver<void> resolver) { promiseResolver = std::move(resolver); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Post init state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(promiseResolver.isValid());
+
+    // Fulfill
+    promiseResolver.resolve();
+
+    // Final state
+    ASSERT_TRUE(promise.isFulfilled());
+}
+
+// Validate promise can be rejected by init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndReject) {
+    configureDefaultInitExecutor();
+
+    Promise<std::string> promise(
+        m_initExecutor, [](PromiseResolver<std::string> resolver) { resolver.reject(CUSTOM_ERROR); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate promise can be rejected by init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndRejectWithEventualValue) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<std::string> resolver;
+    Promise<std::string> promise(m_initExecutor, [&resolver]() {
+        Promise<std::string> result;
+        std::tie(result, resolver) = Promise<std::string>::__makePending();
+        return result;
+    });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    ASSERT_TRUE(resolver.reject(CUSTOM_ERROR));
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate promise can be rejected by init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndReject) {
+    configureDefaultInitExecutor();
+
+    Promise<void> promise(m_initExecutor, [](PromiseResolver<void> resolver) { resolver.reject(CUSTOM_ERROR); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate promise can be rejected by init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndRejectWithEventualValue) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<void> resolver;
+    Promise<void> promise(m_initExecutor, [&resolver]() {
+        Promise<void> result;
+        std::tie(result, resolver) = Promise<void>::__makePending();
+        return result;
+    });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    ASSERT_TRUE(resolver.reject(CUSTOM_ERROR));
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate promise can be rejected out of scope of init handler.
+TEST_F(PromiseInitTest, test_initPromiseAndRejectOutOfScope) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<std::string> promiseResolver;
+    Promise<std::string> promise = Promise<std::string>(
+        m_initExecutor,
+        [&promiseResolver](PromiseResolver<std::string> resolver) { promiseResolver = std::move(resolver); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Post-init state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(promiseResolver.isValid());
+
+    // Reject
+    ASSERT_TRUE(promiseResolver.reject(CUSTOM_ERROR));
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Validate promise can be rejected out of scope of init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseAndRejectOutOfScope) {
+    configureDefaultInitExecutor();
+
+    PromiseResolver<void> promiseResolver;
+    Promise<void> promise(
+        m_initExecutor, [&promiseResolver](PromiseResolver<void> resolver) { promiseResolver = std::move(resolver); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Post-init state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(promiseResolver.isValid());
+
+    // Reject
+    ASSERT_TRUE(promiseResolver.reject(CUSTOM_ERROR));
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+#if __cpp_exceptions || defined(__EXCEPTIONS)
+
+// Validate promise can be rejected out of scope of init handler.
+TEST_F(PromiseInitTest, test_initVoidPromiseRejectedWithException) {
+    configureDefaultInitExecutor();
+
+    Promise<void> promise(m_initExecutor, [](PromiseResolver<void> resolver) { throw std::bad_alloc(); });
+
+    // Post-construction state
+    ASSERT_TRUE(promise.isPending());
+    ASSERT_TRUE(m_initScheduled);
+
+    // Run init handler
+    m_initScheduled();
+
+    // Final state
+    ASSERT_TRUE(promise.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::operation_canceled), rejectReason);
+}
+
+#endif
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseResolverTest.cpp b/AVSCommon/Utils/test/Threading/PromiseResolverTest.cpp
new file mode 100644
index 00000000..2a032833
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseResolverTest.cpp
@@ -0,0 +1,349 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/PromiseTestHelper.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseResolverTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+/// @{
+/// @brief Error code constant for unit test.
+/// @private
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+/// @}
+
+/**
+ * @brief Test fixture for PromiseResolver<T> for non-void T type.
+ */
+class PromiseResolverTest : public Test {};
+
+// Validate constructed resolver are not valid.
+TEST_F(PromiseResolverTest, test_makeInvalid) {
+    PromiseResolver<std::string> resolver;
+
+    ASSERT_FALSE(resolver.isValid());
+    ASSERT_FALSE(PromiseTestHelper::getState(resolver));
+}
+
+// Validate constructed resolver are not valid for void type.
+TEST_F(PromiseResolverTest, test_makeValid) {
+    PromiseResolver<void> resolver;
+
+    ASSERT_FALSE(resolver.isValid());
+    ASSERT_FALSE(PromiseTestHelper::getState(resolver));
+}
+
+// Test copy constructor works for valid resolver
+TEST_F(PromiseResolverTest, test_copyConstructorForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test"));
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_TRUE(resolver1.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver1));
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy constructor works for invalid resolver
+TEST_F(PromiseResolverTest, test_copyConstructorForInvalid) {
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test move constructor works for valid resolver
+TEST_F(PromiseResolverTest, test_moveConstructorForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test"));
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2(std::move(resolver1));
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy constructor works for invalid resolver
+TEST_F(PromiseResolverTest, test_moveConstructorForInvalid) {
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test copy assignment works for valid resolver
+TEST_F(PromiseResolverTest, test_copyAssignmentForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test"));
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2;
+
+    resolver2 = resolver1;
+
+    ASSERT_TRUE(resolver1.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver1));
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy assignment works for invalid resolver
+TEST_F(PromiseResolverTest, test_copyAssignmentForInvalid) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test"));
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(state);
+
+    resolver2 = resolver1;
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test resolve.
+TEST_F(PromiseResolverTest, test_resolveImplicitConstructor) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_TRUE(resolver.resolve("test"));
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Test resolve.
+TEST_F(PromiseResolverTest, test_resolveCopyConstructor) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> resolver(state);
+
+    std::string value = "test";
+    ASSERT_TRUE(resolver.resolve(value));
+    // verify value is not moved
+    ASSERT_EQ("test", value);
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> fulfillValue;
+    ASSERT_TRUE(state->getValue(fulfillValue));
+    ASSERT_EQ("test", *static_cast<const std::string*>(fulfillValue.get()));
+}
+
+// Test resolve.
+TEST_F(PromiseResolverTest, test_resolveMoveConstructor) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> resolver(state);
+
+    std::string value = "test";
+    ASSERT_TRUE(resolver.resolve(std::move(value)));
+    ASSERT_EQ("", value);
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> fulfillValue;
+    ASSERT_TRUE(state->getValue(fulfillValue));
+    ASSERT_EQ("test", *static_cast<const std::string*>(fulfillValue.get()));
+}
+
+// Test resolve.
+TEST_F(PromiseResolverTest, test_resolveEmplace) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> resolver(state);
+
+    // see std::string constructors.
+    ASSERT_TRUE(resolver.resolveEmplace("test 123", 4u));
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Test resolve resolved.
+TEST_F(PromiseResolverTest, test_resolveResolved) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test1"));
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_FALSE(resolver.resolve("test2"));
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test1", *static_cast<const std::string*>(value.get()));
+}
+
+// Test resolve rejected.
+TEST_F(PromiseResolverTest, test_resolveRejected) {
+    auto state = std::make_shared<PromiseState>(CUSTOM_ERROR);
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_FALSE(resolver.resolve("test2"));
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test reject.
+TEST_F(PromiseResolverTest, test_reject) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_TRUE(resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test reject rejected state.
+TEST_F(PromiseResolverTest, test_rejectResolved) {
+    auto state = std::make_shared<PromiseState>(PromiseTypeTraits<std::string>::emplace("test1"));
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_FALSE(resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test1", *static_cast<const std::string*>(value.get()));
+}
+
+// Test reject rejected state.
+TEST_F(PromiseResolverTest, test_rejectRejected) {
+    auto state = std::make_shared<PromiseState>(CUSTOM_ERROR);
+    PromiseResolver<std::string> resolver(state);
+
+    ASSERT_FALSE(resolver.reject(INVALID_ARGUMENT));
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test eventual result error propagation.
+TEST_F(PromiseResolverTest, test_resolveWithPromiseAndReject) {
+    PromiseResolver<std::string> resolver1;
+    Promise<std::string> promise1;
+    std::tie(promise1, resolver1) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::string> resolver2;
+    Promise<std::string> promise2;
+    std::tie(promise2, resolver2) = Promise<std::string>::__makePending();
+
+    resolver2.resolve(promise1);
+
+    ASSERT_FALSE(PromiseTestHelper::getState(resolver1)->isResolved());
+    ASSERT_FALSE(PromiseTestHelper::getState(resolver2)->isResolved());
+
+    ASSERT_TRUE(resolver1.reject(CUSTOM_ERROR));
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->waitFor(std::chrono::seconds(10)));
+
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test non-eventual result error propagation.
+TEST_F(PromiseResolverTest, test_resolveWithRejectedPromise) {
+    auto promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    PromiseResolver<std::string> resolver2;
+    Promise<std::string> promise2;
+    std::tie(promise2, resolver2) = Promise<std::string>::__makePending();
+
+    resolver2.resolve(promise1);
+
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->waitFor(std::chrono::seconds(10)));
+
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test non-eventual result value propagation.
+TEST_F(PromiseResolverTest, test_resolveWithPromiseAndFulfill) {
+    auto promise1 = Promise<std::string>::resolve("test");
+
+    PromiseResolver<std::string> resolver2;
+    Promise<std::string> promise2;
+    std::tie(promise2, resolver2) = Promise<std::string>::__makePending();
+
+    resolver2.resolve(promise1);
+
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->waitFor(std::chrono::seconds(10)));
+
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver2)->getValue(value));
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Test std::swap operation
+TEST_F(PromiseResolverTest, test_swap) {
+    PromiseResolver<std::string> resolver1;
+    Promise<std::string> promise1;
+    std::tie(promise1, resolver1) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::string> resolver2;
+    Promise<std::string> promise2;
+    std::tie(promise2, resolver2) = Promise<std::string>::__makePending();
+
+    std::swap(resolver1, resolver2);
+
+    resolver1.resolve("test1");
+    resolver2.resolve("test2");
+
+    std::shared_ptr<PromiseState::Value> value1;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise1)->getValue(value1));
+    ASSERT_EQ("test2", *static_cast<const std::string*>(value1.get()));
+
+    std::shared_ptr<PromiseState::Value> value2;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getValue(value2));
+    ASSERT_EQ("test1", *static_cast<const std::string*>(value2.get()));
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseStateTest.cpp b/AVSCommon/Utils/test/Threading/PromiseStateTest.cpp
new file mode 100644
index 00000000..89d73886
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseStateTest.cpp
@@ -0,0 +1,682 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gmock/gmock.h>
+#include <thread>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Logger/LogEntry.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseState.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+using namespace ::std::placeholders;
+
+/// Error code for unit tests.
+static const std::error_condition INVALID_ARGUMENT(std::errc::invalid_argument);
+
+/// @brief Interface to intercept data calls.
+/// @private
+class ResultConsumerInterface {
+public:
+    virtual ~ResultConsumerInterface() = default;
+    virtual void onFulfilled(
+        const std::shared_ptr<PromiseState>& state2,
+        const std::shared_ptr<PromiseState::Value>& value) = 0;
+    virtual void onRejected(const std::shared_ptr<PromiseState>& state2, const std::error_condition& rejectReason) = 0;
+};
+
+/// Mock type for @c ResultConsumerInterface
+/// @private
+class MockResultConsumer : public ResultConsumerInterface {
+public:
+    MOCK_METHOD2(onFulfilled, void(const std::shared_ptr<PromiseState>&, const std::shared_ptr<PromiseState::Value>&));
+    MOCK_METHOD2(onRejected, void(const std::shared_ptr<PromiseState>&, const std::error_condition&));
+};
+
+/// Test fixture for @c PromiseState
+/// @see PromiseState
+class PromiseStateTest : public Test {
+public:
+};
+
+// Verify state checks for object in pending state.
+TEST_F(PromiseStateTest, test_createInPendingState) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->isPending());
+    ASSERT_FALSE(state->isResolved());
+    ASSERT_FALSE(state->isFulfilled());
+    ASSERT_FALSE(state->isRejected());
+}
+
+// Verify state checks for object in rejected state.
+TEST_F(PromiseStateTest, test_createInRejectedState) {
+    auto state = std::make_shared<PromiseState>(std::errc::host_unreachable);
+    ASSERT_TRUE(state);
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_FALSE(state->isFulfilled());
+    ASSERT_TRUE(state->isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::host_unreachable), rejectReason);
+}
+
+// Verify state checks for object in rejected state with zero error code.
+TEST_F(PromiseStateTest, test_createInRejectedStateWithBadError) {
+    auto state = std::make_shared<PromiseState>(std::error_condition());
+    ASSERT_TRUE(state);
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_FALSE(state->isFulfilled());
+    ASSERT_TRUE(state->isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify reject reason is not available when state is pending.
+TEST_F(PromiseStateTest, test_getRejectReasonFromPendingStateFails) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(state->getRejectReason(rejectReason));
+}
+
+// Verify reject reason is available when state is rejected.
+TEST_F(PromiseStateTest, test_getRejectReasonFromRejectedState) {
+    auto state = std::make_shared<PromiseState>(std::errc::invalid_argument);
+    ASSERT_TRUE(state);
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify transition from pending to rejected.
+TEST_F(PromiseStateTest, test_rejectFromPendingState) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->reject(std::errc::invalid_argument));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_TRUE(state->isRejected());
+    ASSERT_FALSE(state->isFulfilled());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify transition from pending to rejected with a zero error code.
+TEST_F(PromiseStateTest, test_rejectFromPendingStateError) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+    ASSERT_TRUE(state->reject(std::error_condition()));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_TRUE(state->isRejected());
+    ASSERT_FALSE(state->isFulfilled());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify transition from reject to reject fails.
+TEST_F(PromiseStateTest, test_rejectFromRejectedStateFails) {
+    auto state = std::make_shared<PromiseState>(std::errc::invalid_argument);
+    ASSERT_TRUE(state);
+
+    ASSERT_FALSE(state->reject(std::errc::bad_address));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_TRUE(state->isRejected());
+    ASSERT_FALSE(state->isFulfilled());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify getValue() in pending state fails.
+TEST_F(PromiseStateTest, test_getValueInPendinglStateFails) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    std::shared_ptr<PromiseState::Value> fulfillValue;
+    ASSERT_FALSE(state->getValue(fulfillValue));
+}
+
+// Verify getValue() in rejected state fails.
+TEST_F(PromiseStateTest, test_getValueInRejectedStateFails) {
+    auto state = std::make_shared<PromiseState>(std::errc::invalid_argument);
+    ASSERT_TRUE(state);
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_FALSE(state->getValue(value));
+}
+
+// Verify getValue() in fulfilled state works.
+TEST_F(PromiseStateTest, test_createInFulfilledStateAndGetValue) {
+    auto state = std::make_shared<PromiseState>(std::make_shared<std::string>("data"));
+    ASSERT_TRUE(state);
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("data", *std::static_pointer_cast<const std::string>(value));
+}
+
+// Verify state is rejected when constructed with nullptr for value reference.
+TEST_F(PromiseStateTest, test_createFulfilledStateWithNullptrError) {
+    auto state = std::make_shared<PromiseState>(std::shared_ptr<std::string>());
+    ASSERT_TRUE(state);
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify state transition from pending to fulfilled.
+TEST_F(PromiseStateTest, test_fulfillFromPendingState) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    ASSERT_TRUE(state->resolve(std::make_shared<std::string>("test")));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_FALSE(state->isRejected());
+    ASSERT_TRUE(state->isFulfilled());
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Verify state transition from pending to rejected because bad value argument.
+TEST_F(PromiseStateTest, test_fulfillFromPendingStateWithNullptrError) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    ASSERT_TRUE(state->resolve(std::shared_ptr<std::string>()));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_TRUE(state->isRejected());
+    ASSERT_FALSE(state->isFulfilled());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify state transition from rejected to fulfilled fails.
+TEST_F(PromiseStateTest, test_fulfillFromRejectedStateFails) {
+    auto state = std::make_shared<PromiseState>(std::errc::invalid_argument);
+    ASSERT_TRUE(state);
+
+    ASSERT_FALSE(state->resolve(std::make_shared<std::string>("test")));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_TRUE(state->isRejected());
+    ASSERT_FALSE(state->isFulfilled());
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_FALSE(state->getValue(value));
+}
+
+// Verify state transition from fulfilled to fulfilled fails.
+TEST_F(PromiseStateTest, test_fulfillFromFulfilledStateFails) {
+    auto state = std::make_shared<PromiseState>(std::make_shared<std::string>("original"));
+    ASSERT_TRUE(state);
+
+    ASSERT_FALSE(state->resolve(std::make_shared<std::string>("modified")));
+
+    ASSERT_FALSE(state->isPending());
+    ASSERT_TRUE(state->isResolved());
+    ASSERT_FALSE(state->isRejected());
+    ASSERT_TRUE(state->isFulfilled());
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ("original", *static_cast<const std::string*>(value.get()));
+}
+
+// Verify consumer can be added in pending state, and it gets a notification when state is released.
+TEST_F(PromiseStateTest, test_addResultObserverInPendingStateAndStateIsReleased) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+
+    std::shared_ptr<PromiseState> state;
+    auto state2 = std::make_shared<PromiseState>();
+    {
+        EXPECT_CALL(*consumer, onFulfilled(_, _)).Times(0);
+        EXPECT_CALL(*consumer, onRejected(_, _)).Times(0);
+        EXPECT_CALL(*executor, executeMove(_)).Times(0);
+        EXPECT_CALL(*executor, executeRef(_)).Times(0);
+
+        state = std::make_shared<PromiseState>();
+        ASSERT_TRUE(state);
+        auto fn = std::bind(&ResultConsumerInterface::onFulfilled, consumer, _1, _2);
+        state->addResultConsumer(
+            state2,
+            executor,
+            std::bind(&ResultConsumerInterface::onFulfilled, consumer, _1, _2),
+            std::bind(&ResultConsumerInterface::onRejected, consumer, _1, _2));
+    }
+
+    std::function<void()> executorFn;
+    {
+        EXPECT_CALL(*executor, executeMove(_)).WillOnce(Invoke([&executorFn](std::function<void()>& fn) {
+            executorFn = std::move(fn);
+            return std::error_condition{};
+        }));
+        EXPECT_CALL(*consumer, onRejected(_, _)).Times(0);
+        state.reset();
+    }
+
+    ASSERT_TRUE(executorFn);
+    EXPECT_CALL(*consumer, onRejected(state2, std::error_condition(std::errc::broken_pipe))).Times(1);
+    executorFn();
+    ASSERT_TRUE(state2->isPending());
+}
+
+// Verify consumer can be added in pending state, and the reject reason is propagated to dependent state.
+TEST_F(PromiseStateTest, test_addResultObserverInPendingStateWithoutOnRejectedAndStateIsReleased) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+
+    std::shared_ptr<PromiseState> state;
+    auto state2 = std::make_shared<PromiseState>();
+    {
+        EXPECT_CALL(*consumer, onFulfilled(_, _)).Times(0);
+        EXPECT_CALL(*executor, executeMove(_)).Times(0);
+        EXPECT_CALL(*executor, executeRef(_)).Times(0);
+
+        state = std::make_shared<PromiseState>();
+        ASSERT_TRUE(state);
+        auto fn = std::bind(&ResultConsumerInterface::onFulfilled, consumer, _1, _2);
+        state->addResultConsumer(
+            state2, executor, std::bind(&ResultConsumerInterface::onFulfilled, consumer, _1, _2), nullptr);
+    }
+
+    std::function<void()> executorFn;
+    {
+        EXPECT_CALL(*executor, executeMove(_)).Times(0);
+        ASSERT_TRUE(state2->isPending());
+        state.reset();
+    }
+
+    ASSERT_TRUE(state2->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state2->getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::broken_pipe), rejectReason);
+}
+
+// Verify result observer get right notification on transition from pending to fulfilled.
+TEST_F(PromiseStateTest, test_addResultObserverInPendingStateWithFulfill) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    std::shared_ptr<PromiseState> state2;
+    std::shared_ptr<PromiseState::Value> value;
+    EXPECT_CALL(*consumer, onFulfilled(_, _))
+        .Times(1)
+        .WillOnce(Invoke(
+            [&value, &state2](
+                const std::shared_ptr<PromiseState>& state, const std::shared_ptr<PromiseState::Value>& userData) {
+                value = userData;
+                state2 = state;
+            }));
+    EXPECT_CALL(*consumer, onRejected(_, _)).Times(0);
+
+    // Add result consumer: make lambda to hold smart pointer to consumer which will be released if lambda is released.
+    state->addResultConsumer(
+        state2,
+        executor,
+        std::bind(&MockResultConsumer::onFulfilled, consumer, _1, _2),
+        std::bind(&MockResultConsumer::onRejected, consumer, _1, _2));
+    std::weak_ptr<MockResultConsumer> weakConsumer{consumer};
+
+    consumer.reset();
+    ASSERT_TRUE(weakConsumer.lock());
+
+    std::function<void()> handler;
+    EXPECT_CALL(*executor, executeMove(_)).WillOnce(Invoke([&handler](std::function<void()>& fn) {
+        handler = std::move(fn);
+        return std::error_condition{};
+    }));
+
+    state->resolve(std::make_shared<std::string>("test"));
+
+    ASSERT_TRUE(handler);
+    handler();
+    handler = nullptr;
+
+    ASSERT_TRUE(value);
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+    ASSERT_FALSE(weakConsumer.lock());
+    value.reset();
+
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_TRUE(value);
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Verify result observer get right notification on transition from pending to fulfilled for void type.
+TEST_F(PromiseStateTest, test_addResultObserverInPendingStateWithVoidFulfill) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    std::shared_ptr<PromiseState> state2;
+    std::shared_ptr<PromiseState::Value> value;
+
+    EXPECT_CALL(*consumer, onFulfilled(_, _))
+        .Times(1)
+        .WillOnce(Invoke(
+            [&value, &state2](
+                const std::shared_ptr<PromiseState>& state, const std::shared_ptr<PromiseState::Value>& userData) {
+                value = userData;
+                state2 = state;
+            }));
+    EXPECT_CALL(*consumer, onRejected(_, _)).Times(0);
+
+    state->addResultConsumer(
+        state2,
+        executor,
+        std::bind(&MockResultConsumer::onFulfilled, consumer, _1, _2),
+        std::bind(&MockResultConsumer::onRejected, consumer, _1, _2));
+    std::weak_ptr<MockResultConsumer> weakConsumer{consumer};
+
+    consumer.reset();
+    ASSERT_TRUE(weakConsumer.lock());
+
+    std::function<void()> handler;
+    EXPECT_CALL(*executor, executeMove(_)).WillOnce(Invoke([&handler](std::function<void()>& fn) {
+        handler = std::move(fn);
+        return std::error_condition{};
+    }));
+
+    ASSERT_TRUE(state->fulfillWithVoid());
+
+    ASSERT_TRUE(handler);
+    handler();
+    handler = nullptr;
+
+    ASSERT_FALSE(weakConsumer.lock());
+
+    // Void is not a nullptr.
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+}
+
+// Verify result observer get immediate notification when state is fulfilled.
+TEST_F(PromiseStateTest, test_addResultObserverInFulfilledStateImmediatelyExecutesObserver) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+    auto state = std::make_shared<PromiseState>(std::make_shared<std::string>("test"));
+
+    std::shared_ptr<PromiseState> state2;
+    std::shared_ptr<PromiseState::Value> value;
+
+    EXPECT_CALL(*consumer, onFulfilled(_, _))
+        .Times(1)
+        .WillOnce(Invoke(
+            [&value, &state2](
+                const std::shared_ptr<PromiseState>& state, const std::shared_ptr<PromiseState::Value>& userData) {
+                value = userData;
+                state2 = state;
+            }));
+    EXPECT_CALL(*consumer, onRejected(_, _)).Times(0);
+    std::function<void()> handler;
+    EXPECT_CALL(*executor, executeMove(_)).WillOnce(Invoke([&handler](std::function<void()>& fn) {
+        handler = std::move(fn);
+        return std::error_condition{};
+    }));
+
+    state->addResultConsumer(
+        state2,
+        executor,
+        std::bind(&MockResultConsumer::onFulfilled, consumer, _1, _2),
+        std::bind(&MockResultConsumer::onRejected, consumer, _1, _2));
+    std::weak_ptr<MockResultConsumer> weakConsumer{consumer};
+    consumer.reset();
+    ASSERT_TRUE(handler);
+    handler();
+    handler = nullptr;
+
+    ASSERT_FALSE(weakConsumer.lock());
+    ASSERT_EQ("test", *static_cast<const std::string*>(value.get()));
+}
+
+// Verify result observer get immediate notification when state is rejected.
+TEST_F(PromiseStateTest, test_addResultObserverInRejectedStateImmediatelyExecutesObserver) {
+    auto consumer = std::make_shared<MockResultConsumer>();
+    auto executor = std::make_shared<MockExecutorInterface>();
+    auto state = std::make_shared<PromiseState>(std::error_condition(std::errc::invalid_argument));
+
+    std::shared_ptr<PromiseState> state2;
+    std::error_condition rejectReason;
+    EXPECT_CALL(*consumer, onFulfilled(_, _)).Times(0);
+    EXPECT_CALL(*consumer, onRejected(_, _))
+        .Times(1)
+        .WillOnce(Invoke(
+            [&state2, &rejectReason](const std::shared_ptr<PromiseState>& state, const std::error_condition& error) {
+                state2 = state;
+                rejectReason = error;
+            }));
+    std::function<void()> handler;
+    EXPECT_CALL(*executor, executeMove(_)).WillOnce(Invoke([&handler](std::function<void()>& fn) {
+        handler = std::move(fn);
+        return std::error_condition{};
+    }));
+
+    state->addResultConsumer(
+        state2,
+        executor,
+        std::bind(&MockResultConsumer::onFulfilled, consumer, _1, _2),
+        std::bind(&MockResultConsumer::onRejected, consumer, _1, _2));
+    std::weak_ptr<MockResultConsumer> weakConsumer{consumer};
+
+    ASSERT_TRUE(handler);
+    consumer.reset();
+    handler();
+    handler = nullptr;
+
+    ASSERT_FALSE(weakConsumer.lock());
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+// Verify blocking wait works.
+TEST_F(PromiseStateTest, test_waitInPendingStateWithSetValue) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    std::thread thread{[&completed, state]() {
+        state->wait();
+        completed = true;
+    }};
+
+    state->resolve(std::shared_ptr<PromiseState::Value>());
+    thread.join();
+
+    ASSERT_TRUE(completed);
+}
+
+// Verify blocking wait for fulfilled objects works.
+TEST_F(PromiseStateTest, test_waitInFulfilledState) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    std::thread thread{[&completed, state]() {
+        state->wait();
+        completed = true;
+    }};
+
+    thread.join();
+
+    ASSERT_TRUE(completed);
+}
+
+// Verify blocking wait for pending objects times out (duration wait).
+TEST_F(PromiseStateTest, test_failedWaitInPendingStateWithDurationTimeout) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    bool waitResult = false;
+    std::thread thread{[&completed, &waitResult, state]() {
+        waitResult = state->waitFor(std::chrono::milliseconds(10));
+        completed = true;
+    }};
+
+    thread.join();
+
+    ASSERT_TRUE(completed);
+    ASSERT_FALSE(waitResult);
+}
+
+// Verify blocking wait for pending objects works.
+TEST_F(PromiseStateTest, test_waitInPendingStateWithDurationTimeout) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    bool waitResult = false;
+    std::chrono::steady_clock::duration duration;
+    std::thread thread{[&completed, &waitResult, state, &duration]() {
+        auto startTime = std::chrono::steady_clock::now();
+        waitResult = state->waitFor(std::chrono::milliseconds(100));
+        duration = std::chrono::steady_clock::now() - startTime;
+        completed = true;
+    }};
+    thread.join();
+
+    // The wait time should be not less than 100, but on multi-core hardware monothonic clock values may jump back for
+    // different cores. So we compare with a relatively small value to mitigate for race condition.
+    ASSERT_THAT(duration, Ge(std::chrono::milliseconds(10)));
+    ASSERT_TRUE(completed);
+    ASSERT_FALSE(waitResult);
+}
+
+// Verify blocking wait for pending objects times out (for time point wait).
+TEST_F(PromiseStateTest, test_failedWaitInPendingStateWithTimePointTimeout) {
+    auto state = std::make_shared<PromiseState>();
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    bool waitResult = false;
+    std::chrono::steady_clock::duration duration;
+    std::thread thread{[&completed, &waitResult, state, &duration]() {
+        auto startTime = std::chrono::steady_clock::now();
+        waitResult = state->waitUntil(std::chrono::steady_clock::now() + std::chrono::milliseconds(100));
+        duration = std::chrono::steady_clock::now() - startTime;
+        completed = true;
+    }};
+
+    thread.join();
+
+    ASSERT_TRUE(completed);
+    // The wait time should be not less than 100, but on multi-core hardware monothonic clock values may jump back for
+    // different cores. So we compare with a relatively small value to mitigate for race condition.
+    ASSERT_THAT(duration, Ge(std::chrono::milliseconds(10)));
+    ASSERT_FALSE(waitResult);
+}
+
+// Verify blocking wait for pending objects times out (for time point wait).
+TEST_F(PromiseStateTest, test_waitInFulfilledStateWithTimePointTimeout) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    ASSERT_TRUE(state);
+
+    bool completed = false;
+    bool waitResult = false;
+    std::chrono::steady_clock::duration duration;
+    std::thread thread{[&completed, &waitResult, state, &duration]() {
+        auto startTime = std::chrono::steady_clock::now();
+        waitResult = state->waitUntil(std::chrono::steady_clock::now() + std::chrono::milliseconds(10000));
+        duration = std::chrono::steady_clock::now() - startTime;
+        completed = true;
+    }};
+    thread.join();
+
+    ASSERT_THAT(duration, Le(std::chrono::milliseconds(10000)));
+    ASSERT_TRUE(completed);
+    ASSERT_TRUE(waitResult);
+}
+
+// Verify handle is not zero.
+TEST_F(PromiseStateTest, test_handleValue) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    ASSERT_NE(0u, state->getHandle());
+}
+
+// Verify fulfilled state is logged correctly.
+TEST_F(PromiseStateTest, test_logFulfilled) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    std::string message = logger::LogEntry("PromiseStateTest", "test").d("state", state).c_str();
+    EXPECT_THAT(message, HasSubstr("PromiseState("));
+    EXPECT_THAT(message, HasSubstr("/fulfilled)"));
+}
+
+// Verify rejected state is logged correctly.
+TEST_F(PromiseStateTest, test_logRejected) {
+    auto state = std::make_shared<PromiseState>(std::errc::invalid_argument);
+    std::string message = logger::LogEntry("PromiseStateTest", "test").d("state", state).c_str();
+    EXPECT_THAT(message, HasSubstr("state=PromiseState("));
+    EXPECT_THAT(message, HasSubstr("/rejected)"));
+}
+
+// Verify pending state is logged correctly.
+TEST_F(PromiseStateTest, test_logPending) {
+    auto state = std::make_shared<PromiseState>();
+    std::string message = logger::LogEntry("PromiseStateTest", "test").d("state", state).c_str();
+    EXPECT_THAT(message, HasSubstr("state=PromiseState("));
+    EXPECT_THAT(message, HasSubstr("/pending)"));
+}
+
+// Verify nullptr state is logged correctly.
+TEST_F(PromiseStateTest, test_logNullptr) {
+    std::shared_ptr<PromiseState> state;
+    std::string message = logger::LogEntry("PromiseStateTest", "test").d("state", state).c_str();
+    EXPECT_THAT(message, HasSubstr("state=PromiseState(nullptr)"));
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseTest.cpp b/AVSCommon/Utils/test/Threading/PromiseTest.cpp
new file mode 100644
index 00000000..dafddd2e
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseTest.cpp
@@ -0,0 +1,252 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/PromiseTestHelper.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for Promise type.
+ */
+class PromiseTest : public Test {};
+
+// Validate default constructor.
+TEST_F(PromiseTest, test_defaultConstructor) {
+    Promise<std::string> promise;
+
+    ASSERT_FALSE(promise.isValid());
+    ASSERT_FALSE(PromiseTestHelper::getState(promise));
+
+    ASSERT_FALSE(promise.isPending());
+    ASSERT_FALSE(promise.isResolved());
+    ASSERT_FALSE(promise.isFulfilled());
+    ASSERT_FALSE(promise.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(promise.getRejectReason(rejectReason));
+    std::string value;
+    ASSERT_FALSE(promise.getValue(value));
+}
+
+// Validate copy constructor for disconnected object.
+TEST_F(PromiseTest, test_copyConstructorDisconnected) {
+    Promise<std::string> promise1;
+    Promise<std::string> promise2(promise1);
+
+    // Post-construction state
+    ASSERT_FALSE(promise2.isValid());
+}
+
+// Validate constructed rejected promise for non-void type.
+TEST_F(PromiseTest, test_copyConstructorRejected) {
+    auto promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+    Promise<std::string> promise2(promise1);
+
+    // Post-construction state
+    ASSERT_EQ(PromiseTestHelper::getState(promise1), PromiseTestHelper::getState(promise2));
+    ASSERT_TRUE(promise2.isValid());
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_FALSE(promise2.isFulfilled());
+    ASSERT_TRUE(promise2.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    std::string value;
+    ASSERT_FALSE(promise2.getValue(value));
+}
+
+// Validate constructed fulfilled promise for non-void type.
+TEST_F(PromiseTest, test_copyConstructorFulfilled) {
+    auto promise1 = Promise<std::string>::resolveEmplace("test");
+    Promise<std::string> promise2(promise1);
+
+    // Post-construction state
+    ASSERT_EQ(PromiseTestHelper::getState(promise1), PromiseTestHelper::getState(promise2));
+    ASSERT_TRUE(promise2.isValid());
+
+    std::shared_ptr<PromiseState::Value> stateValue;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getValue(stateValue));
+    ASSERT_EQ("test", *static_cast<const std::string*>(stateValue.get()));
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_TRUE(promise2.isFulfilled());
+    ASSERT_FALSE(promise2.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(promise2.getRejectReason(rejectReason));
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Validate constructed fulfilled promise for void type.
+TEST_F(PromiseTest, test_copyConstructorVoidFulfilled) {
+    auto promise1 = Promise<void>::resolve();
+    Promise<void> promise2(promise1);
+
+    // Post-construction state
+    ASSERT_EQ(PromiseTestHelper::getState(promise1), PromiseTestHelper::getState(promise2));
+    ASSERT_TRUE(promise2.isValid());
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_TRUE(promise2.isFulfilled());
+    ASSERT_FALSE(promise2.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(promise2.getRejectReason(rejectReason));
+}
+
+// Validate move-constructed rejected promise for non-void type.
+TEST_F(PromiseTest, test_moveConstructorWithRejected) {
+    auto promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+    Promise<std::string> promise2(std::move(promise1));
+
+    // Post-construction state
+    ASSERT_FALSE(promise1.isValid());
+    ASSERT_TRUE(promise2.isValid());
+
+    ASSERT_FALSE(promise1.isPending());
+    ASSERT_FALSE(promise1.isResolved());
+    ASSERT_FALSE(promise1.isFulfilled());
+    ASSERT_FALSE(promise1.isRejected());
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_FALSE(promise2.isFulfilled());
+    ASSERT_TRUE(promise2.isRejected());
+
+    rejectReason.clear();
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    std::string value;
+    ASSERT_FALSE(promise2.getValue(value));
+}
+
+// Validate move-constructed fulfilled promise for non-void type.
+TEST_F(PromiseTest, test_moveConstructorWithFulfilled) {
+    auto promise1 = Promise<std::string>::resolveEmplace("test");
+    Promise<std::string> promise2(std::move(promise1));
+
+    // Post-construction state
+    ASSERT_FALSE(promise1.isValid());
+    ASSERT_TRUE(promise2.isValid());
+
+    ASSERT_FALSE(promise1.isPending());
+    ASSERT_FALSE(promise1.isResolved());
+    ASSERT_FALSE(promise1.isFulfilled());
+    ASSERT_FALSE(promise1.isRejected());
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_TRUE(promise2.isFulfilled());
+    ASSERT_FALSE(promise2.isRejected());
+
+    std::shared_ptr<PromiseState::Value> stateValue;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getValue(stateValue));
+    ASSERT_EQ("test", *static_cast<const std::string*>(stateValue.get()));
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(promise2.getRejectReason(rejectReason));
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Validate move-constructed fulfilled promise for void type.
+TEST_F(PromiseTest, test_moveConstructorWithFulfilledVoid) {
+    auto promise1 = Promise<void>::resolve();
+    Promise<void> promise2(std::move(promise1));
+
+    // Post-construction state
+    ASSERT_FALSE(promise1.isValid());
+    ASSERT_TRUE(promise2.isValid());
+
+    ASSERT_FALSE(promise1.isPending());
+    ASSERT_FALSE(promise1.isResolved());
+    ASSERT_FALSE(promise1.isFulfilled());
+    ASSERT_FALSE(promise1.isRejected());
+
+    ASSERT_FALSE(promise2.isPending());
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_TRUE(promise2.isFulfilled());
+    ASSERT_FALSE(promise2.isRejected());
+
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+
+    std::error_condition rejectReason;
+    ASSERT_FALSE(promise2.getRejectReason(rejectReason));
+}
+
+// Test std::swap operation
+TEST_F(PromiseTest, test_swap) {
+    auto promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+    auto promise2 = Promise<std::string>::reject(INVALID_ARGUMENT);
+
+    std::swap(promise1, promise2);
+
+    std::error_condition rejectReason1;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise1)->getRejectReason(rejectReason1));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason1);
+
+    std::error_condition rejectReason2;
+    ASSERT_TRUE(PromiseTestHelper::getState(promise2)->getRejectReason(rejectReason2));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason2);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenCatchTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenCatchTest.cpp
new file mode 100644
index 00000000..d17d3ac3
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenCatchTest.cpp
@@ -0,0 +1,519 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenCatchTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// @{
+/// Error codes for unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+/// @}
+
+/**
+ * @brief Test fixture for Promise::thenCatch() methods.
+ */
+class PromiseThenCatchTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::thenCatch() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onRejected
+     * handlers, or to invoke system handler to propagate fulfillment value.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor();
+
+    /**
+     * @brief Configures executor for promise thenCatch() value that is never called.
+     *
+     * Method prepares executor that should never be called.
+     */
+    void configureNeverCalledExecutor();
+
+    /**
+     * @brief Executor mock for Promise::thenCatch() methods.
+     *
+     * This executor is used to either invoke onRejected handler, or to invoke system handler to propagate fulfillment
+     * value.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief  Scheduled function from m_executor executor.
+     *
+     * This function contains either a user-supplied onRejected handler, or system handler for propagating fulfillment
+     * value.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenCatchTest::SetUp() {
+    // Executor for Promise::thenCatch().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenCatchTest::configureExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+}
+
+void PromiseThenCatchTest::configureNeverCalledExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerNotCalledWhenFulfilled) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool catchCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled](const std::error_condition&, PromiseResolver<std::string>) { catchCalled = true; });
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_FALSE(catchCalled);
+    std::string fulfillValue;
+    ASSERT_TRUE(promise2.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerNotCalledWhenVoidFulfilled) {
+    configureNeverCalledExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool catchCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled](const std::error_condition&, PromiseResolver<void>) { catchCalled = true; });
+
+    promise1Resolver.resolve();
+
+    ASSERT_FALSE(catchCalled);
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerFulfillsInScope) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool catchCalled = false;
+    std::error_condition rejectReason;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor,
+        [&catchCalled, &rejectReason](const std::error_condition& error, PromiseResolver<std::string> resolver) {
+            catchCalled = true;
+            rejectReason = error;
+            resolver.resolve("test");
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    std::string fulfillValue;
+    ASSERT_TRUE(promise2.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerFulfillsOutOfScope) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool catchCalled = false;
+    PromiseResolver<std::string> promise2Resolver;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor,
+        [&catchCalled, &promise2Resolver](const std::error_condition&, PromiseResolver<std::string> resolver) {
+            catchCalled = true;
+            promise2Resolver = std::move(resolver);
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_TRUE(promise2.isPending());
+    ASSERT_TRUE(promise2Resolver.isValid());
+
+    ASSERT_TRUE(promise2Resolver.resolve("test"));
+
+    std::string fulfillValue;
+    ASSERT_TRUE(promise2.getValue(fulfillValue));
+    ASSERT_EQ("test", fulfillValue);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerFulfillsVoidInScope) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool catchCalled = false;
+    std::error_condition rejectReason;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled, &rejectReason](const std::error_condition& error, PromiseResolver<void> resolver) {
+            catchCalled = true;
+            rejectReason = error;
+            resolver.resolve();
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerFulfillsVoidOutOfScope) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool catchCalled = false;
+    PromiseResolver<void> promise2Resolver;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled, &promise2Resolver](const std::error_condition&, PromiseResolver<void> resolver) {
+            catchCalled = true;
+            promise2Resolver = std::move(resolver);
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_TRUE(promise2.isPending());
+    ASSERT_TRUE(promise2Resolver.isValid());
+
+    promise2Resolver.resolve();
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerRejectsInScope) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool catchCalled = false;
+    std::error_condition rejectReason;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled, &rejectReason](const std::error_condition& error, PromiseResolver<void> resolver) {
+            catchCalled = true;
+            rejectReason = error;
+            resolver.reject(std::errc::bad_address);
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::bad_address), rejectReason);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerRejectsOutOfScope) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool catchCalled = false;
+    PromiseResolver<void> promise2Resolver;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled, &promise2Resolver](const std::error_condition&, PromiseResolver<void> resolver) {
+            catchCalled = true;
+            promise2Resolver = std::move(resolver);
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_TRUE(promise2.isPending());
+    ASSERT_TRUE(promise2Resolver.isValid());
+
+    promise2Resolver.reject(std::errc::bad_address);
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::bad_address), rejectReason);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchResultIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(nullptr, [](const std::error_condition&, PromiseResolver<std::string>) {});
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchResultIsRejectedOnNullValueHandlers) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(m_executor, nullptr);
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerNotExecutedForFulfilledPromise) {
+    configureNeverCalledExecutor();
+
+    auto promise1 = Promise<std::string>::resolve("test");
+
+    std::string resultValue;
+    bool catchCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&catchCalled](const std::error_condition&, PromiseResolver<std::string>) { catchCalled = true; });
+
+    ASSERT_FALSE(catchCalled);
+
+    ASSERT_TRUE(promise2.getValue(resultValue));
+    ASSERT_EQ("test", resultValue);
+}
+
+TEST_F(PromiseThenCatchTest, test_catchHandlerExecutedForRejectedPromise) {
+    configureExecutor();
+
+    auto promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition rejectReason;
+    bool catchCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor,
+        [&catchCalled, &rejectReason](const std::error_condition& error, PromiseResolver<std::string> resolver) {
+            catchCalled = true;
+            rejectReason = std::move(error);
+            resolver.resolve("test2");
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(catchCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(catchCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Promise can propagate value through a chain of operations.
+TEST_F(PromiseThenCatchTest, test_propagateValueThroughChain) {
+    configureNeverCalledExecutor();
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.thenCatch(
+            m_executor, [](const std::error_condition& rejectReason, PromiseResolver<std::size_t> resolver) {
+                resolver.reject(static_cast<std::errc>(rejectReason.value() + 1));
+            });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.resolve(0u);
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        ASSERT_TRUE(promiseStack[i].isFulfilled());
+        std::size_t value;
+        ASSERT_TRUE(promiseStack[i].getValue(value));
+        ASSERT_EQ(0u, value);
+    }
+}
+
+// Promise can propagate error through a chain of operations.
+TEST_F(PromiseThenCatchTest, test_propagateErrorThroughChain) {
+    auto executor = std::make_shared<MockExecutorInterface>();
+    std::list<std::function<void()>> operations;
+    EXPECT_CALL(*executor, executeMove(_))
+        .Times(100)
+        .WillRepeatedly(Invoke([&operations](std::function<void()>& operation) {
+            operations.push_back(std::move(operation));
+            return std::error_condition{};
+        }));
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.thenCatch(
+            executor, [](const std::error_condition& rejectReason, PromiseResolver<std::size_t> resolver) {
+                resolver.reject(static_cast<std::errc>(rejectReason.value() + 1));
+            });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    for (std::size_t i = 0u; i < 99u; ++i) {
+        ASSERT_EQ(1u, operations.size());
+
+        ASSERT_TRUE(promiseStack[i].isPending());
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+
+        auto operation = std::move(operations.front());
+        operations.pop_front();
+        operation();
+
+        ASSERT_TRUE(promiseStack[i].isRejected());
+        std::error_condition rejectReason;
+        ASSERT_TRUE(promiseStack[i].getRejectReason(rejectReason));
+        ASSERT_EQ(std::error_condition(static_cast<std::errc>(CUSTOM_ERROR.value() + i + 1)), rejectReason);
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+    }
+
+    ASSERT_EQ(1u, operations.size());
+    ASSERT_TRUE(promiseStack[99u].isPending());
+    auto operation = std::move(operations.front());
+    operations.pop_front();
+    operation();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(lastPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(static_cast<std::errc>(CUSTOM_ERROR.value() + 100)), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenCatchWithPromiseTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenCatchWithPromiseTest.cpp
new file mode 100644
index 00000000..c7d883a0
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenCatchWithPromiseTest.cpp
@@ -0,0 +1,529 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenCatchWithPromiseTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// Error value for use with unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/**
+ * @brief Test fixture for Promise::thenCatch() methods with handlers that return Promise.
+ */
+class PromiseThenCatchWithPromiseTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::thenCatch() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onRejected
+     * handlers, or to invoke system handler to propagate fulfillment value.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor() noexcept;
+
+    /**
+     * @brief Configures executor for promise thenCatch() value that is never called.
+     *
+     * Method prepares executor that should never be called.
+     */
+    void configureNeverCalledExecutor();
+
+    /**
+     * @brief Executor mock for Promise::thenCatch() methods.
+     *
+     * This executor is used to either invoke onRejected handler, or to invoke system handler to propagate fulfillment
+     * value.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief  Scheduled function from m_executor executor.
+     *
+     * This function contains either a user-supplied onRejected handler, or system handler for propagating fulfillment
+     * value.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenCatchWithPromiseTest::SetUp() {
+    // Executor for Promise::thenCatch().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenCatchWithPromiseTest::configureExecutor() noexcept {
+    // Store lambda on Promise::thenCatch() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+void PromiseThenCatchWithPromiseTest::configureNeverCalledExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+// Verify value is propagated.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchFulfillPropagatesValue) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(m_executor, [&onRejectedCalled](const std::error_condition& error) {
+        onRejectedCalled = true;
+        return std::get<0>(Promise<std::string>::__makePending());
+    });
+
+    ASSERT_TRUE(promise2.isPending());
+
+    // Resolve promise1
+    ASSERT_TRUE(promise1Resolver.resolve("test"));
+
+    ASSERT_FALSE(onRejectedCalled);
+    std::string promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ("test", promise2Value);
+}
+
+// Verify void result is propagated.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchFulfillPropagatesVoidValue) {
+    configureNeverCalledExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(m_executor, [&onRejectedCalled](const std::error_condition& rejectReason) {
+        onRejectedCalled = true;
+        return std::get<0>(Promise<void>::__makePending());
+    });
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2.isPending());
+
+    // Resolve promise1
+    ASSERT_TRUE(promise1Resolver.resolve());
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2.isResolved());
+}
+
+// Verify reject reason is called and can be converted into value.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchRejectResolvesWithValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+    std::error_condition promise1RejectReason;
+
+    Promise<std::string> promise2;
+    PromiseResolver<std::string> promise2Resolver;
+    std::tie(promise2, promise2Resolver) = Promise<std::string>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise3 = promise1.thenCatch(
+        m_executor, [&onRejectedCalled, &promise1RejectReason, &promise2](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            promise1RejectReason = rejectReason;
+            return promise2;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Reject promise1
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+    m_scheduledOperation = nullptr;
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise3.isResolved());
+
+    // Resolve promise2
+    ASSERT_TRUE(promise2Resolver.resolve("test"));
+
+    std::string promise3Value;
+    ASSERT_TRUE(promise3.getValue(promise3Value));
+    ASSERT_EQ("test", promise3Value);
+}
+
+// Verify result can be resolved with void value.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchRejectResolvesWithVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+    std::error_condition promise1RejectReason;
+
+    Promise<void> promise2;
+    PromiseResolver<void> promise2Resolver;
+    std::tie(promise2, promise2Resolver) = Promise<void>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise3 = promise1.thenCatch(
+        m_executor, [&onRejectedCalled, &promise1RejectReason, &promise2](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            promise1RejectReason = rejectReason;
+            return promise2;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Reject promise1
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+    m_scheduledOperation = nullptr;
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise3.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve());
+
+    ASSERT_TRUE(promise3.isFulfilled());
+}
+
+// Verify reject reason is called and can be converted into another error.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchRejectResolvesWithError) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+    std::error_condition promise1RejectReason;
+
+    Promise<std::string> promise2;
+    PromiseResolver<std::string> promise2Resolver;
+    std::tie(promise2, promise2Resolver) = Promise<std::string>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise3 = promise1.thenCatch(
+        m_executor, [&onRejectedCalled, &promise1RejectReason, &promise2](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            promise1RejectReason = rejectReason;
+            return promise2;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Reject promise1
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+    m_scheduledOperation = nullptr;
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise3.isResolved());
+
+    // Reject promise2
+    ASSERT_TRUE(promise2Resolver.reject(CUSTOM_ERROR));
+
+    std::error_condition promise3RejectReason;
+    ASSERT_TRUE(promise3.getRejectReason(promise3RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise3RejectReason);
+}
+
+// Verify reject reason is called and can be converted into another error.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchRejectResolvesWithErrorForVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::error_condition promise1RejectReason;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    Promise<void> promise2;
+    PromiseResolver<void> promise2Resolver;
+    std::tie(promise2, promise2Resolver) = Promise<void>::__makePending();
+
+    auto onRejectedCalled = false;
+
+    auto promise3 = promise1.thenCatch(
+        m_executor, [&onRejectedCalled, &promise1RejectReason, &promise2](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            promise1RejectReason = rejectReason;
+            return promise2;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Reject promise1
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(m_scheduledOperation);
+
+    m_scheduledOperation();
+    m_scheduledOperation = nullptr;
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise3.isResolved());
+
+    // Reject promise2
+    ASSERT_TRUE(promise2Resolver.reject(CUSTOM_ERROR));
+
+    std::error_condition promise3RejectReason;
+    ASSERT_TRUE(promise3.getRejectReason(promise3RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise3RejectReason);
+}
+
+// Verify result is rejected when executor is nullptr.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchResultIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(
+        nullptr, [](const std::error_condition& rejectReason) { return Promise<std::string>::resolve("test"); });
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Verify result is rejected when handler is nullptr.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchResultIsRejectedOnEmptyOnReject) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(m_executor, nullptr);
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Verify the value propagated if promise is fulfilled.
+TEST_F(PromiseThenCatchWithPromiseTest, test_composeValueHandlerExecutedForFulfilledPromise) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::resolve("test");
+
+    auto onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(m_executor, [&onRejectedCalled](const std::error_condition& error) {
+        onRejectedCalled = true;
+        return Promise<std::string>::reject(CUSTOM_ERROR);
+    });
+
+    ASSERT_FALSE(onRejectedCalled);
+
+    std::string promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ("test", promise2Value);
+}
+
+// Verify the handler is scheduled for execution if promise is rejected.
+TEST_F(PromiseThenCatchWithPromiseTest, test_thenCatchOnRejectedExecutedForRejectedPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    PromiseResolver<std::string> promise2Resolver;
+    std::error_condition promise1RejectReason;
+    auto onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor,
+        [&onRejectedCalled, &promise2Resolver, &promise1RejectReason](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            promise1RejectReason = std::move(rejectReason);
+            Promise<std::string> result;
+            std::tie(result, promise2Resolver) = Promise<std::string>::__makePending();
+            return result;
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+
+    // Resolve promise2
+    ASSERT_TRUE(promise2Resolver.resolve("test"));
+
+    std::string promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ("test", promise2Value);
+}
+
+// Promise can propagate value through a chain of operations.
+TEST_F(PromiseThenCatchWithPromiseTest, test_propagateValueThroughChain) {
+    configureNeverCalledExecutor();
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.thenCatch(m_executor, [](const std::error_condition& rejectReason) {
+            return Promise<std::size_t>::reject(static_cast<std::errc>(rejectReason.value() + 1));
+        });
+        promiseStack.push_back(lastPromise);
+    }
+
+    // Resolve promise1
+    ASSERT_TRUE(promise1Resolver.resolve(0u));
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        ASSERT_TRUE(promiseStack[i].isFulfilled());
+        std::size_t value;
+        ASSERT_TRUE(promiseStack[i].getValue(value));
+        ASSERT_EQ(0u, value);
+    }
+}
+
+// Promise can propagate error through a chain of operations.
+TEST_F(PromiseThenCatchWithPromiseTest, test_propagateErrorThroughChain) {
+    auto executor = std::make_shared<MockExecutorInterface>();
+    std::list<std::function<void()>> operations;
+    EXPECT_CALL(*executor, executeMove(_))
+        .Times(100)
+        .WillRepeatedly(Invoke([&operations](std::function<void()>& operation) {
+            operations.push_back(std::move(operation));
+            return std::error_condition{};
+        }));
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.thenCatch(executor, [](const std::error_condition& rejectReason) {
+            return Promise<std::size_t>::reject(static_cast<std::errc>(rejectReason.value() + 1));
+        });
+        promiseStack.push_back(lastPromise);
+    }
+
+    // Reject promise1.
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    for (std::size_t i = 0u; i < 99u; ++i) {
+        ASSERT_EQ(1u, operations.size());
+
+        ASSERT_TRUE(promiseStack[i].isPending());
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+
+        auto operation = std::move(operations.front());
+        operations.pop_front();
+        ASSERT_TRUE(operation);
+        operation();
+
+        ASSERT_TRUE(promiseStack[i].isRejected());
+        std::error_condition rejectReason;
+        ASSERT_TRUE(promiseStack[i].getRejectReason(rejectReason));
+        ASSERT_EQ(std::error_condition(static_cast<std::errc>(CUSTOM_ERROR.value() + i + 1)), rejectReason);
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+    }
+
+    ASSERT_EQ(1u, operations.size());
+    ASSERT_TRUE(promiseStack[99u].isPending());
+    auto operation = std::move(operations.front());
+    operations.pop_front();
+    ASSERT_TRUE(operation);
+    operation();
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(lastPromise.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(static_cast<std::errc>(CUSTOM_ERROR.value() + 100)), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenCatchWithValueTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenCatchWithValueTest.cpp
new file mode 100644
index 00000000..aab55070
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenCatchWithValueTest.cpp
@@ -0,0 +1,332 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenCatchWithValueTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// @{
+/// Error code to use with unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+/// @}
+
+/**
+ * @brief Test fixture for Promise::thenCatch() with handlers that return value.
+ */
+class PromiseThenCatchWithValueTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::thenCatch() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onRejected
+     * handlers, or to invoke system handler to propagate fulfillment value.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor() noexcept;
+
+    /**
+     * @brief Configures executor for promise thenCatch() value that is never called.
+     *
+     * Method prepares executor that should never be called.
+     */
+    void configureNeverCalledExecutor();
+
+    /**
+     * @brief Executor mock for Promise::thenCatch() methods.
+     *
+     * This executor is used to either invoke onRejected handler, or to invoke system handler to propagate fulfillment
+     * value.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief Scheduled function from m_executor executor.
+     *
+     * This function contains either a user-supplied onRejected handler, or system handler for propagating fulfillment
+     * value.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenCatchWithValueTest::SetUp() {
+    // Executor for Promise::thenCatch().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenCatchWithValueTest::configureExecutor() noexcept {
+    // Store lambda on Promise::thenCatch() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+void PromiseThenCatchWithValueTest::configureNeverCalledExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+// Verify value is propagated.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchFulfillPropagatesValue) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(m_executor, [&onRejectedCalled](const std::error_condition& error) {
+        onRejectedCalled = true;
+        return "test2";
+    });
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2.isPending());
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_FALSE(onRejectedCalled);
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Verify void result is propagated.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchFulfillPropagatesVoidValue) {
+    configureNeverCalledExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.thenCatch(
+        m_executor, [&onRejectedCalled](const std::error_condition& rejectReason) { onRejectedCalled = true; });
+
+    ASSERT_TRUE(promise2.isPending());
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.resolve();
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify reject reason is called and can be converted into value.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchRejectResolvesWithValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onRejectedCalled = false;
+    std::error_condition argRejectReason;
+
+    auto promise2 =
+        promise1.thenCatch(m_executor, [&onRejectedCalled, &argRejectReason](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            argRejectReason = rejectReason;
+            return "test";
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, argRejectReason);
+
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Verify reject reason is called and can be converted into void value.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchRejectResolvesWithVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool onRejectedCalled = false;
+    std::error_condition argRejectReason;
+
+    auto promise2 =
+        promise1.thenCatch(m_executor, [&onRejectedCalled, &argRejectReason](const std::error_condition& rejectReason) {
+            onRejectedCalled = true;
+            argRejectReason = rejectReason;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+    m_scheduledOperation = nullptr;
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, argRejectReason);
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify result is rejected when executor is nullptr.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchResultIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(nullptr, [](const std::error_condition& rejectReason) { return "test"; });
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition error;
+    ASSERT_TRUE(promise2.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify result is propagated when reject handler is empty.
+TEST_F(PromiseThenCatchWithValueTest, test_thenCatchResultIsRejectedWithEmptyHandler) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.thenCatch(m_executor, nullptr);
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition error;
+    ASSERT_TRUE(promise2.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify the handler is scheduled for execution if promise is fulfilled.
+TEST_F(PromiseThenCatchWithValueTest, test_thenResultIsFulfilledForFulfilledPromise) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::resolve("test");
+
+    bool onRejectedCalled = false;
+    auto promise2 = promise1.thenCatch(m_executor, [&onRejectedCalled](const std::error_condition& error) {
+        onRejectedCalled = true;
+        return "test2";
+    });
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2.isFulfilled());
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Verify the handler is scheduled for execution if promise is rejected.
+TEST_F(PromiseThenCatchWithValueTest, test_thenValueHandlerExecutedForRejectedPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition rejectReason;
+    bool onRejectedCalled = false;
+
+    auto promise2 =
+        promise1.thenCatch(m_executor, [&onRejectedCalled, &rejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            rejectReason = std::move(error);
+            return "test";
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+
+    std::string value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ("test", value);
+}
+
+// Verify when we async without an error handler the result is rejected.
+TEST_F(PromiseThenCatchWithValueTest, test_promise2PromiseRejectedWhenNoErrorHandler) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    auto promise2 = promise1.thenCatch(m_executor, Promise<std::string>::OnRejectedWithValue<std::string>{});
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(INVALID_ARGUMENT, rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenTest.cpp
new file mode 100644
index 00000000..c8b0f87e
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenTest.cpp
@@ -0,0 +1,519 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// Error code to use with unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/**
+ * @brief Test fixture for Promise type.
+ */
+class PromiseThenTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::then() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onFulfilled or
+     * onRejected handlers, or to invoke system handler to propagate reject reason when onRejected is empty.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     */
+    void configureExecutor() noexcept;
+
+    /**
+     * @brief Executor mock for Promise::then() methods.
+     *
+     * This executor is used to either invoke onFulfilled or onRejected handler, or to invoke system handler to
+     * propagate reject reason when onRejected is empty.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief  Scheduled function from m_executor executor.
+     *
+     * This function contains either a user-supplied onFulfilled, or onRejected, or system handler for propagating
+     * reject reason.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenTest::SetUp() {
+    // Executor for Promise::then().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenTest::configureExecutor() noexcept {
+    // Store lambda on Promise->then() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+}
+
+// Verify Promise::then() handler function gets the right call when parent promise is fulfilled.
+TEST_F(PromiseThenTest, test_PromiseThenGetsRightFulfillCall) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool thenAfterFulfillCalled = false;
+    bool thenAfterRejectCalled = false;
+    std::string promise1FulfillValue;
+    auto thenPromise = promise1.then<void>(
+        m_executor,
+        [&thenAfterFulfillCalled, &promise1FulfillValue](const std::string& value, PromiseResolver<void>) {
+            thenAfterFulfillCalled = true;
+            ACSDK_INFO(LX(__func__).m("Fulfilling thenPromise"));
+            promise1FulfillValue = value;
+        },
+        [&thenAfterRejectCalled](const std::error_condition&, PromiseResolver<void>) { thenAfterRejectCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Fulfill promise1
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Execute handler
+    m_scheduledOperation();
+
+    // Final state
+    ASSERT_TRUE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+    ASSERT_EQ("test", promise1FulfillValue);
+}
+
+// Verify Promise::then() handler function gets the right call when parent promise is fulfilled.
+TEST_F(PromiseThenTest, test_VoidPromiseThenGetsRightFulfillValue) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool thenAfterFulfillCalled = false;
+    bool thenAfterRejectCalled = false;
+    auto thenPromise = promise1.then<void>(
+        m_executor,
+        [&thenAfterFulfillCalled](PromiseResolver<void>) { thenAfterFulfillCalled = true; },
+        [&thenAfterRejectCalled](const std::error_condition&, PromiseResolver<void>) { thenAfterRejectCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Fulfill promise1
+    promise1Resolver.resolve();
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Execute handler
+    m_scheduledOperation();
+
+    // Final state
+    ASSERT_TRUE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+}
+
+// Verify Promise::then() handler function gets the right call when parent promise is rejected.
+TEST_F(PromiseThenTest, test_PromiseThenGetsRightRejectReason) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool thenAfterFulfillCalled = false;
+    bool thenAfterRejectCalled = false;
+    std::error_condition promise1RejectReason;
+    auto thenPromise = promise1.then<void>(
+        m_executor,
+        [&thenAfterFulfillCalled](const std::string& val, PromiseResolver<void>) { thenAfterFulfillCalled = true; },
+        [&thenAfterRejectCalled, &promise1RejectReason](const std::error_condition& error, PromiseResolver<void>) {
+            thenAfterRejectCalled = true;
+            promise1RejectReason = error;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Reject promise
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Execute handler
+    m_scheduledOperation();
+
+    // Final state
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_TRUE(thenAfterRejectCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+}
+
+// Verify Promise::then() handler function gets the right call when parent promise is rejected.
+TEST_F(PromiseThenTest, test_VoidPromiseThenGetsRightRejectReason) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool thenAfterFulfillCalled = false;
+    bool thenAfterRejectCalled = false;
+    std::error_condition promise1RejectReason;
+
+    auto thenPromise = promise1.then<void>(
+        m_executor,
+        [&thenAfterFulfillCalled](PromiseResolver<void>) { thenAfterFulfillCalled = true; },
+        [&thenAfterRejectCalled, &promise1RejectReason](const std::error_condition& error, PromiseResolver<void>) {
+            thenAfterRejectCalled = true;
+            promise1RejectReason = error;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Reject promise
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_FALSE(thenAfterRejectCalled);
+
+    // Execute handler
+    m_scheduledOperation();
+
+    // Final state
+    ASSERT_FALSE(thenAfterFulfillCalled);
+    ASSERT_TRUE(thenAfterRejectCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+}
+
+// Verify Promise::then() handler can fulfill void Promise::then() result.
+TEST_F(PromiseThenTest, test_PromiseThenFulfillsResult) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool thenAfterFulfillCalled = false;
+    bool thenAfterRejectCalled = false;
+    std::string thenInputValue;
+
+    auto thenPromise = promise1.then<std::string>(
+        m_executor,
+        [&](const std::string& val, PromiseResolver<std::string> resolver) {
+            thenAfterFulfillCalled = true;
+            thenInputValue = val;
+            resolver.resolve("test2");
+        },
+        [&](const std::error_condition&, PromiseResolver<std::string>) { thenAfterRejectCalled = true; });
+
+    ASSERT_TRUE(promise1.isPending());
+    ASSERT_TRUE(thenPromise.isPending());
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+    ASSERT_EQ("test", thenInputValue);
+
+    ASSERT_TRUE(thenPromise.isFulfilled());
+    std::string thenPromiseResult;
+    ASSERT_TRUE(thenPromise.getValue(thenPromiseResult));
+    ASSERT_EQ("test2", thenPromiseResult);
+}
+
+// Verify Promise::then() handler can fulfill void Promise::then() result.
+TEST_F(PromiseThenTest, test_PromiseThenFulfillsVoidResult) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    std::string thenInputValue;
+    auto thenPromise = promise1.then<void>(m_executor, [&](const std::string& val, PromiseResolver<void> resolver) {
+        ACSDK_INFO(LX(__func__).m("Fulfilling thenPromise"));
+        thenInputValue = val;
+        auto fulfilled = resolver.resolve();
+        ACSDK_INFO(LX(__func__).d("fulfilled", fulfilled));
+    });
+
+    ASSERT_TRUE(promise1.isPending());
+    ASSERT_TRUE(thenPromise.isPending());
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+    ASSERT_EQ("test", thenInputValue);
+
+    ASSERT_TRUE(thenPromise.isResolved());
+    ASSERT_TRUE(thenPromise.isFulfilled());
+    ASSERT_FALSE(thenPromise.isRejected());
+}
+
+// Verify Promise::then() handler can fulfill Promise::then() result with different type.
+TEST_F(PromiseThenTest, test_thenOtherResult) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    std::string thenInputValue;
+    auto thenPromise =
+        promise1.then<std::size_t>(m_executor, [&](const std::string& val, PromiseResolver<std::size_t> resolver) {
+            thenInputValue = val;
+            resolver.resolve(val.size());
+        });
+
+    ASSERT_TRUE(thenPromise.isPending());
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_EQ("test", thenInputValue);
+
+    ASSERT_TRUE(thenPromise.isFulfilled());
+
+    std::size_t thenPromiseResult;
+    ASSERT_TRUE(thenPromise.getValue(thenPromiseResult));
+    ASSERT_EQ(4u, thenPromiseResult);
+}
+
+// Verify Promise::then() handler can reject Promise::then() result with different type.
+TEST_F(PromiseThenTest, test_thenPromiseResultRejected) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto thenPromise =
+        promise1.then<std::size_t>(m_executor, [&](const std::string& val, PromiseResolver<std::size_t> resolver) {
+            resolver.reject(std::errc::invalid_argument);
+        });
+
+    promise1Resolver.resolve("test");
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(thenPromise.isRejected());
+
+    std::error_condition thenPromiseError;
+    ASSERT_TRUE(thenPromise.getRejectReason(thenPromiseError));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), thenPromiseError);
+}
+
+// Verify Promise::then() result can be rejected outside of handler scope.
+TEST_F(PromiseThenTest, test_thenResultRejectedOutsideOfHandler) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::size_t> thenPromiseResolver;
+    auto thenPromise =
+        promise1.then<std::size_t>(m_executor, [&](const std::string& val, PromiseResolver<std::size_t> resolver) {
+            thenPromiseResolver = std::move(resolver);
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(thenPromise.isPending());
+    ASSERT_TRUE(thenPromiseResolver.isValid());
+
+    ASSERT_TRUE(thenPromiseResolver.reject(std::errc::state_not_recoverable));
+
+    ASSERT_TRUE(thenPromise.isRejected());
+    std::error_condition thenPromiseError;
+    ASSERT_TRUE(thenPromise.getRejectReason(thenPromiseError));
+    ASSERT_EQ(std::error_condition(std::errc::state_not_recoverable), thenPromiseError);
+}
+
+// Promise can be converted to Promise<void> through Promise<T>::then().
+TEST_F(PromiseThenTest, test_alwaysVoidResult) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto thenPromise = promise1.then<void>(
+        m_executor, [&](const std::string& val, PromiseResolver<void> resolver) { resolver.resolve(); });
+    ASSERT_TRUE((std::is_same<Promise<void>, decltype(thenPromise)>::value));
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(thenPromise.isFulfilled());
+}
+
+// Promise can propagate value through a chain of operations.
+TEST_F(PromiseThenTest, test_propagateValueThroughChain) {
+    auto executor = std::make_shared<MockExecutorInterface>();
+    std::list<std::function<void()>> operations;
+    EXPECT_CALL(*executor, executeMove(_))
+        .Times(100)
+        .WillRepeatedly(Invoke([&operations](std::function<void()>& operation) {
+            operations.push_back(std::move(operation));
+            return std::error_condition{};
+        }));
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.then<std::size_t>(
+            executor, [](std::size_t value, PromiseResolver<std::size_t> resolver) { resolver.resolve(value + 1); });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.resolve(0u);
+
+    for (std::size_t i = 0u; i < 99u; ++i) {
+        ASSERT_EQ(1u, operations.size());
+
+        ASSERT_TRUE(promiseStack[i].isPending());
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+
+        auto operation = std::move(operations.front());
+        operations.pop_front();
+        operation();
+
+        ASSERT_TRUE(promiseStack[i].isFulfilled());
+        std::size_t value;
+        ASSERT_TRUE(promiseStack[i].getValue(value));
+        ASSERT_EQ(i + 1, value);
+        ASSERT_TRUE(promiseStack[i + 1].isPending());
+    }
+
+    ASSERT_EQ(1u, operations.size());
+    ASSERT_TRUE(promiseStack[99u].isPending());
+    auto operation = std::move(operations.front());
+    operations.pop_front();
+    operation();
+
+    std::size_t value;
+    ASSERT_TRUE(lastPromise.getValue(value));
+    ASSERT_EQ(100u, value);
+}
+
+// Promise can propagate error through a chain of operations.
+TEST_F(PromiseThenTest, test_propagateErrorThroughChain) {
+    auto executor = std::make_shared<MockExecutorInterface>();
+    // Executor should never be called, as reject reason is propagated directly between promise states when there is
+    // no onRejected handler.
+    EXPECT_CALL(*executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*executor, executeRef(_)).Times(0);
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.then<std::size_t>(
+            executor, [](std::size_t value, PromiseResolver<std::size_t> resolver) { resolver.resolve(value + 1); });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        ASSERT_TRUE(promiseStack[i].isRejected());
+        std::error_condition rejectReason;
+        ASSERT_TRUE(promiseStack[i].getRejectReason(rejectReason));
+        ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    }
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenWithPromiseTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenWithPromiseTest.cpp
new file mode 100644
index 00000000..f46ed9f0
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenWithPromiseTest.cpp
@@ -0,0 +1,865 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenWithPromiseTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace alexaClientSDK::threading::test;
+
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/**
+ * @brief Test fixture for Promise::then() methods with handlers that return Promise.
+ */
+class PromiseThenWithPromiseTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::then() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onFulfilled or
+     * onRejected handlers, or to invoke system handler to propagate reject reason when onRejected is empty.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor();
+
+    /**
+     * @brief Configures executor for promise then() value that is never called.
+     *
+     * Method prepares executor that should never be called.
+     */
+    void configureNeverCalledExecutor();
+
+    /**
+     * @brief Executor mock for Promise::then() methods.
+     *
+     * This executor is used to either invoke onFulfilled or onRejected handler, or to invoke system handler to
+     * propagate reject reason when onRejected is empty.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief  Scheduled function from m_catchExecutor executor.
+     *
+     * This function contains either a user-supplied onRejected handler, or system handler for propagating fulfillment
+     * value.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenWithPromiseTest::SetUp() {
+    // Executor for Promise::then().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenWithPromiseTest::configureExecutor() {
+    // Store lambda on Promise::then() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+void PromiseThenWithPromiseTest::configureNeverCalledExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+// Verify value type can be converted with onFulfilled handler.
+TEST_F(PromiseThenWithPromiseTest, test_thenValueResultToValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::string promise1Value;
+
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver, &promise1Value](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            promise1Value = value;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve("test"));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_EQ("test", promise1Value);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve(33u));
+
+    std::size_t promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ(33u, promise2Value);
+}
+
+// Verify onFulfilled handler can reject the result.
+TEST_F(PromiseThenWithPromiseTest, test_thenValueResultToError) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::string promise1Value;
+
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver, &promise1Value](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            promise1Value = value;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve("test"));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_EQ("test", promise1Value);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Reject promise2.
+    ASSERT_TRUE(promise2Resolver.reject(CUSTOM_ERROR));
+
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise2RejectReason);
+}
+
+// Verify onFulfilled handler can reject the result for void value type.
+TEST_F(PromiseThenWithPromiseTest, test_thenValueResultToVoid) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::string promise1Value;
+
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    PromiseResolver<void> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver, &promise1Value](const std::string& value) -> Promise<void> {
+            onFulfilledCalled = true;
+            promise1Value = value;
+            Promise<void> result;
+            std::tie(result, promise2Resolver) = Promise<void>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<void>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve("test"));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_EQ("test", promise1Value);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve());
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify onFulfilled handler can convert void to non-void.
+TEST_F(PromiseThenWithPromiseTest, test_thenVoidResultToValue) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver]() -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(promise2Resolver.isValid());
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve());
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(promise2Resolver.isValid());
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve(33u));
+
+    ASSERT_TRUE(promise2.isFulfilled());
+    std::size_t promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ(33u, promise2Value);
+}
+
+// Verify onFulfilled handler can reject result for void type.
+TEST_F(PromiseThenWithPromiseTest, test_thenVoidResultToError) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver]() -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve());
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Reject promise2.
+    ASSERT_TRUE(promise2Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise2RejectReason);
+}
+
+// Verify onFulfilled can provide eventual result of void type.
+TEST_F(PromiseThenWithPromiseTest, test_thenVoidResultToVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    PromiseResolver<void> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver]() {
+            onFulfilledCalled = true;
+            Promise<void> result;
+            std::tie(result, promise2Resolver) = Promise<void>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<void>::__makePending());
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Resolve promise1.
+    ASSERT_TRUE(promise1Resolver.resolve());
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve());
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify onRejected handler can resolve the result.
+TEST_F(PromiseThenWithPromiseTest, test_thenErrorResultToValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+    std::error_condition promise1RejectReason;
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            return Promise<std::size_t>();
+        },
+        [&onRejectedCalled, &promise2Resolver, &promise1RejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            promise1RejectReason = error;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    // Reject promise1.
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve(33u));
+
+    ASSERT_TRUE(promise2.isFulfilled());
+    std::size_t promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ(33u, promise2Value);
+}
+
+// Verify onRejected handler can reject the result.
+TEST_F(PromiseThenWithPromiseTest, test_thenErrorResultToError) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::error_condition promise1RejectReason;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            return Promise<std::size_t>();
+        },
+        [&promise2Resolver, &promise1RejectReason, &onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            promise1RejectReason = error;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(promise2Resolver.isValid());
+
+    // Reject promise1.
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Reject promise2.
+    ASSERT_TRUE(promise2Resolver.reject(std::errc::timed_out));
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::timed_out), promise2RejectReason);
+}
+
+// Verify onRejected handler can resolve with void value.
+TEST_F(PromiseThenWithPromiseTest, test_thenErrorResultToVoid) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::error_condition promise1RejectReason;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onRejectedCalled = false;
+    PromiseResolver<void> promise2Resolver;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onRejectedCalled](const std::string& value) {
+            onRejectedCalled = true;
+            return Promise<void>();
+        },
+        [&promise2Resolver, &promise1RejectReason](const std::error_condition& error) {
+            promise1RejectReason = error;
+            Promise<void> result;
+            std::tie(result, promise2Resolver) = Promise<void>::__makePending();
+            return result;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(promise2Resolver.isValid());
+
+    // Reject promise1.
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise2.isResolved());
+
+    // Resolve promise2.
+    ASSERT_TRUE(promise2Resolver.resolve());
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify a reject reason can be propagated to promise2 result if there is no error handler.
+TEST_F(PromiseThenWithPromiseTest, test_thenErrorResultPropagatesWithoutAnErrorHandler) {
+    configureNeverCalledExecutor();
+
+    // Original promise and resolver
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onFulfilledCalled = false;
+
+    auto promise2 = promise1.then<void>(m_executor, [&onFulfilledCalled](const std::string& value) {
+        onFulfilledCalled = true;
+        return Promise<void>();
+    });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+
+    // Reject promise1.
+    ASSERT_TRUE(promise1Resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise2RejectReason);
+}
+
+// Verify result is rejected when executor is nullptr.
+TEST_F(PromiseThenWithPromiseTest, test_thenResultIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.then<void>(
+        nullptr, [](const std::string& value) { return std::get<0>(Promise<void>::__makePending()); });
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Verify result is rejected when onFulfilled handler is empty.
+TEST_F(PromiseThenWithPromiseTest, test_thenResultIsRejectedWithEmptyOnFulfilled) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.then<void>(m_executor, Promise<std::string>::OnFulfilledWithPromise<void>{});
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Verify onFulfilled handler is scheduled for execution if promise is fulfilled.
+TEST_F(PromiseThenWithPromiseTest, test_thenValueHandlerExecutedForFulfilledPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::resolve("test");
+    std::string promise1Value;
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &promise2Resolver, &promise1Value](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            promise1Value = value;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+
+    ASSERT_FALSE(promise1Value.empty());
+    ASSERT_FALSE(promise2.isResolved());
+
+    ASSERT_TRUE(promise2Resolver.resolve(33u));
+
+    ASSERT_TRUE(promise2.isFulfilled());
+    std::size_t promise2Value;
+    ASSERT_TRUE(promise2.getValue(promise2Value));
+    ASSERT_EQ(33u, promise2Value);
+}
+
+// Verify onRejected handler is scheduled for execution if promise is rejected.
+TEST_F(PromiseThenWithPromiseTest, test_thenValueHandlerExecutedForRejectedPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+    std::error_condition promise1RejectReason;
+
+    PromiseResolver<std::size_t> promise2Resolver;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        },
+        [&onRejectedCalled, &promise2Resolver, &promise1RejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            promise1RejectReason = error;
+            Promise<std::size_t> result;
+            std::tie(result, promise2Resolver) = Promise<std::size_t>::__makePending();
+            return result;
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+    ASSERT_TRUE(promise2Resolver.isValid());
+    ASSERT_EQ(CUSTOM_ERROR, promise1RejectReason);
+    ASSERT_FALSE(promise2.isResolved());
+}
+
+// Verify result is rejected if promise1 is rejected without onRejected handler.
+TEST_F(PromiseThenWithPromiseTest, test_promise2PromiseRejectedWhenNoErrrorHandler) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition promise2RejectReason;
+    bool onFulfilledCalled = false;
+
+    auto promise2 =
+        promise1.then<std::size_t>(m_executor, [&onFulfilledCalled](const std::string&) -> Promise<std::size_t> {
+            onFulfilledCalled = true;
+            return std::get<0>(Promise<std::size_t>::__makePending());
+        });
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(promise2.isRejected());
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, promise2RejectReason);
+}
+
+// Verify result is rejected if onFulfilled is empty.
+TEST_F(PromiseThenWithPromiseTest, test_promise2PromiseRejectedWhenValueHandlerNull) {
+    // test for non-void type
+    auto promise1 = Promise<std::string>::resolve("").then<std::size_t>(m_executor, nullptr);
+
+    std::error_condition promise1RejectReason;
+    ASSERT_TRUE(promise1.getRejectReason(promise1RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise1RejectReason);
+
+    // test for void type
+    using OnFulfilledWithPromise = Promise<void>::OnFulfilledWithPromise<std::size_t>;
+    auto promise2 = Promise<void>::resolve().then<std::size_t>(m_executor, OnFulfilledWithPromise{});
+
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Verify when we compose without executor the result is rejected.
+TEST_F(PromiseThenWithPromiseTest, test_promise2PromiseRejectedWhenExecutorNull) {
+    // test for non-void type
+    auto promise1 = Promise<std::string>::resolve("").then<std::size_t>(m_executor, nullptr, nullptr);
+
+    std::error_condition promise1RejectReason;
+    ASSERT_TRUE(promise1.getRejectReason(promise1RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise1RejectReason);
+
+    // test for void type
+    using OnFulfilledWithPromise = Promise<void>::OnFulfilledWithPromise<std::size_t>;
+    auto promise2 = Promise<void>::resolve().then<std::size_t>(m_executor, OnFulfilledWithPromise{});
+
+    std::error_condition promise2RejectReason;
+    ASSERT_TRUE(promise2.getRejectReason(promise2RejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), promise2RejectReason);
+}
+
+// Promise can propagate value through a chain of operations.
+TEST_F(PromiseThenWithPromiseTest, test_propagateValueThroughChain) {
+    auto executor = std::make_shared<MockExecutorInterface>();
+    std::list<std::function<void()>> operations;
+    EXPECT_CALL(*executor, executeMove(_))
+        .Times(100)
+        .WillRepeatedly(Invoke([&operations](std::function<void()>& operation) {
+            operations.push_back(std::move(operation));
+            return std::error_condition{};
+        }));
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.then<std::size_t>(
+            executor, [](std::size_t value) { return Promise<std::size_t>::resolve(value + 1); });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.resolve(0u);
+
+    for (std::size_t i = 0u; i < 99u; ++i) {
+        ASSERT_EQ(1u, operations.size());
+
+        ASSERT_TRUE(promiseStack[i].isPending());
+        ASSERT_TRUE(promiseStack[i + 1u].isPending());
+
+        auto operation = std::move(operations.front());
+        operations.pop_front();
+        operation();
+
+        ASSERT_TRUE(promiseStack[i].isFulfilled());
+        std::size_t value;
+        ASSERT_TRUE(promiseStack[i].getValue(value));
+        ASSERT_EQ(i + 1u, value);
+        ASSERT_TRUE(promiseStack[i + 1u].isPending());
+    }
+
+    ASSERT_EQ(1u, operations.size());
+    ASSERT_TRUE(promiseStack[99u].isPending());
+    auto operation = std::move(operations.front());
+    operations.pop_front();
+    operation();
+
+    std::size_t value;
+    ASSERT_TRUE(lastPromise.getValue(value));
+    ASSERT_EQ(100u, value);
+}
+
+// Promise can propagate error through a chain of operations.
+TEST_F(PromiseThenWithPromiseTest, test_propagateErrorThroughChain) {
+    configureNeverCalledExecutor();
+
+    Promise<std::size_t> promise1;
+    PromiseResolver<std::size_t> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::size_t>::__makePending();
+
+    Promise<std::size_t> lastPromise = promise1;
+    std::vector<Promise<std::size_t>> promiseStack;
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        lastPromise = lastPromise.then<std::size_t>(
+            m_executor, [](std::size_t value) { return Promise<std::size_t>::resolve(value + 1); });
+        promiseStack.push_back(lastPromise);
+    }
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    for (std::size_t i = 0u; i < 100u; ++i) {
+        ASSERT_TRUE(promiseStack[i].isRejected());
+        std::error_condition rejectReason;
+        ASSERT_TRUE(promiseStack[i].getRejectReason(rejectReason));
+        ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    }
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseThenWithValueTest.cpp b/AVSCommon/Utils/test/Threading/PromiseThenWithValueTest.cpp
new file mode 100644
index 00000000..3a39bdc7
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseThenWithValueTest.cpp
@@ -0,0 +1,532 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/MockExecutorInterface.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseThenWithValueTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// Error code to use with unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/**
+ * @brief Test fixture for Promise::then() methods with handlers that return value.
+ */
+class PromiseThenWithValueTest : public Test {
+public:
+    /**
+     * @brief Create mocks.
+     */
+    void SetUp() override;
+
+protected:
+    /**
+     * @brief Configures executor for Promise::then() executor value.
+     *
+     * Framework uses executor to handle either fulfillment value or reject reason and either invoke onFulfilled or
+     * onRejected handlers, or to invoke system handler to propagate reject reason when onRejected is empty.
+     *
+     * The executor does not directly execute user-supplied function due to the following reasons:
+     * - We need to be able to validate object state before propagation occurs and after it.
+     * - Direct execution leads to recursion, and it goes against state machine expectations as ExecutorInterface
+     *   contract expects asynchronous execution.
+     *
+     * @see m_executor
+     * @see m_scheduledOperation
+     */
+    void configureExecutor() noexcept;
+
+    /**
+     * @brief Configures executor for promise then() value that is never called.
+     *
+     * Method prepares executor that should never be called.
+     */
+    void configureNeverCalledExecutor();
+
+    /**
+     * @brief Executor mock for Promise::then() methods.
+     *
+     * This executor is used to either invoke onFulfilled or onRejected handler, or to invoke system handler to
+     * propagate reject reason when onRejected is empty.
+     *
+     * @see m_scheduledOperation
+     */
+    std::shared_ptr<MockExecutorInterface> m_executor;
+
+    /**
+     * @brief  Scheduled function from m_executor call.
+     *
+     * This function contains either a user-supplied onFulfilled, or onRejected, or system handler for propagating
+     * reject reason.
+     */
+    std::function<void()> m_scheduledOperation;
+};
+
+void PromiseThenWithValueTest::SetUp() {
+    // Executor for Promise::then().
+    m_executor = std::make_shared<MockExecutorInterface>();
+}
+
+void PromiseThenWithValueTest::configureExecutor() noexcept {
+    // Store lambda on initExecutor->then() invocation.
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(1).WillOnce(Invoke([&](std::function<void()>& fn) {
+        m_scheduledOperation = std::move(fn);
+        return std::error_condition{};
+    }));
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+void PromiseThenWithValueTest::configureNeverCalledExecutor() {
+    EXPECT_CALL(*m_executor, executeMove(_)).Times(0);
+    EXPECT_CALL(*m_executor, executeRef(_)).Times(0);
+}
+
+// Verify the value can be converted into another value.
+TEST_F(PromiseThenWithValueTest, test_thenValueResultToValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    std::string resultValue;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &resultValue](const std::string& value) {
+            onFulfilledCalled = true;
+            resultValue = value;
+            return 492745u;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return 0u;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.resolve("test");
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_EQ("test", resultValue);
+
+    std::size_t value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ(492745u, value);
+}
+
+// Verify value can be converted into an void.
+TEST_F(PromiseThenWithValueTest, test_thenValueResultToVoid) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    std::string resultValue;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onFulfilledCalled, &resultValue](const std::string& value) {
+            onFulfilledCalled = true;
+            resultValue = value;
+        },
+        [&onRejectedCalled](const std::error_condition& error) { onRejectedCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.resolve("test");
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_EQ("test", resultValue);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify void can be converted into a value.
+TEST_F(PromiseThenWithValueTest, test_thenVoidResultToValue) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled]() {
+            onFulfilledCalled = true;
+            return 38472u;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return 0u;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.resolve();
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onRejectedCalled);
+    std::size_t value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ(38472u, value);
+}
+
+// Verify void can be converted into a void.
+TEST_F(PromiseThenWithValueTest, test_thenVoidResultToVoid) {
+    configureExecutor();
+
+    Promise<void> promise1;
+    PromiseResolver<void> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<void>::__makePending();
+
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onFulfilledCalled]() { onFulfilledCalled = true; },
+        [&onRejectedCalled](const std::error_condition& error) { onRejectedCalled = true; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.resolve();
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify an error can be converted into a value.
+TEST_F(PromiseThenWithValueTest, test_thenErrorResultToValue) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+    std::error_condition resultError;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) {
+            onFulfilledCalled = true;
+            return 0u;
+        },
+        [&onRejectedCalled, &resultError](const std::error_condition& error) {
+            onRejectedCalled = true;
+            resultError = error;
+            return 8372639u;
+        });
+
+    ASSERT_FALSE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+
+    ASSERT_EQ(CUSTOM_ERROR, resultError);
+
+    std::size_t value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ(8372639u, value);
+}
+
+// Verify  an error can be converted into void.
+TEST_F(PromiseThenWithValueTest, test_thenErrorResultToVoid) {
+    configureExecutor();
+
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onRejectedCalled = false;
+    std::error_condition resultError;
+
+    auto promise2 = promise1.then<void>(
+        m_executor,
+        [&onRejectedCalled](const std::string& value) { onRejectedCalled = true; },
+        [&resultError](const std::error_condition& error) { resultError = error; });
+
+    ASSERT_FALSE(m_scheduledOperation);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+    ASSERT_TRUE(m_scheduledOperation);
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onRejectedCalled);
+    ASSERT_EQ(CUSTOM_ERROR, resultError);
+
+    ASSERT_TRUE(promise2.isFulfilled());
+}
+
+// Verify a reject reason can be propagated to promise2 result if there is no error handler.
+TEST_F(PromiseThenWithValueTest, test_thenErrorResultPropagatesWithoutAnErrorHandler) {
+    configureNeverCalledExecutor();
+
+    // Original promise and resolver
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    bool onFulfilledCalled = false;
+
+    auto promise2 = promise1.then<void>(m_executor, [&onFulfilledCalled](const std::string& value) {
+        onFulfilledCalled = true;
+        return Promise<void>();
+    });
+
+    ASSERT_TRUE(promise2.isPending());
+    ASSERT_FALSE(onFulfilledCalled);
+
+    promise1Resolver.reject(CUSTOM_ERROR);
+
+    ASSERT_FALSE(onFulfilledCalled);
+
+    ASSERT_TRUE(promise2.isResolved());
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition error;
+    ASSERT_TRUE(promise2.getRejectReason(error));
+    ASSERT_EQ(CUSTOM_ERROR, error);
+}
+
+// Verify result is rejected when executor is nullptr.
+TEST_F(PromiseThenWithValueTest, test_thenResultIsRejectedOnNullExecutor) {
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.then<void>(
+        nullptr, [](const std::string& value) { return std::get<0>(Promise<void>::__makePending()); });
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition error;
+    ASSERT_TRUE(promise2.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify result is rejected when onFulfilled handler is empty.
+TEST_F(PromiseThenWithValueTest, test_thenResultIsRejectedOnEmptyValueHandler) {
+    configureNeverCalledExecutor();
+    Promise<std::string> promise1;
+    PromiseResolver<std::string> promise1Resolver;
+    std::tie(promise1, promise1Resolver) = Promise<std::string>::__makePending();
+
+    auto promise2 = promise1.then<void>(m_executor, Promise<std::string>::OnFulfilledWithValue<void>{});
+
+    ASSERT_TRUE(promise2.isRejected());
+    std::error_condition error;
+    ASSERT_TRUE(promise2.getRejectReason(error));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), error);
+}
+
+// Verify the handler is scheduled for execution if promise is fulfilled.
+TEST_F(PromiseThenWithValueTest, test_thenValueHandlerExecutedForFulfilledPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::resolve("test");
+
+    std::string resultValue;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled, &resultValue](const std::string& value) {
+            onFulfilledCalled = true;
+            resultValue = value;
+            return 999u;
+        },
+        [&onRejectedCalled](const std::error_condition& error) {
+            onRejectedCalled = true;
+            return 0u;
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_TRUE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    ASSERT_EQ("test", resultValue);
+
+    std::size_t value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ(999u, value);
+}
+
+// Verify the handler is scheduled for execution if promise is rejected.
+TEST_F(PromiseThenWithValueTest, test_thenValueHandlerExecutedForRejectedPromise) {
+    configureExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition rejectReason;
+    bool onFulfilledCalled = false;
+    bool onRejectedCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(
+        m_executor,
+        [&onFulfilledCalled](const std::string& value) {
+            onFulfilledCalled = true;
+            return 0u;
+        },
+        [&onRejectedCalled, &rejectReason](const std::error_condition& error) {
+            onRejectedCalled = true;
+            rejectReason = error;
+            return 87987897u;
+        });
+
+    ASSERT_TRUE(m_scheduledOperation);
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_FALSE(onRejectedCalled);
+
+    m_scheduledOperation();
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(onRejectedCalled);
+
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+    std::size_t value;
+    ASSERT_TRUE(promise2.getValue(value));
+    ASSERT_EQ(87987897u, value);
+}
+
+// Verify the result is rejected without onRejected handler if promise is rejected.
+TEST_F(PromiseThenWithValueTest, test_thenPromiseRejectedWhenNoErrorHandler) {
+    configureNeverCalledExecutor();
+
+    Promise<std::string> promise1 = Promise<std::string>::reject(CUSTOM_ERROR);
+
+    std::error_condition rejectReason;
+    bool onFulfilledCalled = false;
+
+    auto promise2 = promise1.then<std::size_t>(m_executor, [&onFulfilledCalled](const std::string&) {
+        onFulfilledCalled = true;
+        return 129458372u;
+    });
+
+    ASSERT_FALSE(onFulfilledCalled);
+    ASSERT_TRUE(promise2.isRejected());
+    ASSERT_TRUE(promise2.getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Verify the result is rejected if executor is nullptr.
+TEST_F(PromiseThenWithValueTest, test_thenPromiseRejectedWhenOnFulfilledEmpty) {
+    std::error_condition rejectReason;
+
+    using OnFulfilled1 = Promise<std::string>::OnFulfilledWithValue<std::size_t>;
+    auto promise21 = Promise<std::string>::resolve("").then<std::size_t>(m_executor, OnFulfilled1{});
+
+    ASSERT_TRUE(promise21.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+
+    using OnFulfilled2 = Promise<void>::OnFulfilledWithValue<std::size_t>;
+    auto promise22 = Promise<void>::resolve().then<std::size_t>(m_executor, OnFulfilled2{});
+
+    ASSERT_TRUE(promise22.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+}
+
+// Verify result is rejected if onFulfilled is empty and onRejected is not empty.
+TEST_F(PromiseThenWithValueTest, test_thenPromiseRejectedWhenOnFulfilledEmptyWithOnRejected) {
+    using OnRejected = Promise<std::string>::OnRejectedWithValue<std::size_t>;
+    using OnFulfilled = Promise<std::string>::OnFulfilledWithValue<std::size_t>;
+    OnRejected dummyOnRejected = [](const std::error_condition&) { return 1u; };
+
+    auto promise21 = Promise<std::string>::resolve("").then<std::size_t>(m_executor, OnFulfilled{}, dummyOnRejected);
+
+    std::error_condition rejectReason;
+    ASSERT_TRUE(promise21.getRejectReason(rejectReason));
+    ASSERT_EQ(std::error_condition(std::errc::invalid_argument), rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseTypeMembersTest.cpp b/AVSCommon/Utils/test/Threading/PromiseTypeMembersTest.cpp
new file mode 100644
index 00000000..a3d3165e
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseTypeMembersTest.cpp
@@ -0,0 +1,112 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+/**
+ * @brief Test fixture for Promise type member types.
+ *
+ * This test verifies that various type definitions do not cause build time issues.
+ */
+class PromiseTypeMembersTest : public Test {};
+
+// Verify type declarations are valid and compile for Promise<std::string>
+TEST_F(PromiseTypeMembersTest, test_ensureMembersAreValid) {
+    // Promise::Promise() init functions
+    Promise<std::string>::InitWithResolver initWithResolver;
+    Promise<std::string>::InitWithPromise initWithPromise;
+    Promise<std::string>::InitWithValue initWithValue;
+
+    // Promise::then() onFulfilled functions with resolver
+    Promise<std::string>::OnFulfilledWithResolver<std::string> thenOnFulfilledFunctionSameResultType;
+    Promise<std::string>::OnFulfilledWithResolver<std::size_t> thenOnFulfilledFunctionDifferentResultType;
+    Promise<std::string>::OnFulfilledWithResolver<void> thenOnFulfilledFunctionVoidResultType;
+
+    // Promise::then() and Promise::thenCatch() onRejected functions with resolver
+    Promise<std::string>::OnRejectedWithResolver<std::string> thenOnRejectedFunctionSameResultType;
+    Promise<std::string>::OnRejectedWithResolver<std::size_t> thenOnRejectedFunctionDifferentResultType;
+    Promise<std::string>::OnRejectedWithResolver<void> thenOnRejectedFunctionVoidResultType;
+
+    // Promise::compose() onFulfilled functions with Promise return
+    Promise<std::string>::OnFulfilledWithPromise<std::string> composeOnFulfilledFunctionSameResultType;
+    Promise<std::string>::OnFulfilledWithPromise<std::size_t> composeOnFulfilledFunctionDifferentResultType;
+    Promise<std::string>::OnFulfilledWithPromise<void> composeOnFulfilledFunctionVoidResultType;
+
+    // Promise::compose() and Promise::composeCatch() onRejected functions with Promise return
+    Promise<std::string>::OnRejectedWithPromise<std::string> composeOnRejectedFunctionSameResultType;
+    Promise<std::string>::OnRejectedWithPromise<std::size_t> composeOnRejectedFunctionDifferentResultType;
+    Promise<std::string>::OnRejectedWithPromise<void> composeOnRejectedFunctionVoidResultType;
+
+    // Promise::async() and Promise::asyncCatch() onRejected functions with value return
+    Promise<std::string>::OnRejectedWithValue<std::string> asyncOnRejectedFunctionSameResultType;
+    Promise<std::string>::OnRejectedWithValue<std::size_t> asyncOnRejectedFunctionDifferentResultType;
+    Promise<std::string>::OnRejectedWithValue<void> asyncOnRejectedFunctionVoidResultType;
+
+    // Promise::finally() onFulfilled and onRejected functions
+    Promise<std::string>::OnFulfilledFinally onFulfilledFinally;
+    Promise<std::string>::OnRejectedFinally onRejectedFinally;
+}
+
+// Verify type declarations are valid and compile for Promise<void>
+TEST_F(PromiseTypeMembersTest, test_ensureMembersAreValidForVoid) {
+    // Promise::Promise() init functions
+    Promise<void>::InitWithResolver initWithResolver;
+    Promise<void>::InitWithPromise initWithPromise;
+    Promise<void>::InitWithValue initWithValue;
+
+    // Promise::then() onFulfilled functions with resolver
+    Promise<void>::OnFulfilledWithResolver<std::string> thenOnFulfilledFunctionValueResultType;
+    Promise<void>::OnFulfilledWithResolver<void> thenOnFulfilledFunctionVoidResultType;
+
+    // Promise::then() and Promise::thenCatch() onRejected functions with resolver
+    Promise<void>::OnRejectedWithResolver<std::string> thenOnRejectedFunctionValueResultType;
+    Promise<void>::OnRejectedWithResolver<void> thenOnRejectedFunctionVoidResultType;
+
+    // Promise::then() onFulfilled functions with eventual return value
+    Promise<void>::OnFulfilledWithPromise<std::string> composeOnFulfilledFunctionValueResultType;
+    Promise<void>::OnFulfilledWithPromise<void> composeOnFulfilledFunctionVoidResultType;
+
+    // Promise::then() and Promise::thenCatch() onRejected functions with eventual return value
+    Promise<void>::OnRejectedWithPromise<std::string> composeOnRejectedFunctionValueResultType;
+    Promise<void>::OnRejectedWithPromise<void> composeOnRejectedFunctionVoidResultType;
+
+    // Promise::then() onFulfilled functions with return value
+    Promise<void>::OnFulfilledWithValue<std::string> asyncOnFulfilledFunctionValueResultType;
+    Promise<void>::OnFulfilledWithValue<void> asyncOnFulfilledFunctionVoidResultType;
+
+    // Promise::then() and Promise::thenCatch() onRejected functions with return value
+    Promise<void>::OnRejectedWithValue<std::string> asyncOnRejectedFunctionValueResultType;
+    Promise<void>::OnRejectedWithValue<void> asyncOnRejectedFunctionVoidResultType;
+
+    // Promise::finally() onFulfilled and onRejected functions
+    Promise<void>::OnFulfilledFinally onFulfilledFinally;
+    Promise<void>::OnRejectedFinally onRejectedFinally;
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseTypeTraitsEmplaceTest.cpp b/AVSCommon/Utils/test/Threading/PromiseTypeTraitsEmplaceTest.cpp
new file mode 100644
index 00000000..28c82f41
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseTypeTraitsEmplaceTest.cpp
@@ -0,0 +1,122 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <acsdk/Test/ObjectLifecycleCallCounter.h>
+#include <AVSCommon/Utils/Threading/Internal/PromiseTypeTraits.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+
+/**
+ * @brief Test fixture for PromiseTypeTraits type.
+ */
+class PromiseTypeTraitsEmplaceTest : public Test {
+public:
+protected:
+    using ArgType = alexaClientSDK::test::ObjectLifecycleCallCounter<0u>;
+    using ValueType = alexaClientSDK::test::ObjectLifecycleCallCounter<1u>;
+
+    void SetUp() override {
+        ArgType::resetCounters();
+        ValueType::resetCounters();
+    }
+};
+
+TEST_F(PromiseTypeTraitsEmplaceTest, test_emplaceNoArgs) {
+    auto value = PromiseTypeTraits<ValueType>::emplace();
+    EXPECT_EQ(1, ValueType::defaultConstructed);
+    EXPECT_EQ(0, ValueType::copyConstructed);
+    EXPECT_EQ(0, ValueType::moveConstructed);
+    EXPECT_EQ(0, ValueType::copyAssigned);
+    EXPECT_EQ(0, ValueType::moveAssigned);
+    EXPECT_EQ(0, ValueType::argCopyConstructed);
+    EXPECT_EQ(0, ValueType::argMoveConstructed);
+}
+
+TEST_F(PromiseTypeTraitsEmplaceTest, test_emplaceCopyConstructed) {
+    const ValueType value;
+    EXPECT_EQ(1, ValueType::defaultConstructed);
+    ValueType::resetCounters();
+
+    auto valueCopy = PromiseTypeTraits<ValueType>::emplace(value);
+    EXPECT_EQ(0, ValueType::defaultConstructed);
+    EXPECT_EQ(1, ValueType::copyConstructed);
+    EXPECT_EQ(0, ValueType::moveConstructed);
+    EXPECT_EQ(0, ValueType::copyAssigned);
+    EXPECT_EQ(0, ValueType::moveAssigned);
+    EXPECT_EQ(0, ValueType::argCopyConstructed);
+    EXPECT_EQ(0, ValueType::argMoveConstructed);
+}
+
+TEST_F(PromiseTypeTraitsEmplaceTest, test_emplaceMoveConstructed) {
+    ValueType value;
+    EXPECT_EQ(1, ValueType::defaultConstructed);
+    ValueType::resetCounters();
+
+    auto valueCopy = PromiseTypeTraits<ValueType>::emplace(std::move(value));
+    EXPECT_EQ(0, ValueType::defaultConstructed);
+    EXPECT_EQ(0, ValueType::copyConstructed);
+    EXPECT_EQ(1, ValueType::moveConstructed);
+    EXPECT_EQ(0, ValueType::copyAssigned);
+    EXPECT_EQ(0, ValueType::moveAssigned);
+    EXPECT_EQ(0, ValueType::argCopyConstructed);
+    EXPECT_EQ(0, ValueType::argMoveConstructed);
+}
+
+TEST_F(PromiseTypeTraitsEmplaceTest, test_emplaceArgCopyConstructed) {
+    const ArgType arg;
+    EXPECT_EQ(1, ArgType::defaultConstructed);
+    ArgType::resetCounters();
+
+    auto valueCopy = PromiseTypeTraits<ValueType>::emplace(ValueType::ArgConstructor(), arg);
+    EXPECT_EQ(0, ValueType::defaultConstructed);
+    EXPECT_EQ(0, ValueType::copyConstructed);
+    EXPECT_EQ(0, ValueType::moveConstructed);
+    EXPECT_EQ(0, ValueType::copyAssigned);
+    EXPECT_EQ(0, ValueType::moveAssigned);
+    EXPECT_EQ(1, ValueType::argCopyConstructed);
+    EXPECT_EQ(0, ValueType::argMoveConstructed);
+}
+
+TEST_F(PromiseTypeTraitsEmplaceTest, test_emplaceArgMoveConstructed) {
+    ArgType arg;
+    EXPECT_EQ(1, ArgType::defaultConstructed);
+    ArgType::resetCounters();
+
+    auto valueCopy = PromiseTypeTraits<ValueType>::emplace(ValueType::ArgConstructor(), std::move(arg));
+    EXPECT_EQ(0, ValueType::defaultConstructed);
+    EXPECT_EQ(0, ValueType::copyConstructed);
+    EXPECT_EQ(0, ValueType::moveConstructed);
+    EXPECT_EQ(0, ValueType::copyAssigned);
+    EXPECT_EQ(0, ValueType::moveAssigned);
+    EXPECT_EQ(0, ValueType::argCopyConstructed);
+    EXPECT_EQ(1, ValueType::argMoveConstructed);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/PromiseWaitTest.cpp b/AVSCommon/Utils/test/Threading/PromiseWaitTest.cpp
new file mode 100644
index 00000000..25a37a14
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/PromiseWaitTest.cpp
@@ -0,0 +1,239 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <thread>
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/PromiseTestHelper.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "PromiseWaitTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+using namespace ::alexaClientSDK::threading::test;
+
+/// @brief Error code for unit tests.
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+
+/// @{
+/// @brief Time interval for unit tests.
+static const std::chrono::milliseconds SHORT_DURATION_MS{10};
+static const std::chrono::minutes TEN_MINUTES{10};
+static const std::chrono::minutes ONE_MINUTE{1};
+/// @}
+
+/**
+ * @brief Test fixture for Promise type.
+ */
+class PromiseWaitTest : public Test {};
+
+/// @brief Validate blocking wait doesn't block for invalid objects.
+TEST_F(PromiseWaitTest, test_waitInInvalidState) {
+    Promise<std::string> promise;
+    ASSERT_FALSE(promise.isValid());
+
+    const auto testStartTime = std::chrono::steady_clock::now();
+
+    EXPECT_EQ(&promise, &promise.await());
+    EXPECT_EQ(&promise, &promise.awaitFor(TEN_MINUTES));
+    EXPECT_EQ(&promise, &promise.awaitUntil(testStartTime + TEN_MINUTES));
+
+    const auto testWaitTime = std::chrono::steady_clock::now() - testStartTime;
+
+    ASSERT_THAT(testWaitTime, Lt(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait unblocks when Promise is resolved.
+TEST_F(PromiseWaitTest, test_waitInPendingStateWithSetValue) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> resolver;
+    std::tie(promise, resolver) = Promise<std::string>::__makePending();
+
+    ASSERT_TRUE(promise.isValid());
+    ASSERT_TRUE(resolver.isValid());
+
+    auto completed = false;
+    std::thread thread{[&completed, &promise]() {
+        promise.await();
+        completed = true;
+    }};
+    resolver.resolveEmplace("test");
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_TRUE(completed);
+    ASSERT_THAT(waitTime, Lt(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait doesn't block when fulfilled.
+TEST_F(PromiseWaitTest, test_waitInFulfilledState) {
+    auto promise = Promise<std::string>::resolveEmplace("test");
+    ASSERT_TRUE(promise.isFulfilled());
+
+    auto completed = false;
+    std::thread thread{[&completed, &promise]() {
+        promise.await();
+        completed = true;
+    }};
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_TRUE(completed);
+    ASSERT_THAT(waitTime, Lt(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait doesn't block when rejected.
+TEST_F(PromiseWaitTest, test_waitInRejectedState) {
+    auto promise = Promise<std::string>::reject(CUSTOM_ERROR);
+    ASSERT_TRUE(promise.isRejected());
+
+    auto completed = false;
+    std::thread thread{[&completed, &promise]() {
+        promise.await();
+        completed = true;
+    }};
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_TRUE(completed);
+    ASSERT_THAT(waitTime, Lt(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait with duration times out.
+TEST_F(PromiseWaitTest, test_waitInPendingStateWithDurationTimeout) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> resolver;
+    std::tie(promise, resolver) = Promise<std::string>::__makePending();
+
+    auto completed = false;
+    auto waitResult = false;
+    std::thread thread{[&completed, &waitResult, &promise]() {
+        waitResult = &promise.awaitFor(SHORT_DURATION_MS) == &promise;
+        completed = true;
+    }};
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_TRUE(completed);
+    EXPECT_TRUE(waitResult);
+    ASSERT_THAT(waitTime, Lt(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait with duration unblocks when resolved.
+TEST_F(PromiseWaitTest, test_waitInPendingStateWithDuration) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> resolver;
+    std::tie(promise, resolver) = Promise<std::string>::__makePending();
+
+    auto completed = false;
+    auto waitResult = false;
+    std::chrono::steady_clock::duration duration;
+    std::thread thread{[&completed, &waitResult, &promise, &duration]() {
+        auto startTime = std::chrono::steady_clock::now();
+        waitResult = &promise.awaitFor(TEN_MINUTES) == &promise;
+        duration = std::chrono::steady_clock::now() - startTime;
+        completed = true;
+    }};
+
+    std::this_thread::sleep_for(SHORT_DURATION_MS);
+    resolver.resolveEmplace("test");
+
+    thread.join();
+
+    EXPECT_THAT(duration, Le(ONE_MINUTE));
+    EXPECT_TRUE(completed);
+    EXPECT_TRUE(waitResult);
+}
+
+/// @brief Validate blocking wait with time point times out.
+TEST_F(PromiseWaitTest, test_waitInPendingStateWithTimePointTimeout) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> resolver;
+    std::tie(promise, resolver) = Promise<std::string>::__makePending();
+
+    auto completed = false;
+    auto waitResult = false;
+    std::thread thread{[&completed, &waitResult, &promise]() {
+        waitResult = &promise.awaitUntil(std::chrono::steady_clock::now() + SHORT_DURATION_MS) == &promise;
+        completed = true;
+    }};
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_TRUE(completed);
+    EXPECT_TRUE(waitResult);
+    EXPECT_THAT(waitTime, Le(ONE_MINUTE));
+}
+
+/// @brief Validate blocking wait with time point unblocks when resolved.
+TEST_F(PromiseWaitTest, test_waitInPendingStateWithTimePoint) {
+    Promise<std::string> promise;
+    PromiseResolver<std::string> resolver;
+    std::tie(promise, resolver) = Promise<std::string>::__makePending();
+
+    auto completed = false;
+    auto waitResult = false;
+    std::chrono::steady_clock::duration duration;
+    std::thread thread{[&completed, &waitResult, &promise, &duration]() {
+        auto startTime = std::chrono::steady_clock::now();
+        waitResult = &promise.awaitUntil(std::chrono::steady_clock::now() + TEN_MINUTES) == &promise;
+        duration = std::chrono::steady_clock::now() - startTime;
+        completed = true;
+    }};
+
+    std::this_thread::sleep_for(SHORT_DURATION_MS);
+    resolver.resolveEmplace("test");
+
+    const auto waitStartTime = std::chrono::steady_clock::now();
+    thread.join();
+    const auto waitTime = std::chrono::steady_clock::now() - waitStartTime;
+
+    EXPECT_THAT(duration, Le(ONE_MINUTE));
+    EXPECT_TRUE(completed);
+    EXPECT_TRUE(waitResult);
+    EXPECT_THAT(waitTime, Le(ONE_MINUTE));
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/Threading/VoidPromiseResolverTest.cpp b/AVSCommon/Utils/test/Threading/VoidPromiseResolverTest.cpp
new file mode 100644
index 00000000..3be0dedc
--- /dev/null
+++ b/AVSCommon/Utils/test/Threading/VoidPromiseResolverTest.cpp
@@ -0,0 +1,220 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+
+#include <acsdk/Threading/Test/PromiseTestHelper.h>
+#include <AVSCommon/Utils/Threading/Promise.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "VoidPromiseResolverTest"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+namespace test {
+
+using namespace ::testing;
+
+/// @{
+/// @brief Error code constant for unit test.
+/// @private
+static const std::error_condition CUSTOM_ERROR{std::errc::network_down};
+static const std::error_condition INVALID_ARGUMENT{std::errc::invalid_argument};
+/// @}
+
+/**
+ * @brief Test fixture for PromiseResolver<void> type.
+ */
+class VoidPromiseResolverTest : public Test {};
+
+// Validate constructed resolver are not valid.
+TEST_F(VoidPromiseResolverTest, test_makeInvalid) {
+    PromiseResolver<void> resolver;
+
+    ASSERT_FALSE(resolver.isValid());
+    ASSERT_FALSE(PromiseTestHelper::getState(resolver));
+}
+
+// Validate constructed resolver are not valid for void type.
+TEST_F(VoidPromiseResolverTest, test_makeValid) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_TRUE(resolver.isValid());
+    ASSERT_TRUE(PromiseTestHelper::getState(resolver));
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver));
+}
+
+// Test copy constructor works for valid resolver
+TEST_F(VoidPromiseResolverTest, test_copyConstructorForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_TRUE(resolver1.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver1));
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy constructor works for invalid resolver
+TEST_F(VoidPromiseResolverTest, test_copyConstructorForInvalid) {
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test copy constructor works for valid resolver
+TEST_F(VoidPromiseResolverTest, test_moveConstructorForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2(std::move(resolver1));
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy constructor works for invalid resolver
+TEST_F(VoidPromiseResolverTest, test_moveConstructorForInvalid) {
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(resolver1);
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test copy assignment works for valid resolver
+TEST_F(VoidPromiseResolverTest, test_copyAssignmentForValid) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    PromiseResolver<void> resolver1(state);
+    PromiseResolver<void> resolver2;
+
+    resolver2 = resolver1;
+
+    ASSERT_TRUE(resolver1.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver1));
+    ASSERT_TRUE(resolver2.isValid());
+    ASSERT_EQ(state, PromiseTestHelper::getState(resolver2));
+}
+
+// Test copy assignment works for invalid resolver
+TEST_F(VoidPromiseResolverTest, test_copyAssignmentForInvalid) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<void> resolver1;
+    PromiseResolver<void> resolver2(state);
+
+    resolver2 = resolver1;
+
+    ASSERT_FALSE(resolver1.isValid());
+    ASSERT_FALSE(resolver2.isValid());
+}
+
+// Test resolve.
+TEST_F(VoidPromiseResolverTest, test_resolveVoid) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_TRUE(resolver.resolve());
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+}
+
+// Test resolve resolved.
+TEST_F(VoidPromiseResolverTest, test_resolveResolved) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_FALSE(resolver.resolve());
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+}
+
+// Test resolve rejected.
+TEST_F(VoidPromiseResolverTest, test_resolveRejected) {
+    auto state = std::make_shared<PromiseState>(CUSTOM_ERROR);
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_FALSE(resolver.resolve());
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test reject.
+TEST_F(VoidPromiseResolverTest, test_reject) {
+    auto state = std::make_shared<PromiseState>();
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_TRUE(resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+// Test reject rejected state.
+TEST_F(VoidPromiseResolverTest, test_rejectResolved) {
+    auto state = std::make_shared<PromiseState>(PromiseState::getVoidValue());
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_FALSE(resolver.reject(CUSTOM_ERROR));
+
+    ASSERT_TRUE(state->isFulfilled());
+    std::shared_ptr<PromiseState::Value> value;
+    ASSERT_TRUE(state->getValue(value));
+    ASSERT_EQ(PromiseState::getVoidValue(), value);
+}
+
+// Test reject rejected state.
+TEST_F(VoidPromiseResolverTest, test_rejectRejected) {
+    auto state = std::make_shared<PromiseState>(CUSTOM_ERROR);
+    PromiseResolver<void> resolver(state);
+
+    ASSERT_FALSE(resolver.reject(INVALID_ARGUMENT));
+
+    ASSERT_TRUE(state->isRejected());
+    std::error_condition rejectReason;
+    ASSERT_TRUE(state->getRejectReason(rejectReason));
+    ASSERT_EQ(CUSTOM_ERROR, rejectReason);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/test/WorkerThreadTest.cpp b/AVSCommon/Utils/test/WorkerThreadTest.cpp
index b7d595b0..0d6dd6a1 100644
--- a/AVSCommon/Utils/test/WorkerThreadTest.cpp
+++ b/AVSCommon/Utils/test/WorkerThreadTest.cpp
@@ -35,7 +35,6 @@ TEST(TaskThreadTest, test_runWorkSeveralTimes) {
     std::atomic_int count{0};
     WaitEvent waitEvent;
     WorkerThread workerThread;
-    EXPECT_TRUE(!workerThread.getMoniker().empty());
 
     for (int i = 1; i <= 10; i++) {
         waitEvent.reset();
diff --git a/AVSCommon/Utils/test/acsdk/Test/ObjectLifecycleCallCounter.h b/AVSCommon/Utils/test/acsdk/Test/ObjectLifecycleCallCounter.h
new file mode 100644
index 00000000..dacf6728
--- /dev/null
+++ b/AVSCommon/Utils/test/acsdk/Test/ObjectLifecycleCallCounter.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_TEST_OBJECTLIFECYCLECALLCOUNTER_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_TEST_OBJECTLIFECYCLECALLCOUNTER_H_
+
+#include <type_traits>
+
+namespace alexaClientSDK {
+namespace test {
+
+/**
+ * @brief Helper type to count number of constructor, assignment, and destructor invocations.
+ *
+ * This type counts number of calls to different operations for verifying r-value and l-value operations.
+ *
+ * @tparam index Object index for managing separate instances of call counters.
+ */
+template <std::size_t index = 0>
+struct ObjectLifecycleCallCounter {
+    /**
+     * @brief Moniker type for differentiating calls to copy/move/default constructor with calls with arguments.
+     */
+    struct ArgConstructor {};
+
+    /**
+     * @brief Default constructor.
+     *
+     * Method increments default constructor call counter.
+     */
+    ObjectLifecycleCallCounter() {
+        defaultConstructed++;
+    }
+
+    /**
+     * @brief Copy constructor.
+     *
+     * Method increments copy constructor call counter.
+     */
+    ObjectLifecycleCallCounter(const ObjectLifecycleCallCounter&) {
+        copyConstructed++;
+    }
+
+    /**
+     * @brief Move constructor.
+     *
+     * Method increments move constructor call counter.
+     */
+    ObjectLifecycleCallCounter(ObjectLifecycleCallCounter&&) {
+        moveConstructed++;
+    }
+
+    /**
+     * @brief Constructs object with argument.
+     *
+     * Method increments move argument constructor call counter.
+     *
+     * @tparam T Argument type.
+     */
+    template <typename T>
+    ObjectLifecycleCallCounter(ArgConstructor, T&&) {
+        argMoveConstructed++;
+    }
+
+    /**
+     * @brief Constructs object with argument.
+     *
+     * Method increments copy argument constructor call counter.
+     *
+     * @tparam T Argument type.
+     */
+    template <typename T>
+    ObjectLifecycleCallCounter(ArgConstructor, const T&) {
+        argCopyConstructed++;
+    }
+
+    /**
+     * @brief Destructor.
+     *
+     * Method increments destructor call counter.
+     */
+    ~ObjectLifecycleCallCounter() {
+        destroyed++;
+    }
+
+    /**
+     * @brief Copy assignment operation.
+     *
+     * Method increments copy assignment call counter.
+     *
+     * @return Reference to @a *this.
+     */
+    ObjectLifecycleCallCounter& operator=(const ObjectLifecycleCallCounter&) {
+        copyAssigned++;
+        return *this;
+    }
+
+    /**
+     * @brief Move assignment operation.
+     *
+     * Method increments move assignment call counter.
+     *
+     * @return Reference to @a *this.
+     */
+    ObjectLifecycleCallCounter& operator=(ObjectLifecycleCallCounter&&) {
+        moveAssigned++;
+        return *this;
+    }
+
+    /**
+     * @brief Set all call counters to zero.
+     */
+    static void resetCounters() {
+        defaultConstructed = 0;
+        copyConstructed = 0;
+        moveConstructed = 0;
+        argMoveConstructed = 0;
+        argCopyConstructed = 0;
+        copyAssigned = 0;
+        moveAssigned = 0;
+        destroyed = 0;
+    }
+
+    // @brief Number of calls to default constructor.
+    static int defaultConstructed;
+    // @brief Number of calls to copy constructor.
+    static int copyConstructed;
+    // @brief Number of calls to move constructor.
+    static int moveConstructed;
+    // @brief Number of calls to constructor that copies arguments.
+    static int argCopyConstructed;
+    // @brief Number of calls to constructor that moves arguments.
+    static int argMoveConstructed;
+    // @brief Number of calls to copy assignment operator.
+    static int copyAssigned;
+    // @brief Number of calls to move assignment operator.
+    static int moveAssigned;
+    // @brief Number of calls to destructor.
+    static int destroyed;
+};
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::defaultConstructed;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::copyConstructed;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::moveConstructed;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::argCopyConstructed;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::argMoveConstructed;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::copyAssigned;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::moveAssigned;
+
+template <std::size_t index>
+int ObjectLifecycleCallCounter<index>::destroyed;
+
+}  // namespace test
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_TEST_OBJECTLIFECYCLECALLCOUNTER_H_
diff --git a/AVSCommon/Utils/test/acsdk/Threading/Test/MockExecutorInterface.h b/AVSCommon/Utils/test/acsdk/Threading/Test/MockExecutorInterface.h
new file mode 100644
index 00000000..24c2745c
--- /dev/null
+++ b/AVSCommon/Utils/test/acsdk/Threading/Test/MockExecutorInterface.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_MOCKEXECUTORINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_MOCKEXECUTORINTERFACE_H_
+
+#include <gmock/gmock.h>
+
+#include <AVSCommon/Utils/Threading/ExecutorInterface.h>
+
+namespace alexaClientSDK {
+namespace threading {
+namespace test {
+
+/**
+ * @brief Mock object for ExecutorInterface.
+ */
+class MockExecutorInterface : public virtual avsCommon::utils::threading::ExecutorInterface {
+public:
+    /// @name Methods from ExecutorInterface
+    /// @{
+    std::error_condition execute(std::function<void()>&& function) noexcept final;
+    std::error_condition execute(const std::function<void()>& function) noexcept final;
+    /// @}
+
+    MOCK_METHOD1(executeMove, std::error_condition(std::function<void()>& function));
+    MOCK_METHOD1(executeRef, std::error_condition(const std::function<void()>& function));
+};
+
+inline std::error_condition MockExecutorInterface::execute(std::function<void()>&& function) noexcept {
+    return executeMove(function);
+}
+
+inline std::error_condition MockExecutorInterface::execute(const std::function<void()>& function) noexcept {
+    return executeRef(function);
+}
+
+}  // namespace test
+}  // namespace threading
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_MOCKEXECUTORINTERFACE_H_
diff --git a/AVSCommon/Utils/test/acsdk/Threading/Test/PromiseTestHelper.h b/AVSCommon/Utils/test/acsdk/Threading/Test/PromiseTestHelper.h
new file mode 100644
index 00000000..56b436e6
--- /dev/null
+++ b/AVSCommon/Utils/test/acsdk/Threading/Test/PromiseTestHelper.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_PROMISETESTHELPER_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_PROMISETESTHELPER_H_
+
+#include <AVSCommon/Utils/Threading/Promise.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace threading {
+
+/**
+ * @brief Helper class for unit tests.
+ */
+class PromiseTestHelper {
+public:
+    /**
+     * @brief Retrieve shared state object.
+     *
+     * @param[in] promise Promise object.
+     * @return Shared state reference or nullptr if @a promise is not valid.
+     */
+    static inline std::shared_ptr<PromiseState> getState(
+        const avsCommon::utils::threading::PromiseCommon& promise) noexcept {
+        return promise.m_state;
+    }
+
+    /**
+     * @brief Retrieve shared state object.
+     *
+     * @param[in] resolver Resolver object.
+     * @return Shared state reference or nullptr if @a resolver is not valid.
+     */
+    static inline std::shared_ptr<PromiseState> getState(
+        const avsCommon::utils::threading::PromiseResolverCommon& resolver) noexcept {
+        return resolver.m_state;
+    }
+};
+
+}  // namespace threading
+}  // namespace utils
+}  // namespace avsCommon
+
+namespace threading {
+namespace test {
+// Import PromiseTestHelper into alexaClientSDK::threading::test namespace.
+using avsCommon::utils::threading::PromiseTestHelper;
+}  // namespace test
+}  // namespace threading
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_TEST_ACSDK_THREADING_TEST_PROMISETESTHELPER_H_
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
index 2569e2d6..49246f20 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
@@ -48,11 +48,13 @@
 #include <AVSCommon/SDKInterfaces/ConnectionStatusObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/Diagnostics/DiagnosticsInterface.h>
 #include <AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/DoNotDisturbSettingObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/DefaultEndpointAnnotation.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointInterface.h>
 #include <AVSCommon/SDKInterfaces/ExpectSpeechTimeoutHandlerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h>
 #include <AVSCommon/SDKInterfaces/InternetConnectionMonitorInterface.h>
 #include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/PowerResourceManagerInterface.h>
@@ -113,6 +115,7 @@
 #include <RegistrationManager/RegistrationNotifierInterface.h>
 #include <RegistrationManager/RegistrationObserverInterface.h>
 #include <Settings/DeviceSettingsManager.h>
+#include <Settings/DoNotDisturbSettingObserverWrapper.h>
 #include <Settings/Storage/DeviceSettingStorageInterface.h>
 #include <SoftwareComponentReporter/SoftwareComponentReporterCapabilityAgent.h>
 #include <SpeakerManager/DefaultChannelVolumeFactory.h>
@@ -127,6 +130,11 @@
 #include <System/RevokeAuthorizationHandler.h>
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h"
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h"
+#endif
+
 #include "DefaultClient/ConnectionRetryTrigger.h"
 #include "DefaultClient/EqualizerRuntimeSetup.h"
 #include "DefaultClient/ExternalCapabilitiesBuilderInterface.h"
@@ -170,6 +178,9 @@ public:
             Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
         acsdkManufactory::
             Annotated<avsCommon::sdkInterfaces::VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
+        acsdkManufactory::Annotated<
+            avsCommon::sdkInterfaces::AudioFocusAnnotation,
+            avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::InternetConnectionMonitorInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface>,
@@ -230,6 +241,9 @@ public:
             Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
         acsdkManufactory::
             Annotated<avsCommon::sdkInterfaces::VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
+        acsdkManufactory::Annotated<
+            avsCommon::sdkInterfaces::AudioFocusAnnotation,
+            avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::InternetConnectionMonitorInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface>,
@@ -291,6 +305,10 @@ public:
      * @param softwareInfoSenderObserver Object to receive notifications about sending SoftwareInfo.
      * @param diagnostics Diagnostics interface which provides suite of APIs for diagnostic insight into SDK.
      * @param externalCapabilitiesBuilder Optional object used to build capabilities that are not included in the SDK.
+#ifdef MULTI_AGENT_EXPERIENCE
+     * @param universalDeviceCommandsInvoker Optional object used to build external capability for UniversalDeviceController.
+     * @param universalDeviceCommandsProvider Optional object used to build external capability for UniversalDeviceController.
+#endif
      * @param firstInteractionAudioProvider Optional object used in the first interaction started from
      * the alexa voice service
      * @return A @c std::unique_ptr to a DefaultClient if all went well or @c nullptr otherwise.
@@ -328,6 +346,12 @@ public:
             nullptr,
         std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics = nullptr,
         const std::shared_ptr<ExternalCapabilitiesBuilderInterface>& externalCapabilitiesBuilder = nullptr,
+#ifdef MULTI_AGENT_EXPERIENCE
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+            universalDeviceCommandsInvoker = nullptr,
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+            universalDeviceCommandsProvider = nullptr,
+#endif
         capabilityAgents::aip::AudioProvider firstInteractionAudioProvider =
             capabilityAgents::aip::AudioProvider::null());
 
@@ -405,6 +429,11 @@ of the @c ExpectSpeech directive's timeout. If provided, this function must rema
 AudioInputProcessor.
      * @param firstInteractionAudioProvider Optional object used in the first interaction started from
      * the alexa voice service
+#ifdef MULTI_AGENT_EXPERIENCE
+     * @param universalDeviceCommandsInvoker Optional object used to build external capability for UniversalDeviceController.
+     * @param universalDeviceCommandsProvider Optional object used to build external capability for UniversalDeviceController.
+#endif
+     * @param externalFocusMediator Optional External Focus Mediator.
      * @return A @c std::unique_ptr to a DefaultClient if all went well or @c nullptr otherwise.
      */
     static std::unique_ptr<DefaultClient> create(
@@ -489,7 +518,15 @@ AudioInputProcessor.
         const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>&
             expectSpeechTimeoutHandler = nullptr,
         capabilityAgents::aip::AudioProvider firstInteractionAudioProvider =
-            capabilityAgents::aip::AudioProvider::null());
+            capabilityAgents::aip::AudioProvider::null(),
+#ifdef MULTI_AGENT_EXPERIENCE
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+        universalDeviceCommandsInvoker = nullptr,
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+        universalDeviceCommandsProvider = nullptr,
+#endif
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator =
+            nullptr);
 
     /**
      * Connects the client to AVS. After this call, users can observe the state of the connection asynchronously by
@@ -664,6 +701,22 @@ AudioInputProcessor.
     void removeNotificationsObserver(
         std::shared_ptr<acsdkNotificationsInterfaces::NotificationsObserverInterface> observer);
 
+    /**
+     * Adds an observer to be notified of DoNotDisturbSetting changes.
+     *
+     * @param observer The observer to add.
+     */
+    void addDoNotDisturbSettingObserver(
+            std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> observer);
+
+    /**
+     * Removes an observer to be notified of DoNotDisturbSetting changes.
+     *
+     * @param observer The observer to remove.
+     */
+    void removeDoNotDisturbSettingObserver(
+            std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> observer);
+
     /**
      * Adds an observer to be notified of ExternalMediaPlayer changes
      *
@@ -716,7 +769,7 @@ AudioInputProcessor.
     void setCaptionMediaPlayers(
         const std::vector<std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface>>& mediaPlayers);
 
-    /*
+    /**
      * Get a reference to the PlaybackRouter
      *
      * @return shared_ptr to the PlaybackRouter.
@@ -1031,7 +1084,7 @@ AudioInputProcessor.
      */
     void disableVideo();
 
-    /*
+    /**
      * To be called when system clock is synchronized.
      */
     void onSystemClockSynchronized();
@@ -1112,6 +1165,10 @@ private:
      * @param softwareInfoSenderObserver Object to receive notifications about sending SoftwareInfo.
      * @param diagnostics Diagnostics interface that provides suite of APIs for insights into SDK.
      * @param externalCapabilitiesBuilder Object used to build capabilities that are not included in the SDK.
+#ifdef MULTI_AGENT_EXPERIENCE
+     * @param universalDeviceCommandsInvoker Optional object used to build external capability for UniversalDeviceController.
+     * @param universalDeviceCommandsProvider Optional object used to build external capability for UniversalDeviceController.
+#endif
      * @param firstInteractionAudioProvider Optional object used in the first interaction started from
      * the alexa voice service
      * @return Whether the SDK was initialized properly.
@@ -1147,6 +1204,12 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::SoftwareInfoSenderObserverInterface> softwareInfoSenderObserver,
         std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics,
         const std::shared_ptr<ExternalCapabilitiesBuilderInterface>& externalCapabilitiesBuilder,
+#ifdef MULTI_AGENT_EXPERIENCE
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+        universalDeviceCommandsInvoker,
+        const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+        universalDeviceCommandsProvider,
+#endif
         capabilityAgents::aip::AudioProvider firstInteractionAudioProvider);
 
     /// The directive sequencer.
@@ -1306,6 +1369,12 @@ private:
 
     /// The @c DeviceSetupInterface
     std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface> m_deviceSetup;
+
+    /// The map of observer objects to wrapper objects for DND, which facilitates removal of the correct observer,
+    /// when given a wrapper object, in @c removeDoNotDisturbSettingObserver.
+    std::unordered_map<
+        std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface>,
+        std::shared_ptr<settings::DoNotDisturbSettingObserverWrapper>> m_dndObserverMap;
 };
 
 }  // namespace defaultClient
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
index 0673c3c6..5e317332 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
@@ -44,6 +44,7 @@
 #include <AVSCommon/SDKInterfaces/ChannelVolumeFactoryInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/ExpectSpeechTimeoutHandlerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/HTTPContentFetcherInterfaceFactoryInterface.h>
 #include <AVSCommon/SDKInterfaces/InternetConnectionMonitorInterface.h>
@@ -110,6 +111,9 @@ using DefaultClientComponent = acsdkManufactory::Component<
         Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
     acsdkManufactory::
         Annotated<avsCommon::sdkInterfaces::VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::AudioFocusAnnotation,
+        avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
     std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface>,
     std::shared_ptr<avsCommon::sdkInterfaces::InternetConnectionMonitorInterface>,
     std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface>,
@@ -179,7 +183,8 @@ DefaultClientComponent getComponent(
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothStorageInterface>& bluetoothStorage,
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothDeviceConnectionRulesProviderInterface>&
         bluetoothConnectionRulesProvider,
-    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage);
+    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator);
 
 }  // namespace defaultClient
 }  // namespace alexaClientSDK
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/ExternalCapabilitiesBuilderInterface.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/ExternalCapabilitiesBuilderInterface.h
index 615a48c9..132db2d0 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/ExternalCapabilitiesBuilderInterface.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/ExternalCapabilitiesBuilderInterface.h
@@ -48,6 +48,11 @@
 #include <System/ReportStateHandler.h>
 #include <TemplateRuntime/TemplateRuntime.h>
 
+#ifdef MULTI_AGENT_EXPERIENCE
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h"
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h"
+#endif
+
 namespace alexaClientSDK {
 namespace defaultClient {
 /**
@@ -156,6 +161,10 @@ public:
      * @param commsMediaPlayer The media player to play Comms calling audio.
      * @param commsSpeaker The speaker to control volume of Comms calling audio.
      * @param sharedDataStream The stream to use which has the audio from microphone.
+#endif
+#ifdef MULTI_AGENT_EXPERIENCE
+     * @param universalDeviceCommandsInvoker Optional object used to build external capability for UniversalDeviceController.
+     * @param universalDeviceCommandsProvider Optional object used to build external capability for UniversalDeviceController.
 #endif
      * @param powerResourceManager Object to manage power resource.
      * @param softwareComponentReporter Object to report adapters' versions.
@@ -187,6 +196,12 @@ public:
         std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface> commsMediaPlayer,
         std::shared_ptr<avsCommon::sdkInterfaces::SpeakerInterface> commsSpeaker,
         std::shared_ptr<avsCommon::avs::AudioInputStream> sharedDataStream,
+#endif
+#ifdef MULTI_AGENT_EXPERIENCE
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>
+            universalDeviceCommandsInvoker,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>
+            universalDeviceCommandsProvider,
 #endif
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ComponentReporterInterface> softwareComponentReporter,
diff --git a/ApplicationUtilities/DefaultClient/src/CMakeLists.txt b/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
index 3ff75309..7804f013 100644
--- a/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
+++ b/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
@@ -66,6 +66,7 @@ target_link_libraries(DefaultClient
     acsdkAuthorization
     acsdkAuthorizationInterfaces)
 
+
 if (CAPTIONS)
     target_link_libraries(DefaultClient CaptionsLib)
 endif()
@@ -94,5 +95,9 @@ if (OPUS)
     target_link_libraries(DefaultClient OpusEncoderContext)
 endif()
 
+if (MULTI_AGENT_EXPERIENCE_ENABLED)
+    target_link_libraries(DefaultClient MultiAgentExperience-Alexa-Adapter)
+endif()
+
 # install target
 asdk_install()
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index e377a10f..e9813084 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -107,6 +107,12 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
     std::shared_ptr<avsCommon::sdkInterfaces::SoftwareInfoSenderObserverInterface> softwareInfoSenderObserver,
     std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics,
     const std::shared_ptr<ExternalCapabilitiesBuilderInterface>& externalCapabilitiesBuilder,
+#ifdef MULTI_AGENT_EXPERIENCE
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+    universalDeviceCommandsInvoker,
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+    universalDeviceCommandsProvider,
+#endif
     capabilityAgents::aip::AudioProvider firstInteractionAudioProvider) {
     std::unique_ptr<DefaultClient> defaultClient(new DefaultClient());
     if (!defaultClient->initialize(
@@ -136,6 +142,10 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
             softwareInfoSenderObserver,
             diagnostics,
             externalCapabilitiesBuilder,
+#ifdef MULTI_AGENT_EXPERIENCE
+            universalDeviceCommandsInvoker,
+            universalDeviceCommandsProvider,
+#endif
             firstInteractionAudioProvider)) {
         return nullptr;
     }
@@ -216,8 +226,14 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
     bool startAlertSchedulingOnInitialization,
     std::shared_ptr<alexaClientSDK::acl::MessageRouterFactoryInterface> messageRouterFactory,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    capabilityAgents::aip::AudioProvider firstInteractionAudioProvider) {
-
+    capabilityAgents::aip::AudioProvider firstInteractionAudioProvider,
+#ifdef MULTI_AGENT_EXPERIENCE
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+    universalDeviceCommandsInvoker,
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+    universalDeviceCommandsProvider,
+#endif
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator) {
     if (!equalizerRuntimeSetup) {
         equalizerRuntimeSetup = std::make_shared<defaultClient::EqualizerRuntimeSetup>(false);
     }
@@ -304,7 +320,8 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
         std::move(bluetoothDeviceManager),
         std::move(bluetoothStorage),
         bluetoothConnectionRulesProvider,
-        std::move(notificationsStorage));
+        std::move(notificationsStorage),
+        externalFocusMediator);
     auto manufactory = DefaultClientManufactory::create(component);
 
     auto speakerManager = manufactory->get<std::shared_ptr<SpeakerManagerInterface>>();
@@ -323,6 +340,7 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
     }
     startupManager->startup();
 
+    /// stored the default client unique_ptr into a variable before returning
     return create(
         std::move(manufactory),
         ringtoneMediaPlayer,
@@ -350,6 +368,10 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
         softwareInfoSenderObserver,
         diagnostics,
         externalCapabilitiesBuilder,
+#ifdef MULTI_AGENT_EXPERIENCE
+        universalDeviceCommandsInvoker,
+        universalDeviceCommandsProvider,
+#endif
         firstInteractionAudioProvider);
 }
 
@@ -384,6 +406,12 @@ bool DefaultClient::initialize(
     std::shared_ptr<avsCommon::sdkInterfaces::SoftwareInfoSenderObserverInterface> softwareInfoSenderObserver,
     std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics,
     const std::shared_ptr<ExternalCapabilitiesBuilderInterface>& externalCapabilitiesBuilder,
+#ifdef MULTI_AGENT_EXPERIENCE
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>&
+    universalDeviceCommandsInvoker,
+    const std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>&
+    universalDeviceCommandsProvider,
+#endif
     capabilityAgents::aip::AudioProvider firstInteractionAudioProvider) {
     if (!ringtoneMediaPlayer) {
         ACSDK_ERROR(LX("initializeFailed").d("reason", "nullRingtoneMediaPlayer"));
@@ -744,7 +772,11 @@ bool DefaultClient::initialize(
         firstInteractionAudioProvider,
         powerResourceManager,
         metricRecorder,
-        manufactory->get<std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>>());
+        manufactory->get<std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>>()
+#ifdef MULTI_AGENT_EXPERIENCE
+        , universalDeviceCommandsProvider
+#endif
+        );
 
     if (!m_audioInputProcessor) {
         ACSDK_ERROR(LX("initializeFailed").d("reason", "unableToCreateAudioInputProcessor"));
@@ -1107,6 +1139,10 @@ bool DefaultClient::initialize(
             commsMediaPlayer,
             commsSpeaker,
             sharedDataStream,
+#endif
+#ifdef MULTI_AGENT_EXPERIENCE
+            universalDeviceCommandsInvoker,
+            universalDeviceCommandsProvider,
 #endif
             powerResourceManager,
             m_softwareReporterCapabilityAgent,
@@ -1300,6 +1336,40 @@ void DefaultClient::removeNotificationsObserver(
     m_notificationsNotifier->removeObserver(observer);
 }
 
+void DefaultClient::addDoNotDisturbSettingObserver(
+    std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> observer) {
+
+    /// register an observer for "DO_NOT_DISTURB" setting if AVS SDK has been instantiated properly
+    auto doNotDisturbSettingsObserver = std::make_shared<settings::DoNotDisturbSettingObserverWrapper>(observer);
+
+    /// Save the wrapper that coresponds to the observer, so that it may be correctly removed in @c removeDoNotDisturbSettingObserver
+    m_dndObserverMap.insert({observer, doNotDisturbSettingsObserver});
+
+    m_deviceSettingsManager
+        ->getSetting<settings::DeviceSettingsIndex::DO_NOT_DISTURB>()
+        ->addObserver(doNotDisturbSettingsObserver);
+}
+
+void DefaultClient::removeDoNotDisturbSettingObserver(
+    std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> observer) {
+
+    if (m_dndObserverMap.find(observer) == m_dndObserverMap.end()) {
+        return;
+    }
+
+    using ObserverType = settings::SettingObserverInterface<settings::SettingInterface<bool>>;
+
+    // We need to explicitly use the type implemented by DoNotDisturbSettingObserverWrapper (which is ObserverType),
+    // since removeObserver accepts a reference to an observer.
+    std::shared_ptr<ObserverType> doNotDisturbSettingsObserver = m_dndObserverMap[observer];
+
+    m_deviceSettingsManager
+        ->getSetting<settings::DeviceSettingsIndex::DO_NOT_DISTURB>()
+        ->removeObserver(doNotDisturbSettingsObserver);
+
+    m_dndObserverMap.erase(observer);
+}
+
 void DefaultClient::addExternalMediaPlayerObserver(
     std::shared_ptr<acsdkExternalMediaPlayerInterfaces::ExternalMediaPlayerObserverInterface> observer) {
     m_externalMediaPlayer->addObserver(observer);
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
index 98bab7f4..82ad6e54 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
@@ -222,7 +222,8 @@ DefaultClientComponent getComponent(
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothStorageInterface>& bluetoothStorage,
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothDeviceConnectionRulesProviderInterface>&
         bluetoothConnectionRulesProvider,
-    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage) {
+    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator) {
     std::shared_ptr<avsCommon::utils::bluetooth::BluetoothEventBus> bluetoothEventBus;
     if (bluetoothDeviceManager) {
         bluetoothEventBus = bluetoothDeviceManager->getEventBus();
@@ -259,6 +260,7 @@ DefaultClientComponent getComponent(
         .addInstance(bluetoothEventBus)
         .addInstance(bluetoothStorage)
         .addInstance(notificationsStorage)
+        .addInstance(externalFocusMediator)
         .addRetainedFactory(getCreateApplicationAudioPipelineFactory(stubAudioPipelineFactory))
         .addRetainedFactory(getCreateDeviceSettingStorageInterface(deviceSettingStorage))
 
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/create_header.bash b/ApplicationUtilities/Resources/Audio/include/Audio/Data/create_header.bash
index 7e8ca9bc..ad1c51c0 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/create_header.bash
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/create_header.bash
@@ -16,21 +16,6 @@ GUARD=`echo "ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO
 CURR_YEAR=`date +"%Y"`
 
 cat <<EOF > "${FULL_OUTPUT}"
-/*
- * Copyright ${CURR_YEAR} Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
@@ -39,9 +24,9 @@ cat <<EOF > "${FULL_OUTPUT}"
  * Copyright ${CURR_YEAR} Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 EOF
 
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_01.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_01.mp3.h
index a600c5b2..131f2349 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_01.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_01.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_ALERTS_NOTIFICATION_01_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_02.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_02.mp3.h
index 824a9233..49d93463 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_02.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_02.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_ALERTS_NOTIFICATION_02_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_03.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_03.mp3.h
index 6550cae3..5f7b50da 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_03.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_alerts_notification_03.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_ALERTS_NOTIFICATION_03_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_connected.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_connected.mp3.h
index 3262f03e..b5c9d2de 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_connected.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_connected.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_COMMS_CALL_CONNECTED_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_disconnected.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_disconnected.mp3.h
index 47376150..64053797 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_disconnected.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_disconnected.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_COMMS_CALL_DISCONNECTED_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_incoming_ringtone.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_incoming_ringtone.mp3.h
index b113913e..301580da 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_incoming_ringtone.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_call_incoming_ringtone.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_COMMS_CALL_INCOMING_RINGTONE_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_drop_in_incoming.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_drop_in_incoming.mp3.h
index de8c7324..8d0f386f 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_drop_in_incoming.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_drop_in_incoming.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_COMMS_DROP_IN_INCOMING_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_outbound_ringtone.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_outbound_ringtone.mp3.h
index e8c9e4b1..0d47a1dc 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_outbound_ringtone.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_comms_outbound_ringtone.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_COMMS_OUTBOUND_RINGTONE_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_connected.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_connected.mp3.h
index 2f4ccd70..290b65de 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_connected.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_connected.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_STATE_BLUETOOTH_CONNECTED_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_disconnected.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_disconnected.mp3.h
index 7b1e21d0..7a4388d2 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_disconnected.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_bluetooth_disconnected.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_STATE_BLUETOOTH_DISCONNECTED_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_off.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_off.wav.h
index b612e56b..1cf654b4 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_off.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_off.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_STATE_PRIVACY_MODE_OFF_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_on.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_on.wav.h
index 2807f7aa..ce63d85f 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_on.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_state_privacy_mode_on.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_STATE_PRIVACY_MODE_ON_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01.mp3.h
index 5a98458b..ee502709 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_SYSTEM_ALERTS_MELODIC_01_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01_short.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01_short.wav.h
index a9cdc37a..d2dbdaa5 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01_short.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_01_short.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_SYSTEM_ALERTS_MELODIC_01_SHORT_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02.mp3.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02.mp3.h
index 8a9374b1..6211b25d 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02.mp3.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02.mp3.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_SYSTEM_ALERTS_MELODIC_02_MP3_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02_short.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02_short.wav.h
index 2fc368e6..3354b366 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02_short.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_system_alerts_melodic_02_short.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_SYSTEM_ALERTS_MELODIC_02_SHORT_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing.wav.h
index c91d9d2b..a3c27f6e 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_UI_ENDPOINTING_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing_touch.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing_touch.wav.h
index 53d8a84d..1677f1c0 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing_touch.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_endpointing_touch.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_UI_ENDPOINTING_TOUCH_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound.wav.h
index 25d5d389..4076e531 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_UI_WAKESOUND_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound_touch.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound_touch.wav.h
index e18bf167..4e3251b3 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound_touch.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_ui_wakesound_touch.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_UI_WAKESOUND_TOUCH_WAV_H_
diff --git a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_utility_500ms_blank.wav.h b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_utility_500ms_blank.wav.h
index 52365d07..12839fce 100644
--- a/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_utility_500ms_blank.wav.h
+++ b/ApplicationUtilities/Resources/Audio/include/Audio/Data/med_utility_500ms_blank.wav.h
@@ -1,29 +1,14 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
 /*
  * ******************
  * ALEXA AUDIO ASSETS
  * ******************
  *
- * Copyright 2019-2020 Amazon.com, Inc. or its affiliates ("Amazon").
+ * Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
  * All Rights Reserved.
  *
- * These materials are licensed to you as "Alexa Materials" under the Alexa Voice
- * Service Agreement, which is currently available at
- * https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/support/terms-and-agreements.
+ * These materials are licensed to you as “AVS Materials" under the Amazon
+ * Developer Services Agreement, which is currently available at
+ * https://developer.amazon.com/support/legal/da
  */
 
 #ifndef ALEXA_CLIENT_SDK_APPLICATIONUTILITIES_RESOURCES_AUDIO_INCLUDE_AUDIO_DATA_MED_UTILITY_500MS_BLANK_WAV_H_
diff --git a/BluetoothImplementations/BlueZ/src/BlueZBluetoothDevice.cpp b/BluetoothImplementations/BlueZ/src/BlueZBluetoothDevice.cpp
index 662cb4e1..998b662b 100644
--- a/BluetoothImplementations/BlueZ/src/BlueZBluetoothDevice.cpp
+++ b/BluetoothImplementations/BlueZ/src/BlueZBluetoothDevice.cpp
@@ -750,7 +750,7 @@ void BlueZBluetoothDevice::onPropertyChanged(const GVariantMapReader& changesMap
         initializeServices(uuids);
     }
 
-    m_executor.submit([this, pairedChanged, paired, connectedChanged, connected, aliasChanged, aliasStr] {
+    m_executor.execute([this, pairedChanged, paired, connectedChanged, connected, aliasChanged, aliasStr] {
         if (aliasChanged) {
             ACSDK_DEBUG5(LX("nameChanged").d("oldName", m_friendlyName).d("newName", aliasStr));
             m_friendlyName = aliasStr;
diff --git a/BluetoothImplementations/BlueZ/src/PulseAudioBluetoothInitializer.cpp b/BluetoothImplementations/BlueZ/src/PulseAudioBluetoothInitializer.cpp
index 1812af5e..1aecc94d 100644
--- a/BluetoothImplementations/BlueZ/src/PulseAudioBluetoothInitializer.cpp
+++ b/BluetoothImplementations/BlueZ/src/PulseAudioBluetoothInitializer.cpp
@@ -414,7 +414,7 @@ void PulseAudioBluetoothInitializer::onEventFired(const BluetoothEvent& event) {
         return;
     }
 
-    m_executor.submit([this] {
+    m_executor.execute([this] {
         if (!m_paLoopStarted) {
             m_paLoopStarted = true;
             run();
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index 57ba3563..fe7e580f 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -306,7 +306,7 @@ bool CapabilitiesDelegate::addOrUpdateEndpoint(
     }
 
     if (!m_currentDiscoveryEventSender) {
-        m_executor.submit([this] { executeSendPendingEndpoints(); });
+        m_executor.execute([this] { executeSendPendingEndpoints(); });
     }
 
     return true;
@@ -371,7 +371,7 @@ bool CapabilitiesDelegate::deleteEndpoint(
     }
 
     if (!m_currentDiscoveryEventSender) {
-        m_executor.submit([this] { executeSendPendingEndpoints(); });
+        m_executor.execute([this] { executeSendPendingEndpoints(); });
     }
 
     return true;
@@ -589,7 +589,7 @@ void CapabilitiesDelegate::onDiscoveryCompleted(
         addOrUpdateReportEndpointIdentifiers,
         deleteReportEndpointIdentifiers);
 
-    m_executor.submit([this] { executeSendPendingEndpoints(); });
+    m_executor.execute([this] { executeSendPendingEndpoints(); });
 }
 
 void CapabilitiesDelegate::onDiscoveryFailure(MessageRequestObserverInterface::Status status) {
@@ -735,7 +735,7 @@ void CapabilitiesDelegate::onConnectionStatusChanged(
     if (ConnectionStatusObserverInterface::Status::CONNECTED == status) {
         /// If newly connected, send Discovery events for any endpoints that may have been added or deleted
         /// during the post-connect stage.
-        m_executor.submit([this] { executeSendPendingEndpoints(); });
+        m_executor.execute([this] { executeSendPendingEndpoints(); });
     }
 }
 
diff --git a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
index e01cda88..fe6d6fea 100644
--- a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
+++ b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
@@ -21,6 +21,7 @@
 #include <memory>
 #include <unordered_map>
 #include <unordered_set>
+#include <utility>
 #include <vector>
 
 #include <AVSCommon/AVS/Attachment/InProcessAttachmentReader.h>
@@ -38,6 +39,7 @@
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/ExpectSpeechTimeoutHandlerInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
@@ -49,6 +51,7 @@
 #include <AVSCommon/SDKInterfaces/PowerResourceManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/SystemSoundPlayerInterface.h>
 #include <AVSCommon/SDKInterfaces/UserInactivityMonitorInterface.h>
+#include <AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h>
 #include <AVSCommon/Utils/AudioFormat.h>
 #include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <AVSCommon/Utils/RequiresShutdown.h>
@@ -159,6 +162,7 @@ public:
      * @param expectSpeechTimeoutHandler An optional interface that applications may provide to specify external
      * handling of the @c ExpectSpeech directive's timeout. If provided, this function must remain valid for the
      * lifetime of the @c AudioInputProcessor.
+     * @param universalDeviceCommandsProvider An optional provider of MultiAssistant.UniversalDeviceController state.
      * @return A @c std::shared_ptr to the new @c AudioInputProcessor instance.
      */
     static std::shared_ptr<AudioInputProcessor> create(
@@ -179,7 +183,8 @@ public:
         AudioProvider defaultAudioProvider = AudioProvider::null(),
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr,
-        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler = nullptr);
+        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler = nullptr,
+        const std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>& universalDeviceCommandsProvider = nullptr);
 
     /**
      * Adds an observer to be notified of AudioInputProcessor state changes.
@@ -282,7 +287,10 @@ public:
 
     /// @name ContextRequesterInterface Functions
     /// @{
-    void onContextAvailable(const std::string& jsonContext) override;
+    void onContextAvailable(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier &endpointId,
+                            const std::shared_ptr<avsCommon::avs::AVSContext>& endpointContext,
+                            avsCommon::sdkInterfaces::ContextRequestToken requestToken) override;
+
     void onContextFailure(const avsCommon::sdkInterfaces::ContextRequestError error) override;
     /// @}
 
@@ -436,7 +444,8 @@ private:
         std::shared_ptr<avsCommon::avs::CapabilityConfiguration> capabilitiesConfiguration,
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler);
+        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+        const std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>& universalDeviceCommandsProvider);
 
     /// @name RequiresShutdown Functions
     /// @{
@@ -571,7 +580,7 @@ private:
      *
      * @param jsonContext The full system context to send with the event.
      */
-    void executeOnContextAvailable(const std::string& jsonContext);
+    void executeOnContextAvailable(const std::shared_ptr<avsCommon::avs::AVSContext>& endpointContext);
 
     /**
      * This function is called when a context request fails.  Context requests are initiated by @c executeRecognize()
@@ -815,7 +824,27 @@ private:
      * or later sent by a call to @c executeOnFocusChanged().  This pointer is only valid during the @c RECOGNIZING
      * state after a call to @c executeRecognize(), and is reset after it is sent.
      */
-    std::shared_ptr<avsCommon::avs::MessageRequest> m_recognizeRequest;
+//    std::shared_ptr<avsCommon::avs::MessageRequest> m_recognizeRequest;
+
+    struct RecognizeRequestData {
+        RecognizeRequestData(
+            std::string name,
+            std::string dialogRequestId,
+            std::string payload,
+            std::shared_ptr<avsCommon::avs::AVSContext> context):
+                m_name{std::move(name)},
+                m_dialogRequestId{std::move(dialogRequestId)},
+                m_payload{std::move(payload)},
+                m_context{std::move(context)} {
+        }
+
+        std::string m_name;
+        std::string m_dialogRequestId;
+        std::string m_payload;
+        std::shared_ptr<avsCommon::avs::AVSContext> m_context;
+    };
+
+    std::shared_ptr<RecognizeRequestData> m_recognizeRequest;
 
     /// The @c MessageRequest for the most recent Recognize event sent with the @c MessageSender.
     std::shared_ptr<avsCommon::avs::MessageRequest> m_recognizeRequestSent;
@@ -897,6 +926,11 @@ private:
      */
     std::shared_ptr<ExpectSpeechTimeoutHandler> m_expectSpeechTimeoutHandler;
 
+    /**
+     * An optional provider of MultiAssitant.UniversalDeviceController state.
+     */
+    std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> m_universalDeviceCommandsProvider;
+
     /**
      * Temporary value of dialogRequestId generated when onRecognize starts. This should be cleared after being
      * passed to the directive sequencer.
@@ -967,6 +1001,13 @@ private:
      *     before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
+
+    avsCommon::sdkInterfaces::endpoints::EndpointIdentifier m_endpointId;
+
+    /**
+     * This keeps track of whether or not the wake tone should still be played for the current voice request.
+     */
+    bool m_shouldPlayWakeTone;
 };
 
 }  // namespace aip
diff --git a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
index d0944a00..48cb1e37 100644
--- a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
+++ b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
@@ -414,7 +414,8 @@ std::shared_ptr<AudioInputProcessor> AudioInputProcessor::create(
     AudioProvider defaultAudioProvider,
     std::shared_ptr<PowerResourceManagerInterface> powerResourceManager,
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler) {
+    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+    const std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>& universalDeviceCommandsProvider) {
     if (!directiveSequencer) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullDirectiveSequencer"));
         return nullptr;
@@ -479,7 +480,8 @@ std::shared_ptr<AudioInputProcessor> AudioInputProcessor::create(
         capabilitiesConfiguration,
         powerResourceManager,
         std::move(metricRecorder),
-        expectSpeechTimeoutHandler));
+        expectSpeechTimeoutHandler,
+        universalDeviceCommandsProvider));
 
     if (!aip->initialize()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "unableToInitialize"));
@@ -508,7 +510,7 @@ void AudioInputProcessor::addObserver(std::shared_ptr<ObserverInterface> observe
         ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
         return;
     }
-    m_executor.submit([this, observer]() { m_observers.insert(observer); });
+    m_executor.execute([this, observer]() { m_observers.insert(observer); });
 }
 
 void AudioInputProcessor::removeObserver(std::shared_ptr<ObserverInterface> observer) {
@@ -578,12 +580,15 @@ std::future<void> AudioInputProcessor::resetState() {
     return m_executor.submit([this]() { executeResetState(); });
 }
 
-void AudioInputProcessor::onContextAvailable(const std::string& jsonContext) {
-    m_executor.submit([this, jsonContext]() { executeOnContextAvailable(jsonContext); });
+void AudioInputProcessor::onContextAvailable(
+    const endpoints::EndpointIdentifier &endpointId,
+    const std::shared_ptr<AVSContext> &endpointContext,
+    ContextRequestToken requestToken) {
+    m_executor.execute([this, endpointContext]() { executeOnContextAvailable(endpointContext); });
 }
 
 void AudioInputProcessor::onContextFailure(const ContextRequestError error) {
-    m_executor.submit([this, error]() { executeOnContextFailure(error); });
+    m_executor.execute([this, error]() { executeOnContextFailure(error); });
 }
 
 void AudioInputProcessor::handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) {
@@ -650,11 +655,11 @@ void AudioInputProcessor::onDeregistered() {
 
 void AudioInputProcessor::onFocusChanged(avsCommon::avs::FocusState newFocus, avsCommon::avs::MixingBehavior behavior) {
     ACSDK_DEBUG9(LX("onFocusChanged").d("newFocus", newFocus).d("MixingBehavior", behavior));
-    m_executor.submit([this, newFocus]() { executeOnFocusChanged(newFocus); });
+    m_executor.execute([this, newFocus]() { executeOnFocusChanged(newFocus); });
 }
 
 void AudioInputProcessor::onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
-    m_executor.submit([this, newState]() { executeOnDialogUXStateChanged(newState); });
+    m_executor.execute([this, newState]() { executeOnDialogUXStateChanged(newState); });
 }
 
 AudioInputProcessor::AudioInputProcessor(
@@ -675,7 +680,8 @@ AudioInputProcessor::AudioInputProcessor(
     std::shared_ptr<avsCommon::avs::CapabilityConfiguration> capabilitiesConfiguration,
     std::shared_ptr<PowerResourceManagerInterface> powerResourceManager,
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler) :
+    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+    const std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>& universalDeviceCommandsProvider) :
         CapabilityAgent{NAMESPACE, exceptionEncounteredSender},
         RequiresShutdown{"AudioInputProcessor"},
         m_metricRecorder{metricRecorder},
@@ -702,6 +708,7 @@ AudioInputProcessor::AudioInputProcessor(
         m_wakeWordsSetting{wakeWordsSetting},
         m_powerResourceManager{powerResourceManager},
         m_expectSpeechTimeoutHandler{expectSpeechTimeoutHandler},
+        m_universalDeviceCommandsProvider{universalDeviceCommandsProvider},
         m_timeSinceLastResumeMS{std::chrono::milliseconds(0)},
         m_timeSinceLastPartialMS{std::chrono::milliseconds(0)},
         m_resourceFlags{0},
@@ -868,7 +875,7 @@ std::future<bool> AudioInputProcessor::expectSpeechTimedOut() {
 
 void AudioInputProcessor::handleStopCaptureDirective(std::shared_ptr<DirectiveInfo> info) {
     m_stopCaptureReceivedTime = steady_clock::now();
-    m_executor.submit([this, info]() {
+    m_executor.execute([this, info]() {
         bool stopImmediately = true;
         executeStopCapture(stopImmediately, info);
     });
@@ -895,7 +902,7 @@ void AudioInputProcessor::handleExpectSpeechDirective(std::shared_ptr<DirectiveI
         return;
     }
 
-    m_executor.submit([this, timeout, info]() { executeExpectSpeech(milliseconds{timeout}, info); });
+    m_executor.execute([this, timeout, info]() { executeExpectSpeech(milliseconds{timeout}, info); });
 }
 
 void AudioInputProcessor::handleSetEndOfSpeechOffsetDirective(std::shared_ptr<DirectiveInfo> info) {
@@ -1104,9 +1111,14 @@ bool AudioInputProcessor::executeRecognize(
             return false;
     }
 
-    if (settings::WakeWordConfirmationSettingType::TONE == m_wakeWordConfirmation->get()) {
-        m_executor.submit(
-            [this]() { m_systemSoundPlayer->playTone(SystemSoundPlayerInterface::Tone::WAKEWORD_NOTIFICATION); });
+    // Capture whether or not the play tone should be played for this request.
+    m_shouldPlayWakeTone = settings::WakeWordConfirmationSettingType::TONE == m_wakeWordConfirmation->get();;
+
+    if (m_focusState == avsCommon::avs::FocusState::FOREGROUND && m_shouldPlayWakeTone) {
+        // If already in the foreground just play the wake tone.
+        m_shouldPlayWakeTone = false;
+        m_executor.execute(
+            [this]() {m_systemSoundPlayer->playTone(SystemSoundPlayerInterface::Tone::WAKEWORD_NOTIFICATION);});
     }
 
     // Mutex required since following operations depend on value of @c m_encodingAudioFormats
@@ -1327,8 +1339,8 @@ bool AudioInputProcessor::executeRecognize(
     return true;
 }
 
-void AudioInputProcessor::executeOnContextAvailable(const std::string& jsonContext) {
-    ACSDK_DEBUG(LX("executeOnContextAvailable").sensitive("jsonContext", jsonContext));
+void AudioInputProcessor::executeOnContextAvailable(const std::shared_ptr<AVSContext>& endpointContext) {
+    ACSDK_DEBUG(LX("executeOnContextAvailable"));
 
     // Should already be RECOGNIZING if we get here.
     if (m_state != ObserverInterface::State::RECOGNIZING) {
@@ -1353,7 +1365,11 @@ void AudioInputProcessor::executeOnContextAvailable(const std::string& jsonConte
     // Start acquiring the channel right away; we'll service the callback after assembling our Recognize event.
     if (m_focusState != avsCommon::avs::FocusState::FOREGROUND) {
         auto activity = FocusManagerInterface::Activity::create(
-            NAMESPACE, shared_from_this(), std::chrono::milliseconds::zero(), avsCommon::avs::ContentType::MIXABLE);
+            NAMESPACE,
+            shared_from_this(),
+            std::chrono::milliseconds::zero(),
+            avsCommon::avs::ContentType::MIXABLE,
+            {avsCommon::avs::AudioAttributes::Usage::AUDIO_CAPTURE});
         if (!m_focusManager->acquireChannel(CHANNEL_NAME, activity)) {
             ACSDK_ERROR(LX("executeOnContextAvailableFailed").d("reason", "Unable to acquire channel"));
             executeResetState();
@@ -1366,31 +1382,12 @@ void AudioInputProcessor::executeOnContextAvailable(const std::string& jsonConte
         m_preCachedDialogRequestId.clear();
     }
 
-    // Assemble the MessageRequest.  It will be sent by executeOnFocusChanged when we acquire the channel.
-    auto msgIdAndJsonEvent =
-        buildJsonEventString("Recognize", m_directiveSequencer->getDialogRequestId(), m_recognizePayload, jsonContext);
-
-    if (m_messageRequestResolver) {
-        // Create unresolved MessageRequest
-        m_recognizeRequest = std::make_shared<MessageRequest>(
-            msgIdAndJsonEvent.second,
-            true,
-            "",
-            std::vector<std::pair<std::string, std::string>>{},
-            m_messageRequestResolver,
-            m_audioBytesForMetricThreshold,
-            m_uploadMetricName);
-    } else {
-        m_recognizeRequest = std::make_shared<MessageRequest>(
-            msgIdAndJsonEvent.second, m_audioBytesForMetricThreshold, m_uploadMetricName);
-        // Only add attachment readers for resolved MessageRequest. For unresolved one, attachment readers will be
-        // passed to the resolver function.
-        if (!m_attachmentReaders.empty() && !m_attachmentReaders.begin()->second.empty()) {
-            for (auto& namedReader : m_attachmentReaders.begin()->second) {
-                m_recognizeRequest->addAttachmentReader(namedReader->name, namedReader->reader);
-            }
-        }
-    }
+    m_recognizeRequest = std::make_shared<RecognizeRequestData>(
+        "Recognize",
+        m_directiveSequencer->getDialogRequestId(),
+        m_recognizePayload,
+        endpointContext);
+
     // If we already have focus, there won't be a callback to send the message, so send it now.
     if (avsCommon::avs::FocusState::FOREGROUND == m_focusState) {
         sendRequestNow();
@@ -1421,6 +1418,24 @@ void AudioInputProcessor::executeOnFocusChanged(avsCommon::avs::FocusState newFo
         return;
     }
 
+    if (m_focusState == avsCommon::avs::FocusState::FOREGROUND && m_shouldPlayWakeTone) {
+        // If we have not already played the wake tone and we should play, do so now.
+        m_shouldPlayWakeTone = false;
+        m_executor.execute(
+            [this]() {m_systemSoundPlayer->playTone(SystemSoundPlayerInterface::Tone::WAKEWORD_NOTIFICATION);});
+    }
+
+    if (m_recognizeRequest && m_universalDeviceCommandsProvider) {
+        auto start = std::chrono::system_clock::now();
+        auto udcTag = m_universalDeviceCommandsProvider->getUniversalDeviceControllerTag();
+        auto udcState = m_universalDeviceCommandsProvider->getUniversalDeviceControllerState();
+        m_recognizeRequest->m_context->addState(udcTag, udcState);
+        auto end = std::chrono::system_clock::now();
+        ACSDK_DEBUG3(LX("collecting UDC context")
+                         .d("durationUs", std::chrono::duration_cast<microseconds>(end - start).count())
+                         .d("payload", udcState.valuePayload));
+    }
+
     // For a focus change to FOREGROUND in the Recognizing state, we may have a message queued up to send.  If we do,
     // we can safely send it now.
     sendRequestNow();
@@ -1487,7 +1502,10 @@ bool AudioInputProcessor::executeStopCapture(bool stopImmediately, std::shared_p
             removeDirective(info);
         }
 
-        if (m_speechConfirmation->get() == settings::SpeechConfirmationSettingType::TONE) {
+        if (avsCommon::avs::FocusState::FOREGROUND == m_focusState &&
+                m_speechConfirmation->get() == settings::SpeechConfirmationSettingType::TONE) {
+            // Only play the tone if we are in the foreground. We will not have lost focus in any use case yet, since
+            // StopCapture directive has not been processed yet.
             m_systemSoundPlayer->playTone(SystemSoundPlayerInterface::Tone::END_SPEECH);
         }
     };
@@ -1525,6 +1543,7 @@ void AudioInputProcessor::executeResetState() {
     m_focusState = avsCommon::avs::FocusState::NONE;
     setState(ObserverInterface::State::IDLE);
     m_audioBytesForMetricThreshold = 0;
+    m_shouldPlayWakeTone = false;
 }
 
 bool AudioInputProcessor::executeExpectSpeech(milliseconds timeout, std::shared_ptr<DirectiveInfo> info) {
@@ -1631,7 +1650,7 @@ void AudioInputProcessor::setState(ObserverInterface::State state) {
 
     // Reset the user inactivity if transitioning to or from `RECOGNIZING` state.
     if (ObserverInterface::State::RECOGNIZING == m_state || ObserverInterface::State::RECOGNIZING == state) {
-        m_executor.submit([this]() { m_userInactivityMonitor->onUserActive(); });
+        m_executor.execute([this]() { m_userInactivityMonitor->onUserActive(); });
     }
 
     auto currentDialogRequestId =
@@ -1667,11 +1686,47 @@ void AudioInputProcessor::sendRequestNow() {
     ACSDK_DEBUG(LX(__func__));
 
     if (m_recognizeRequest) {
+        // Assemble the MessageRequest.  It will be sent by executeOnFocusChanged when we acquire the channel.
+        auto start = std::chrono::system_clock::now();
+        auto jsonContext = m_recognizeRequest->m_context->toJson();
+        ACSDK_DEBUG(LX("building request now").sensitive("jsonContext", jsonContext));
+        auto msgIdAndJsonEvent =
+            buildJsonEventString(
+                m_recognizeRequest->m_name,
+                m_recognizeRequest->m_dialogRequestId,
+                m_recognizeRequest->m_payload,
+                jsonContext);
+
+        std::shared_ptr<MessageRequest> messageRequest;
+        if (m_messageRequestResolver) {
+            // Create unresolved MessageRequest
+            messageRequest = std::make_shared<MessageRequest>(
+                msgIdAndJsonEvent.second,
+                true,
+                "",
+                std::vector<std::pair<std::string, std::string>>{},
+                m_messageRequestResolver,
+                m_audioBytesForMetricThreshold,
+                m_uploadMetricName);
+        } else {
+            messageRequest = std::make_shared<MessageRequest>(
+                msgIdAndJsonEvent.second, m_audioBytesForMetricThreshold, m_uploadMetricName);
+            // Only add attachment readers for resolved MessageRequest. For unresolved one, attachment readers will be
+            // passed to the resolver function.
+            if (!m_attachmentReaders.empty() && !m_attachmentReaders.begin()->second.empty()) {
+                for (auto& namedReader : m_attachmentReaders.begin()->second) {
+                    messageRequest->addAttachmentReader(namedReader->name, namedReader->reader);
+                }
+            }
+        }
+        auto end = std::chrono::system_clock::now();
+
+        ACSDK_DEBUG(LX("preparing recognize request completed").d("durationUs", std::chrono::duration_cast<microseconds>(end - start).count()));
         ACSDK_METRIC_IDS(TAG, "Recognize", "", "", Metrics::Location::AIP_SEND);
-        if (m_recognizeRequestSent && (m_recognizeRequestSent != m_recognizeRequest)) {
+        if (m_recognizeRequestSent && (m_recognizeRequestSent != messageRequest)) {
             m_recognizeRequestSent->removeObserver(shared_from_this());
         }
-        m_recognizeRequestSent = m_recognizeRequest;
+        m_recognizeRequestSent = messageRequest;
         m_recognizeRequestSent->addObserver(shared_from_this());
         m_messageSender->sendMessage(m_recognizeRequestSent);
 
@@ -1699,7 +1754,7 @@ void AudioInputProcessor::onExceptionReceived(const std::string& exceptionMessag
 
 void AudioInputProcessor::onSendCompleted(MessageRequestObserverInterface::Status status) {
     ACSDK_DEBUG(LX("onSendCompleted").d("status", status));
-    m_executor.submit([this, status]() {
+    m_executor.execute([this, status]() {
         if (MessageRequestObserverInterface::Status::SUCCESS == status &&
             ObserverInterface::State::RECOGNIZING == m_state) {
             // This is to take care of the edge case where the event stream is closed before a stop capture is received.
@@ -1715,7 +1770,7 @@ std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> Aud
 }
 
 void AudioInputProcessor::onLocaleAssetsChanged() {
-    m_executor.submit([this]() { executeOnLocaleAssetsChanged(); });
+    m_executor.execute([this]() { executeOnLocaleAssetsChanged(); });
 }
 
 void AudioInputProcessor::executeOnLocaleAssetsChanged() {
@@ -1787,7 +1842,7 @@ bool AudioInputProcessor::handleSetWakeWordConfirmation(std::shared_ptr<Directiv
 
     auto executeChange = [this, value]() { m_wakeWordConfirmation->setAvsChange(value); };
 
-    m_executor.submit(executeChange);
+    m_executor.execute(executeChange);
 
     if (info->result) {
         info->result->setCompleted();
@@ -1810,7 +1865,7 @@ bool AudioInputProcessor::handleSetSpeechConfirmation(std::shared_ptr<DirectiveI
         return false;
     }
 
-    settings::SpeechConfirmationSettingType value;
+    settings::SpeechConfirmationSettingType value = settings::SpeechConfirmationSettingType::NONE;
     std::stringstream ss{jsonValue};
     ss >> value;
 
@@ -1823,7 +1878,7 @@ bool AudioInputProcessor::handleSetSpeechConfirmation(std::shared_ptr<DirectiveI
 
     auto executeChange = [this, value]() { m_speechConfirmation->setAvsChange(value); };
 
-    m_executor.submit(executeChange);
+    m_executor.execute(executeChange);
 
     if (info->result) {
         info->result->setCompleted();
@@ -1852,7 +1907,7 @@ bool AudioInputProcessor::handleSetWakeWords(std::shared_ptr<DirectiveInfo> info
         return false;
     }
 
-    m_executor.submit([this, wakeWords, info]() { m_wakeWordsSetting->setAvsChange(wakeWords); });
+    m_executor.execute([this, wakeWords, info]() { m_wakeWordsSetting->setAvsChange(wakeWords); });
 
     if (info->result) {
         info->result->setCompleted();
@@ -1902,7 +1957,7 @@ void AudioInputProcessor::managePowerResource(ObserverInterface::State newState)
 
 void AudioInputProcessor::onConnectionStatusChanged(bool connected) {
     if (!connected) {
-        m_executor.submit([this]() { return executeDisconnected(); });
+        m_executor.execute([this]() { return executeDisconnected(); });
     }
 }
 
diff --git a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
index c1b553b7..fc0a179b 100644
--- a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
+++ b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
@@ -45,6 +45,7 @@
 #include <AVSCommon/SDKInterfaces/MockSystemSoundPlayer.h>
 #include <AVSCommon/SDKInterfaces/MockUserInactivityMonitor.h>
 #include <AVSCommon/SDKInterfaces/MockPowerResourceManager.h>
+#include <AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsProvider.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/Memory/Memory.h>
 #include <AVSCommon/Utils/Metrics/MockMetricRecorder.h>
@@ -309,6 +310,9 @@ static const std::string DEFAULT_LOCALE = "en-CA";
 /// Capability configuration key used to give more details about the device configuration.
 static const std::string CAPABILITY_INTERFACE_CONFIGURATIONS_KEY = "configurations";
 
+// The test EndpointIdentifier.
+static const endpoints::EndpointIdentifier ENDPOINT_IDENTIFIER{"test_endpoint_id"};
+
 // The context request token returned by context manager.
 static const ContextRequestToken CONTEXT_REQUEST_TOKEN{1};
 
@@ -332,6 +336,19 @@ static const std::map<std::string, std::string> EXPECTED_ENCODING_FORMATS = {{"C
                                                                              {"LOCAL", AUDIO_FORMAT_LPCM},
                                                                              {"LOCAL2", AUDIO_FORMAT_LPCM}};
 
+/// Empty UniversalDeviceController Payload
+const std::string AVAILABLE_COMMANDS_PAYLOAD_TEMPLATE = R"({"availableCommands" : []})";
+
+/// Empty UniversalDeviceController CapabilityState
+static const CapabilityState UDC_CAPABILITY_STATE = CapabilityState(AVAILABLE_COMMANDS_PAYLOAD_TEMPLATE);
+
+/// UniversalDeviceController CapabilityTag
+static const CapabilityTag UDC_CAPABILITY_TAG = CapabilityTag(
+    "MultiAssistant.UniversalDeviceController",
+    "UniversalDeviceControllerState",
+    ENDPOINT_IDENTIFIER
+    );
+
 /// Utility function to parse a JSON document.
 static rapidjson::Document parseJson(const std::string& json) {
     rapidjson::Document document;
@@ -1025,6 +1042,9 @@ protected:
 
     /// Message ID in directive
     std::string m_messageId;
+
+    /// The mock @c UniversalDeviceCOmmandsProviderInterface
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockUniversalDeviceCommandsProvider> m_mockUDCProvider;
 };
 
 void AudioInputProcessorTest::SetUp() {
@@ -1094,6 +1114,8 @@ void AudioInputProcessorTest::SetUp() {
         }));
     EXPECT_CALL(*m_mockPowerResourceManager, close(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
 
+    m_mockUDCProvider = std::make_shared<MockUniversalDeviceCommandsProvider>();
+
     m_audioInputProcessor = AudioInputProcessor::create(
         m_mockDirectiveSequencer,
         m_mockMessageSender,
@@ -1111,7 +1133,9 @@ void AudioInputProcessorTest::SetUp() {
         nullptr,
         *m_audioProvider,
         m_mockPowerResourceManager,
-        m_metricRecorder);
+        m_metricRecorder,
+        nullptr,
+        m_mockUDCProvider);
     ASSERT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
     // Note: StrictMock here so that we fail on unexpected AIP state changes
@@ -1225,19 +1249,14 @@ bool AudioInputProcessorTest::testRecognizeSucceeds(
         EXPECT_EQ(m_writer->write(m_pattern.data(), m_pattern.size()), static_cast<ssize_t>(m_pattern.size()));
     }
 
-    rapidjson::Document contextDocument(rapidjson::kObjectType);
-    rapidjson::Value contextArray(rapidjson::kArrayType);
-    contextDocument.AddMember(rapidjson::StringRef(MESSAGE_CONTEXT_KEY), contextArray, contextDocument.GetAllocator());
-    rapidjson::StringBuffer contextBuffer;
-    rapidjson::Writer<rapidjson::StringBuffer> contextWriter(contextBuffer);
-    contextDocument.Accept(contextWriter);
-    std::string contextJson = contextBuffer.GetString();
+    auto context = std::make_shared<AVSContext>();
+
     m_recognizeEvent = std::make_shared<RecognizeEvent>(
         audioProvider, initiator, begin, keywordEnd, keyword, avsInitiator, KWDMetadata, expectedFormat);
     if (keyword.empty()) {
         EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
-            .WillOnce(InvokeWithoutArgs([this, contextJson, stopPoint] {
-                m_audioInputProcessor->onContextAvailable(contextJson);
+            .WillOnce(InvokeWithoutArgs([this, context, stopPoint] {
+                m_audioInputProcessor->onContextAvailable(ENDPOINT_IDENTIFIER, context, CONTEXT_REQUEST_TOKEN);
                 if (RecognizeStopPoint::AFTER_CONTEXT == stopPoint) {
                     EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
                     m_dialogUXStateAggregator->onRequestProcessingStarted();
@@ -1250,8 +1269,8 @@ bool AudioInputProcessorTest::testRecognizeSucceeds(
         InSequence dummy;
 
         EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
-            .WillOnce(InvokeWithoutArgs([this, contextJson, stopPoint] {
-                m_audioInputProcessor->onContextAvailable(contextJson);
+            .WillOnce(InvokeWithoutArgs([this, context, stopPoint] {
+                m_audioInputProcessor->onContextAvailable(ENDPOINT_IDENTIFIER, context, CONTEXT_REQUEST_TOKEN);
                 if (RecognizeStopPoint::AFTER_CONTEXT == stopPoint) {
                     EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
                     m_dialogUXStateAggregator->onRequestProcessingStarted();
@@ -1643,13 +1662,7 @@ bool AudioInputProcessorTest::testRecognizeWithExpectSpeechInitiator(bool withIn
             conditionVariable.notify_one();
         }));
 
-    rapidjson::Document contextDocument(rapidjson::kObjectType);
-    rapidjson::Value contextArray(rapidjson::kArrayType);
-    contextDocument.AddMember(rapidjson::StringRef(MESSAGE_CONTEXT_KEY), contextArray, contextDocument.GetAllocator());
-    rapidjson::StringBuffer contextBuffer;
-    rapidjson::Writer<rapidjson::StringBuffer> contextWriter(contextBuffer);
-    contextDocument.Accept(contextWriter);
-    std::string contextJson = contextBuffer.GetString();
+    auto context = std::make_shared<AVSContext>();
 
     // Check for successful Directive handling.
     EXPECT_CALL(*result, setCompleted());
@@ -1665,7 +1678,7 @@ bool AudioInputProcessorTest::testRecognizeWithExpectSpeechInitiator(bool withIn
     EXPECT_TRUE(directiveHandler->handleDirective(avsDirective->getMessageId()));
     EXPECT_EQ(std::string(""), m_mockDirectiveSequencer->getDialogRequestId());
     m_audioInputProcessor->onFocusChanged(avsCommon::avs::FocusState::FOREGROUND, MixingBehavior::PRIMARY);
-    m_audioInputProcessor->onContextAvailable(contextJson);
+    m_audioInputProcessor->onContextAvailable(ENDPOINT_IDENTIFIER, context, CONTEXT_REQUEST_TOKEN);
 
     std::unique_lock<std::mutex> lock(mutex);
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
@@ -2236,11 +2249,15 @@ TEST_F(AudioInputProcessorTest, test_recognizeInvalidAudioFormat) {
 
 /// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::PRESS_AND_HOLD.
 TEST_F(AudioInputProcessorTest, test_recognizePressAndHold) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD));
 }
 
 /// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::TAP.
 TEST_F(AudioInputProcessorTest, test_recognizeTap) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
 }
 
@@ -2267,6 +2284,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithBadBegin) {
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
@@ -2274,6 +2293,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeyword) {
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBegin) {
     avsCommon::avs::AudioInputStream::Index begin = 0;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
@@ -2284,6 +2305,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBegin) {
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEnd) {
     avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
     avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
@@ -2291,6 +2314,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEnd) {
 TEST_F(AudioInputProcessorTest, test_recognizeCloseTalk) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::PRESS_AND_HOLD));
 }
 
@@ -2298,6 +2323,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeCloseTalk) {
 TEST_F(AudioInputProcessorTest, test_recognizeNearField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::NEAR_FIELD;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
 }
 
@@ -2305,6 +2332,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeNearField) {
 TEST_F(AudioInputProcessorTest, test_recognizeFarField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::FAR_FIELD;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
 }
 
@@ -2396,6 +2425,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWhileExpectingSpeech) {
 TEST_F(AudioInputProcessorTest, test_recognizeStopAfterRecognize) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
         Initiator::PRESS_AND_HOLD,
@@ -2412,6 +2443,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterRecognize) {
 TEST_F(AudioInputProcessorTest, test_recognizeStopAfterContext) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
         Initiator::PRESS_AND_HOLD,
@@ -2428,6 +2461,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterContext) {
 TEST_F(AudioInputProcessorTest, test_recognizeStopAfterFocus) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
         Initiator::PRESS_AND_HOLD,
@@ -2444,6 +2479,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterFocus) {
 TEST_F(AudioInputProcessorTest, test_recognizeStopAfterSend) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
         Initiator::PRESS_AND_HOLD,
@@ -2460,6 +2497,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterSend) {
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalk) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
 }
@@ -2471,6 +2510,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalk)
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingNearField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::NEAR_FIELD;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
 }
@@ -2482,6 +2523,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingNearField)
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingFarField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::FAR_FIELD;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
 }
@@ -2491,6 +2534,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingFarField) {
  * @c AudioProvider can't override.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantOverride) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
     auto audioProvider = *m_audioProvider;
     audioProvider.canOverride = false;
@@ -2504,6 +2549,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantOverrid
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantBeOverridden) {
     auto audioProvider = *m_audioProvider;
     audioProvider.canBeOverridden = false;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
     ASSERT_TRUE(testRecognizeFails(*m_audioProvider, Initiator::TAP));
 }
@@ -2522,6 +2569,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenExpectingSpeech) {
 
 /// This function verifies that @c AudioInputProcessor::stopCapture() works in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizing) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureSucceeds());
 
@@ -2538,6 +2587,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizing) {
  * subsequent StopCapture directive will be ignored.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizingFollowByStopCaptureDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureSucceeds());
 
@@ -2584,6 +2635,8 @@ TEST_F(AudioInputProcessorTest, test_resetStateWhenExpectingSpeech) {
 
 /// This function verifies that @c AudioInputProcessor::resetState() works in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_resetStateWhenRecognizing) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
 
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
@@ -2614,6 +2667,8 @@ TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenI
 
 /// This function verifies that StopCapture directives with dialog request ID work in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenRecognizing) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureDirectiveSucceeds(WITH_DIALOG_REQUEST_ID));
 }
@@ -2627,6 +2682,8 @@ TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenE
 
 /// This function verifies that StopCapture directives without dialog request ID work in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_handleDirectiveImmediatelyStopCaptureWhenRecognizing) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureDirectiveSucceeds(!WITH_DIALOG_REQUEST_ID));
 }
@@ -2643,6 +2700,8 @@ TEST_F(AudioInputProcessorTest, test_handleDirectiveImmediatelyExpectSpeechWhenI
 
 /// This function verifies that ExpectSpeech directives fail in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenRecognizing) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
     ASSERT_TRUE(testExpectSpeechFails(WITH_DIALOG_REQUEST_ID));
 }
@@ -2754,18 +2813,24 @@ TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithAlwaysRea
 /// This function verifies that a focus change to @c FocusState::BACKGROUND causes the @c AudioInputProcessor to
 /// release the channel and go back to @c State::IDLE.
 TEST_F(AudioInputProcessorTest, test_focusChangedBackground) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testFocusChange(avsCommon::avs::FocusState::BACKGROUND, avsCommon::avs::MixingBehavior::MUST_PAUSE));
 }
 
 /// This function verifies that a focus change to @c FocusState::NONE causes the @c AudioInputProcessor to
 /// release the channel and go back to @c State::IDLE.
 TEST_F(AudioInputProcessorTest, test_focusChangedNone) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testFocusChange(avsCommon::avs::FocusState::NONE, avsCommon::avs::MixingBehavior::MUST_STOP));
 }
 
 /// Test that the @c AudioInputProcessor correctly transitions to @c State::IDLE
 /// if @c Status::TIMEDOUT is received
 TEST_F(AudioInputProcessorTest, test_resetStateOnTimeOut) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
 
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
@@ -2779,6 +2844,8 @@ TEST_F(AudioInputProcessorTest, test_resetStateOnTimeOut) {
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithESPWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     // note that we are just using a integer instead of a float number, this is to help with JSON verification.
     EXPECT_TRUE(testRecognizeSucceeds(
         *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr));
@@ -2792,6 +2859,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithESPWithKeyword) {
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithInvalidESPWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     EXPECT_TRUE(testRecognizeSucceeds(
         *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr));
 }
@@ -2803,6 +2872,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithInvalidESPWithKeyword)
 TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithTap) {
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
 }
 
@@ -2813,6 +2884,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithTap) {
 TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithPressAndHold) {
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD));
 }
 
@@ -2825,6 +2898,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithWakeWord) {
     avsCommon::avs::AudioInputStream::Index end = AudioInputProcessor::INVALID_INDEX;
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
@@ -2838,6 +2913,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKWDMetadata) {
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
 
     EXPECT_TRUE(testRecognizeSucceeds(
         *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr, metadata));
@@ -2859,6 +2936,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeInvalidWakeWord) {
  * has received SUCCESS but not yet closed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessBeforeClose) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::NONE,
@@ -2872,6 +2951,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessBeforeClose) {
  * successfully sent.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccess) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::NONE,
@@ -2884,6 +2965,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccess) {
  * has received SUCCESS_NO_CONTENT but the stream has not yet closed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentBeforeClose) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::NONE,
@@ -2897,6 +2980,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentBeforeCl
  * has received PENDING but the stream has not yet closed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamPendingBeforeClose) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PENDING,
         StopCaptureDirectiveSchedule::NONE,
@@ -2910,6 +2995,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamPendingBeforeClose) {
  * successfully sent but received no HTTP/2 content.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContent) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::NONE,
@@ -2922,6 +3009,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContent) {
  * been sent due to connection to AVS has been severed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnected) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
         StopCaptureDirectiveSchedule::NONE,
@@ -2934,6 +3023,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnected) {
  * been sent due to AVS is not synchronized.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronized) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
         StopCaptureDirectiveSchedule::NONE,
@@ -2946,6 +3037,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronized) {
  * been sent due to an internal error within ACL.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrror) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
         StopCaptureDirectiveSchedule::NONE,
@@ -2958,6 +3051,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrror) {
  * been sent due to an underlying protocol error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
         StopCaptureDirectiveSchedule::NONE,
@@ -2970,6 +3065,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolError) {
  * been sent due to an internal error on the server which sends code 500.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
         StopCaptureDirectiveSchedule::NONE,
@@ -2982,6 +3079,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalError) {
  * been sent due to server refusing the request.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefused) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
         StopCaptureDirectiveSchedule::NONE,
@@ -2994,6 +3093,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefused) {
  * been sent due to server canceling it before the transmission completed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceled) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
         StopCaptureDirectiveSchedule::NONE,
@@ -3006,6 +3107,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceled) {
  * been sent due to excessive load on the server.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottled) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
         StopCaptureDirectiveSchedule::NONE,
@@ -3018,6 +3121,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottled) {
  * been sent due to the access credentials provided to ACL were invalid.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuth) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
         StopCaptureDirectiveSchedule::NONE,
@@ -3030,6 +3135,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuth) {
  * been sent due to invalid request sent by the user.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequest) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
         StopCaptureDirectiveSchedule::NONE,
@@ -3042,6 +3149,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequest) {
  * been sent due to unknown server error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
         StopCaptureDirectiveSchedule::NONE,
@@ -3054,6 +3163,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerError) {
  * recognize event stream has been successfully sent.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccess) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3066,6 +3177,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccess) {
  * recognize event stream has been successfully sent but received no HTTP/2 content.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNoContent) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3078,6 +3191,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNoCon
  * recognize event stream has not been sent due to connection to AVS has been severed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNotConnected) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3090,6 +3205,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamSuccessNotCo
  * recognize event stream has not been sent due to AVS is not synchronized.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamNotSynchronized) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3102,6 +3219,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamNotSynchroni
  * recognize event stream has not been sent due to an internal error within ACL.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInternalrror) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3114,6 +3233,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInternalrror
  * recognize event stream has not been sent due to an underlying protocol error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamProtocolError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3126,6 +3247,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamProtocolErro
  * recognize event stream has not been sent due to an internal error on the server which sends code 500.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamServerInternalError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3138,6 +3261,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamServerIntern
  * recognize event stream has not been sent due to server refusing the request.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamRefused) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3150,6 +3275,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamRefused) {
  * recognize event stream has not been sent due to server canceling it before the transmission completed.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamCanceled) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3162,6 +3289,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamCanceled) {
  * recognize event stream has not been sent due to excessive load on the server.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamThrottled) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3174,6 +3303,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamThrottled) {
  * recognize event stream has not been sent due to the access credentials provided to ACL were invalid.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInvalidAuth) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3186,6 +3317,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamInvalidAuth)
  * recognize event stream has not been sent due to invalid request sent by the user.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamBadRequest) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3198,6 +3331,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamBadRequest)
  * recognize event stream has not been sent due to unknown server error.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamUnknownServerError) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
         StopCaptureDirectiveSchedule::BEFORE_RESPONSE_STATUS_RECEIVED,
@@ -3210,6 +3345,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnDirectiveAndStreamUnknownServe
  * SUCCESS but is not yet closed and a stop capture directive has been received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirectiveBeforeClose) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS,
         StopCaptureDirectiveSchedule::AFTER_RESPONSE_CODE_RECEIVED,
@@ -3224,6 +3361,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirectiveBefor
  * directive.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     // Simulate tap to talk and start recognizing.
     ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
 
@@ -3256,6 +3395,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
  * successfully sent but received no HTTP/2 content and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3268,6 +3409,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNoContentAndDirec
  * been sent due to connection to AVS has been severed and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnectedAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_CONNECTED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3280,6 +3423,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessNotConnectedAndDi
  * been sent due to AVS is not synchronized and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronizedAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::NOT_SYNCHRONIZED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3292,6 +3437,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamNotSynchronizedAndDirect
  * been sent due to an internal error within ACL and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrrorAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INTERNAL_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3304,6 +3451,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInternalrrorAndDirective
  * been sent due to an underlying protocol error and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolErrorAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::PROTOCOL_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3316,6 +3465,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamProtocolErrorAndDirectiv
  * been sent due to an internal error on the server which sends code 500  and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalErrorAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3328,6 +3479,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamServerInternalErrorAndDi
  * been sent due to server refusing the request and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefusedAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::REFUSED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3340,6 +3493,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamRefusedAndDirective) {
  * been sent due to server canceling it before the transmission completed and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceledAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::CANCELED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3352,6 +3507,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamCanceledAndDirective) {
  * been sent due to excessive load on the server and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottledAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::THROTTLED,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3364,6 +3521,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamThrottledAndDirective) {
  * been sent due to the access credentials provided to ACL were invalid and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuthAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::INVALID_AUTH,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3376,6 +3535,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamInvalidAuthAndDirective)
  * been sent due to invalid request sent by the user and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequestAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::BAD_REQUEST,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3388,6 +3549,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamBadRequestAndDirective)
  * been sent due to unknown server error and a stop capture directive is received.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerErrorAndDirective) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     testAIPStateTransitionOnEventResponse(
         avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR,
         StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE,
@@ -3883,6 +4046,8 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizingForMultiStreams)
 /// This function verifies that after call requestEncodingAudioFormats with only one format in the request, AIP will
 /// still send resolved MessageRequest.
 TEST_F(AudioInputProcessorTest, test_recognizeWorksWithOneFormatInRequestEncodingAudioFormats) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).WillOnce(Return(UDC_CAPABILITY_STATE));
     AudioInputProcessor::EncodingFormatRequest encodingReq = {
         {"LOCAL", {avsCommon::utils::AudioFormat::Encoding::LPCM, avsCommon::utils::AudioFormat::Encoding::LPCM}}};
     AudioInputProcessor::EncodingFormatResponse expectedRsp = {
diff --git a/CapabilityAgents/Alexa/include/Alexa/AlexaInterfaceMessageSender.h b/CapabilityAgents/Alexa/include/Alexa/AlexaInterfaceMessageSender.h
index 02a4a39e..66eb4790 100644
--- a/CapabilityAgents/Alexa/include/Alexa/AlexaInterfaceMessageSender.h
+++ b/CapabilityAgents/Alexa/include/Alexa/AlexaInterfaceMessageSender.h
@@ -98,7 +98,7 @@ public:
     /// @{
     void onContextAvailable(
         const std::string& endpointId,
-        const avsCommon::avs::AVSContext& endpointContext,
+        const std::shared_ptr<avsCommon::avs::AVSContext>& endpointContext,
         avsCommon::sdkInterfaces::ContextRequestToken token) override;
     void onContextFailure(
         const avsCommon::sdkInterfaces::ContextRequestError error,
diff --git a/CapabilityAgents/Alexa/src/AlexaInterfaceCapabilityAgent.cpp b/CapabilityAgents/Alexa/src/AlexaInterfaceCapabilityAgent.cpp
index 86aca700..1d4f52ca 100644
--- a/CapabilityAgents/Alexa/src/AlexaInterfaceCapabilityAgent.cpp
+++ b/CapabilityAgents/Alexa/src/AlexaInterfaceCapabilityAgent.cpp
@@ -168,7 +168,7 @@ void AlexaInterfaceCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<A
 
 void AlexaInterfaceCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         if (!info || !info->directive) {
             ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirective"));
             return;
diff --git a/CapabilityAgents/Alexa/src/AlexaInterfaceMessageSender.cpp b/CapabilityAgents/Alexa/src/AlexaInterfaceMessageSender.cpp
index 4fa4a9f4..de1982ae 100644
--- a/CapabilityAgents/Alexa/src/AlexaInterfaceMessageSender.cpp
+++ b/CapabilityAgents/Alexa/src/AlexaInterfaceMessageSender.cpp
@@ -327,7 +327,7 @@ bool AlexaInterfaceMessageSender::sendCommonResponseEvent(
         endpoint,
         jsonPayload,
         responseNamespace == "" ? ALEXA_INTERFACE_NAME : responseNamespace);
-    m_executor.submit([this, event]() {
+    m_executor.execute([this, event]() {
         // Start collecting context for this endpoint.
         auto token = m_contextManager->getContext(shared_from_this(), event->endpoint.endpointId);
         m_pendingResponses[token] = event;
@@ -408,7 +408,7 @@ void AlexaInterfaceMessageSender::onStateChanged(
     const CapabilityState& state,
     const AlexaStateChangeCauseType cause) {
     auto event = std::make_shared<ChangeReportData>(identifier, state, cause);
-    m_executor.submit([this, event]() {
+    m_executor.execute([this, event]() {
         // Start collecting context for this endpoint.
         auto token = m_contextManager->getContext(shared_from_this(), event->tag.endpointId);
         m_pendingChangeReports[token] = event;
@@ -417,17 +417,17 @@ void AlexaInterfaceMessageSender::onStateChanged(
 
 void AlexaInterfaceMessageSender::onContextAvailable(
     const std::string& endpointId,
-    const AVSContext& endpointContext,
+    const std::shared_ptr<AVSContext>& endpointContext,
     ContextRequestToken token) {
-    m_executor.submit([this, endpointId, endpointContext, token]() {
+    m_executor.execute([this, endpointId, endpointContext, token]() {
         ACSDK_DEBUG(LX("onContextAvailable").sensitive("endpointId", endpointId));
 
         // Is this for a pending response event?
         if (m_pendingResponses.find(token) != m_pendingResponses.end()) {
-            completeResponseEvent(m_pendingResponses[token], Optional<AVSContext>(endpointContext));
+            completeResponseEvent(m_pendingResponses[token], Optional<AVSContext>(*endpointContext));
             m_pendingResponses.erase(token);
         } else if (m_pendingChangeReports.find(token) != m_pendingChangeReports.end()) {
-            completeChangeReportEvent(m_pendingChangeReports[token], endpointContext);
+            completeChangeReportEvent(m_pendingChangeReports[token], *endpointContext);
             m_pendingChangeReports.erase(token);
         } else {
             ACSDK_ERROR(LX("onContextAvailable").d("reason", "unknownEvent").d("token", token));
@@ -436,7 +436,7 @@ void AlexaInterfaceMessageSender::onContextAvailable(
 }
 
 void AlexaInterfaceMessageSender::onContextFailure(const ContextRequestError error, ContextRequestToken token) {
-    m_executor.submit([this, error, token]() {
+    m_executor.execute([this, error, token]() {
         ACSDK_ERROR(LX("executeOnContextFailure").d("error", error));
 
         // Is this for a pending response event?
diff --git a/CapabilityAgents/Alexa/test/AlexaInterfaceMessageSenderTest.cpp b/CapabilityAgents/Alexa/test/AlexaInterfaceMessageSenderTest.cpp
index 245d69af..7df1ef37 100644
--- a/CapabilityAgents/Alexa/test/AlexaInterfaceMessageSenderTest.cpp
+++ b/CapabilityAgents/Alexa/test/AlexaInterfaceMessageSenderTest.cpp
@@ -417,14 +417,15 @@ protected:
     std::shared_ptr<MockMessageSender> m_messageSender;
 
     /// Test @c AVSContext object.
-    AVSContext m_context;
+    std::shared_ptr<AVSContext> m_context;
 };
 
 void AlexaInterfaceMessageSenderTest::SetUp() {
     m_mockContextManager = std::make_shared<StrictMock<avsCommon::sdkInterfaces::test::MockContextManager>>();
     m_messageSender = std::make_shared<StrictMock<MockMessageSender>>();
 
-    m_context.addState(buildTestTag(), buildTestState());
+    m_context = std::make_shared<AVSContext>();
+    m_context->addState(buildTestTag(), buildTestState());
 }
 
 void AlexaInterfaceMessageSenderTest::TearDown() {
diff --git a/CapabilityAgents/ApiGateway/src/ApiGatewayCapabilityAgent.cpp b/CapabilityAgents/ApiGateway/src/ApiGatewayCapabilityAgent.cpp
index 9030205d..84cb0376 100644
--- a/CapabilityAgents/ApiGateway/src/ApiGatewayCapabilityAgent.cpp
+++ b/CapabilityAgents/ApiGateway/src/ApiGatewayCapabilityAgent.cpp
@@ -117,7 +117,7 @@ void ApiGatewayCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<AVSDi
 
 void ApiGatewayCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, info] { executeHandleDirective(info); });
+    m_executor.execute([this, info] { executeHandleDirective(info); });
 }
 
 void ApiGatewayCapabilityAgent::executeHandleDirective(std::shared_ptr<DirectiveInfo> info) {
diff --git a/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp b/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
index 84567f25..66f50a84 100644
--- a/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
@@ -269,7 +269,7 @@ void ModeControllerCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInf
         return;
     }
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         ACSDK_DEBUG5(LX("handleDirectiveInExecutor"));
         const std::string directiveName = info->directive->getName();
         if (!info->directive->getEndpoint().hasValue() ||
@@ -311,7 +311,7 @@ void ModeControllerCapabilityAgent::provideState(
     ACSDK_DEBUG5(
         LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
 
-    m_executor.submit([this, stateProviderName, contextRequestToken] {
+    m_executor.execute([this, stateProviderName, contextRequestToken] {
         ACSDK_DEBUG5(LX("provideStateInExecutor"));
         executeProvideState(stateProviderName, contextRequestToken);
     });
@@ -402,7 +402,7 @@ void ModeControllerCapabilityAgent::onModeChanged(const ModeState& mode, const A
         return;
     }
 
-    m_executor.submit([this, mode, cause] {
+    m_executor.execute([this, mode, cause] {
         m_contextManager->reportStateChange(
             CapabilityTag(NAMESPACE, MODEVALUE_PROPERTY_NAME, m_endpointId, m_instance),
             buildCapabilityState(mode),
diff --git a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
index 07401dfa..0537f875 100644
--- a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
+++ b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
@@ -120,7 +120,7 @@ void PlaybackController::handleCommand(const PlaybackCommand& command) {
     };
 
     ACSDK_DEBUG9(LX("buttonPressed").d("Button", command));
-    m_executor.submit(task);
+    m_executor.execute(task);
 }
 
 void PlaybackController::onButtonPressed(PlaybackButton button) {
@@ -167,7 +167,7 @@ void PlaybackController::onContextAvailable(const std::string& jsonContext) {
     };
 
     ACSDK_DEBUG9(LX("onContextAvailable"));
-    m_executor.submit(task);
+    m_executor.execute(task);
 }
 
 void PlaybackController::onContextFailure(const ContextRequestError error) {
@@ -189,7 +189,7 @@ void PlaybackController::onContextFailure(const ContextRequestError error) {
     };
 
     ACSDK_DEBUG9(LX("onContextFailure"));
-    m_executor.submit(task);
+    m_executor.execute(task);
 }
 
 PlaybackController::PlaybackController(
diff --git a/CapabilityAgents/PowerController/src/PowerControllerCapabilityAgent.cpp b/CapabilityAgents/PowerController/src/PowerControllerCapabilityAgent.cpp
index 21d799a2..d78dca3c 100644
--- a/CapabilityAgents/PowerController/src/PowerControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/PowerController/src/PowerControllerCapabilityAgent.cpp
@@ -164,7 +164,7 @@ void PowerControllerCapabilityAgent::handleDirective(std::shared_ptr<DirectiveIn
         return;
     }
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         ACSDK_DEBUG5(LX("handleDirectiveInExecutor"));
         const std::string directiveName = info->directive->getName();
         if (!info->directive->getEndpoint().hasValue() ||
@@ -195,7 +195,7 @@ void PowerControllerCapabilityAgent::provideState(
     ACSDK_DEBUG5(
         LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
 
-    m_executor.submit([this, stateProviderName, contextRequestToken] {
+    m_executor.execute([this, stateProviderName, contextRequestToken] {
         ACSDK_DEBUG5(LX("provideStateInExecutor"));
         executeProvideState(stateProviderName, contextRequestToken);
     });
@@ -254,7 +254,7 @@ void PowerControllerCapabilityAgent::onPowerStateChanged(
         return;
     }
 
-    m_executor.submit([this, powerState, cause] {
+    m_executor.execute([this, powerState, cause] {
         ACSDK_DEBUG5(LX("onPowerStateChangedInExecutor"));
         m_contextManager->reportStateChange(
             CapabilityTag(NAMESPACE, POWERSTATE_PROPERTY_NAME, m_endpointId), buildCapabilityState(powerState), cause);
diff --git a/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp b/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
index d885c0fc..73546ae0 100644
--- a/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
@@ -271,7 +271,7 @@ void RangeControllerCapabilityAgent::handleDirective(std::shared_ptr<DirectiveIn
         return;
     }
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         ACSDK_DEBUG5(LX("handleDirectiveInExecutor"));
         const std::string directiveName = info->directive->getName();
         if (!info->directive->getEndpoint().hasValue() ||
@@ -313,7 +313,7 @@ void RangeControllerCapabilityAgent::provideState(
     ACSDK_DEBUG5(
         LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
 
-    m_executor.submit([this, stateProviderName, contextRequestToken] {
+    m_executor.execute([this, stateProviderName, contextRequestToken] {
         ACSDK_DEBUG5(LX("provideStateInExecutor"));
         executeProvideState(stateProviderName, contextRequestToken);
     });
@@ -417,7 +417,7 @@ void RangeControllerCapabilityAgent::onRangeChanged(
         return;
     }
 
-    m_executor.submit([this, rangeState, cause] {
+    m_executor.execute([this, rangeState, cause] {
         m_contextManager->reportStateChange(
             CapabilityTag(NAMESPACE, RANGEVALUE_PROPERTY_NAME, m_endpointId, m_instance),
             buildCapabilityState(rangeState),
diff --git a/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp b/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
index 77cd9a8a..17806c11 100644
--- a/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
+++ b/CapabilityAgents/SpeakerManager/src/SpeakerManager.cpp
@@ -315,7 +315,7 @@ void SpeakerManager::sendExceptionEncountered(
     std::shared_ptr<CapabilityAgent::DirectiveInfo> info,
     const std::string& message,
     avsCommon::avs::ExceptionErrorType type) {
-    m_executor.submit([this, info, message, type] {
+    m_executor.execute([this, info, message, type] {
         m_exceptionEncounteredSender->sendExceptionEncountered(info->directive->getUnparsedDirective(), type, message);
         if (info && info->result) {
             info->result->setFailed(message);
@@ -385,7 +385,7 @@ void SpeakerManager::handleDirective(std::shared_ptr<CapabilityAgent::DirectiveI
         int64_t volume;
         if (jsonUtils::retrieveValue(payload, VOLUME_KEY, &volume) &&
             withinBounds(volume, static_cast<int64_t>(AVS_SET_VOLUME_MIN), static_cast<int64_t>(AVS_SET_VOLUME_MAX))) {
-            m_executor.submit([this, volume, directiveType, info] {
+            m_executor.execute([this, volume, directiveType, info] {
                 /*
                  * Since AVS doesn't have a concept of Speaker IDs or types, no-op if a directive
                  * comes in and there are no AVS_SPEAKER_VOLUME speakers.
@@ -423,7 +423,7 @@ void SpeakerManager::handleDirective(std::shared_ptr<CapabilityAgent::DirectiveI
         if (jsonUtils::retrieveValue(payload, VOLUME_KEY, &delta) &&
             withinBounds(
                 delta, static_cast<int64_t>(AVS_ADJUST_VOLUME_MIN), static_cast<int64_t>(AVS_ADJUST_VOLUME_MAX))) {
-            m_executor.submit([this, delta, directiveType, info] {
+            m_executor.execute([this, delta, directiveType, info] {
                 /*
                  * Since AVS doesn't have a concept of Speaker IDs or types, no-op if a directive
                  * comes in and there are no AVS_SPEAKER_VOLUME speakers.
@@ -459,7 +459,7 @@ void SpeakerManager::handleDirective(std::shared_ptr<CapabilityAgent::DirectiveI
     } else if (directiveName == SET_MUTE.name) {
         bool mute = false;
         if (jsonUtils::retrieveValue(payload, MUTE_KEY, &mute)) {
-            m_executor.submit([this, mute, directiveType, info] {
+            m_executor.execute([this, mute, directiveType, info] {
                 /*
                  * Since AVS doesn't have a concept of Speaker IDs or types, no-op if a directive
                  * comes in and there are no AVS_SPEAKER_VOLUME speakers.
@@ -508,7 +508,7 @@ void SpeakerManager::addSpeakerManagerObserver(
         return;
     }
     ACSDK_DEBUG9(LX("addSpeakerManagerObserver").d("observer", observer.get()));
-    m_executor.submit([this, observer] {
+    m_executor.execute([this, observer] {
         if (!m_observers.insert(observer).second) {
             ACSDK_ERROR(LX("addSpeakerManagerObserverFailed").d("reason", "duplicateObserver"));
         }
@@ -523,7 +523,7 @@ void SpeakerManager::removeSpeakerManagerObserver(
         return;
     }
     ACSDK_DEBUG9(LX("removeSpeakerManagerObserver").d("observer", observer.get()));
-    m_executor.submit([this, observer] {
+    m_executor.execute([this, observer] {
         if (m_observers.erase(observer) == 0) {
             ACSDK_WARN(LX("removeSpeakerManagerObserverFailed").d("reason", "nonExistentObserver"));
         }
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index dfb53ab5..c960b78c 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -261,7 +261,7 @@ avsCommon::avs::DirectiveHandlerConfiguration SpeechSynthesizer::getConfiguratio
 
 void SpeechSynthesizer::addObserver(std::shared_ptr<SpeechSynthesizerObserverInterface> observer) {
     ACSDK_DEBUG9(LX("addObserver").d("observer", observer.get()));
-    m_executor.submit([this, observer]() { m_observers.insert(observer); });
+    m_executor.execute([this, observer]() { m_observers.insert(observer); });
 }
 
 void SpeechSynthesizer::removeObserver(std::shared_ptr<SpeechSynthesizerObserverInterface> observer) {
@@ -277,7 +277,7 @@ void SpeechSynthesizer::onDeregistered() {
 void SpeechSynthesizer::handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) {
     ACSDK_DEBUG9(LX("handleDirectiveImmediately").d("messageId", directive->getMessageId()));
     auto info = createDirectiveInfo(directive, nullptr);
-    m_executor.submit([this, info]() { executeHandleImmediately(info); });
+    m_executor.execute([this, info]() { executeHandleImmediately(info); });
 }
 
 void SpeechSynthesizer::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
@@ -287,7 +287,7 @@ void SpeechSynthesizer::preHandleDirective(std::shared_ptr<DirectiveInfo> info)
     }
 
     ACSDK_DEBUG9(LX("preHandleDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executePreHandle(info); });
+    m_executor.execute([this, info]() { executePreHandle(info); });
 }
 
 void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
@@ -300,13 +300,13 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
     if (info->directive->getName() == "Speak") {
         ACSDK_METRIC_MSG(TAG, info->directive, Metrics::Location::SPEECH_SYNTHESIZER_RECEIVE);
     }
-    m_executor.submit([this, info]() { executeHandle(info); });
+    m_executor.execute([this, info]() { executeHandle(info); });
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
     if (info && info->directive) {
         ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-        m_executor.submit([this, info]() { executeCancel(info); });
+        m_executor.execute([this, info]() { executeCancel(info); });
     } else {
         ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
     }
@@ -340,7 +340,7 @@ void SpeechSynthesizer::onFocusChanged(FocusState newFocus, MixingBehavior behav
     }
 
     auto currentInfo = std::make_shared<std::shared_ptr<SpeakDirectiveInfo>>(nullptr);
-    m_executor.submit([this, desiredState, currentInfo]() {
+    m_executor.execute([this, desiredState, currentInfo]() {
         *currentInfo = m_currentInfo;
         executeStateChange(desiredState);
     });
@@ -354,7 +354,7 @@ void SpeechSynthesizer::onFocusChanged(FocusState newFocus, MixingBehavior behav
                         .d("initialDesiredState", desiredState)
                         .d("desiredState", m_desiredState)
                         .d("currentState", m_currentState));
-        m_executor.submit([this, currentInfo]() {
+        m_executor.execute([this, currentInfo]() {
             ACSDK_DEBUG9(
                 LX("onFocusChangedLambda")
                     .d("currentInfo",
@@ -377,7 +377,7 @@ void SpeechSynthesizer::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     const unsigned int stateRequestToken) {
     ACSDK_DEBUG9(LX("provideState").d("token", stateRequestToken));
-    m_executor.submit([this, stateRequestToken]() {
+    m_executor.execute([this, stateRequestToken]() {
         std::lock_guard<std::mutex> lock(m_mutex);
         executeProvideStateLocked(stateRequestToken);
     });
@@ -404,7 +404,7 @@ void SpeechSynthesizer::onPlaybackStarted(SourceId id, const MediaPlayerState&)
     ACSDK_DEBUG9(LX("onPlaybackStarted").d("callbackSourceId", id));
     ACSDK_METRIC_IDS(TAG, "SpeechStarted", "", "", Metrics::Location::SPEECH_SYNTHESIZER_RECEIVE);
 
-    m_executor.submit([this, id] {
+    m_executor.execute([this, id] {
         if (id != m_mediaSourceId) {
             ACSDK_ERROR(LX("queueingExecutePlaybackStartedFailed")
                             .d("reason", "mismatchSourceId")
@@ -429,7 +429,7 @@ void SpeechSynthesizer::onPlaybackFinished(SourceId id, const MediaPlayerState&)
     ACSDK_DEBUG9(LX("onPlaybackFinished").d("callbackSourceId", id));
     ACSDK_METRIC_IDS(TAG, "SpeechFinished", "", "", Metrics::Location::SPEECH_SYNTHESIZER_RECEIVE);
 
-    m_executor.submit([this, id] {
+    m_executor.execute([this, id] {
         if (id != m_mediaSourceId) {
             ACSDK_ERROR(LX("queueingExecutePlaybackFinishedFailed")
                             .d("reason", "mismatchSourceId")
@@ -456,13 +456,13 @@ void SpeechSynthesizer::onPlaybackError(
     std::string error,
     const MediaPlayerState&) {
     ACSDK_DEBUG9(LX("onPlaybackError").d("callbackSourceId", id));
-    m_executor.submit([this, type, error]() { executePlaybackError(type, error); });
+    m_executor.execute([this, type, error]() { executePlaybackError(type, error); });
 }
 
 void SpeechSynthesizer::onPlaybackStopped(SourceId id, const MediaPlayerState&) {
     ACSDK_DEBUG9(LX("onPlaybackStopped").d("callbackSourceId", id));
 
-    m_executor.submit([this, id]() { executePlaybackStopped(id); });
+    m_executor.execute([this, id]() { executePlaybackStopped(id); });
 }
 
 void SpeechSynthesizer::onBufferUnderrun(SourceId id, const MediaPlayerState&) {
@@ -802,7 +802,11 @@ void SpeechSynthesizer::executeHandleAfterValidation(std::shared_ptr<SpeakDirect
     setDesiredState(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING);
 
     auto activity = FocusManagerInterface::Activity::create(
-        NAMESPACE, shared_from_this(), std::chrono::milliseconds::zero(), avsCommon::avs::ContentType::MIXABLE);
+        NAMESPACE,
+        shared_from_this(),
+        std::chrono::milliseconds::zero(),
+        avsCommon::avs::ContentType::MIXABLE,
+        {avsCommon::avs::AudioAttributes::Usage::SPEECH});
     if (!m_focusManager->acquireChannel(CHANNEL_NAME, activity)) {
         static const std::string message = std::string("Could not acquire ") + CHANNEL_NAME + " for " + NAMESPACE;
         ACSDK_ERROR(LX("executeHandleFailed")
@@ -1399,7 +1403,7 @@ void SpeechSynthesizer::resetMediaSourceId() {
 }
 
 void SpeechSynthesizer::onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
-    m_executor.submit([this, newState]() { executeOnDialogUXStateChanged(newState); });
+    m_executor.execute([this, newState]() { executeOnDialogUXStateChanged(newState); });
 }
 
 void SpeechSynthesizer::executeOnDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
diff --git a/CapabilityAgents/System/src/LocaleHandler.cpp b/CapabilityAgents/System/src/LocaleHandler.cpp
index a850e8dc..0c6845d2 100644
--- a/CapabilityAgents/System/src/LocaleHandler.cpp
+++ b/CapabilityAgents/System/src/LocaleHandler.cpp
@@ -115,7 +115,7 @@ void LocaleHandler::handleDirective(std::shared_ptr<CapabilityAgent::DirectiveIn
         ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirective"));
         return;
     }
-    m_executor.submit([this, info]() { executeHandleDirective(info); });
+    m_executor.execute([this, info]() { executeHandleDirective(info); });
 }
 
 void LocaleHandler::cancelDirective(std::shared_ptr<CapabilityAgent::DirectiveInfo> info) {
diff --git a/CapabilityAgents/System/src/ReportStateHandler.cpp b/CapabilityAgents/System/src/ReportStateHandler.cpp
index e361dad6..b39bf9d0 100644
--- a/CapabilityAgents/System/src/ReportStateHandler.cpp
+++ b/CapabilityAgents/System/src/ReportStateHandler.cpp
@@ -171,7 +171,7 @@ void ReportStateHandler::handleDirectiveImmediately(std::shared_ptr<AVSDirective
         return;
     }
 
-    m_executor.submit([this, directive] { handleReportState(*directive); });
+    m_executor.execute([this, directive] { handleReportState(*directive); });
 }
 
 void ReportStateHandler::handleDirective(std::shared_ptr<CapabilityAgent::DirectiveInfo> info) {
@@ -185,7 +185,7 @@ void ReportStateHandler::handleDirective(std::shared_ptr<CapabilityAgent::Direct
         return;
     }
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         auto ok = handleReportState(*(info->directive));
         if (info->result) {
             if (ok) {
@@ -241,7 +241,7 @@ void ReportStateHandler::initialize() {
     m_connectionObserver = SettingConnectionObserver::create([this](bool isConnected) {
         if (isConnected) {
             std::lock_guard<std::mutex> lock(m_stateMutex);
-            m_executor.submit([this] { sendReportState(); });
+            m_executor.execute([this] { sendReportState(); });
         }
     });
     m_connectionManager->addConnectionStatusObserver(m_connectionObserver);
diff --git a/CapabilityAgents/System/src/TimeZoneHandler.cpp b/CapabilityAgents/System/src/TimeZoneHandler.cpp
index 73c398d9..00962426 100644
--- a/CapabilityAgents/System/src/TimeZoneHandler.cpp
+++ b/CapabilityAgents/System/src/TimeZoneHandler.cpp
@@ -85,7 +85,7 @@ void TimeZoneHandler::handleDirectiveImmediately(std::shared_ptr<AVSDirective> d
         return;
     }
     auto info = createDirectiveInfo(directive, nullptr);
-    m_executor.submit([this, info]() { executeHandleDirectiveImmediately(info); });
+    m_executor.execute([this, info]() { executeHandleDirectiveImmediately(info); });
 }
 void TimeZoneHandler::preHandleDirective(std::shared_ptr<CapabilityAgent::DirectiveInfo> info) {
     // intentional no-op
@@ -95,7 +95,7 @@ void TimeZoneHandler::handleDirective(std::shared_ptr<CapabilityAgent::Directive
         ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "info is nullptr."));
         return;
     }
-    m_executor.submit([this, info]() { executeHandleDirectiveImmediately(info); });
+    m_executor.execute([this, info]() { executeHandleDirectiveImmediately(info); });
 }
 void TimeZoneHandler::cancelDirective(std::shared_ptr<CapabilityAgent::DirectiveInfo> info) {
     // intentional no-op
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 5a19ef69..df2a6c8a 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -214,12 +214,12 @@ DirectiveHandlerConfiguration TemplateRuntime::getConfiguration() const {
 }
 
 void TemplateRuntime::onFocusChanged(avsCommon::avs::FocusState newFocus, MixingBehavior) {
-    m_executor.submit([this, newFocus]() { executeOnFocusChangedEvent(newFocus); });
+    m_executor.execute([this, newFocus]() { executeOnFocusChangedEvent(newFocus); });
 }
 
 void TemplateRuntime::onRenderPlayerCardsInfoChanged(avsCommon::avs::PlayerActivity state, const Context& context) {
     ACSDK_DEBUG5(LX("onRenderPlayerCardsInfoChanged"));
-    m_executor.submit([this, state, context]() {
+    m_executor.execute([this, state, context]() {
         ACSDK_DEBUG5(LX("onPlayerActivityChangedInExecutor"));
         executeAudioPlayerInfoUpdates(state, context);
     });
@@ -228,7 +228,7 @@ void TemplateRuntime::onRenderPlayerCardsInfoChanged(avsCommon::avs::PlayerActiv
 void TemplateRuntime::onDialogUXStateChanged(
     avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) {
     ACSDK_DEBUG5(LX("onDialogUXStateChanged").d("state", newState));
-    m_executor.submit([this, newState]() {
+    m_executor.execute([this, newState]() {
         if (TemplateRuntime::State::DISPLAYING == m_state && m_lastDisplayedDirective &&
             m_lastDisplayedDirective->directive->getName() == RENDER_TEMPLATE) {
             if (avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE == newState) {
@@ -249,7 +249,7 @@ void TemplateRuntime::addObserver(
         ACSDK_ERROR(LX("addObserver").m("Observer is null."));
         return;
     }
-    m_executor.submit([this, observer]() {
+    m_executor.execute([this, observer]() {
         ACSDK_DEBUG5(LX("addObserverInExecutor"));
         if (!m_observers.insert(observer).second) {
             ACSDK_ERROR(LX("addObserverInExecutor").m("Duplicate observer."));
@@ -264,7 +264,7 @@ void TemplateRuntime::removeObserver(
         ACSDK_ERROR(LX("removeObserver").m("Observer is null."));
         return;
     }
-    m_executor.submit([this, observer]() {
+    m_executor.execute([this, observer]() {
         ACSDK_DEBUG5(LX("removeObserverInExecutor"));
         if (m_observers.erase(observer) == 0) {
             ACSDK_WARN(LX("removeObserverInExecutor").m("Nonexistent observer."));
@@ -320,7 +320,7 @@ void TemplateRuntime::removeDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void TemplateRuntime::displayCardCleared() {
-    m_executor.submit([this]() { executeCardClearedEvent(); });
+    m_executor.execute([this]() { executeCardClearedEvent(); });
 }
 
 void TemplateRuntime::setHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
@@ -333,7 +333,7 @@ void TemplateRuntime::setHandlingCompleted(std::shared_ptr<DirectiveInfo> info)
 void TemplateRuntime::handleRenderTemplateDirective(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG5(LX("handleRenderTemplateDirective"));
 
-    m_executor.submit([this, info]() {
+    m_executor.execute([this, info]() {
         ACSDK_DEBUG5(LX("handleRenderTemplateDirectiveInExecutor"));
         m_isRenderTemplateLastReceived = true;
         executeDisplayCardEvent(info);
@@ -344,7 +344,7 @@ void TemplateRuntime::handleRenderTemplateDirective(std::shared_ptr<DirectiveInf
 void TemplateRuntime::handleRenderPlayerInfoDirective(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG5(LX("handleRenderPlayerInfoDirective"));
 
-    m_executor.submit([this, info]() {
+    m_executor.execute([this, info]() {
         ACSDK_DEBUG5(LX("handleRenderPlayerInfoDirectiveInExecutor"));
         m_isRenderTemplateLastReceived = false;
 
@@ -417,7 +417,7 @@ void TemplateRuntime::handleUnknownDirective(std::shared_ptr<DirectiveInfo> info
                     .d("namespace", info->directive->getNamespace())
                     .d("name", info->directive->getName()));
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         const std::string exceptionMessage =
             "unexpected directive " + info->directive->getNamespace() + ":" + info->directive->getName();
 
@@ -575,7 +575,7 @@ void TemplateRuntime::executeClearCard() {
 void TemplateRuntime::executeStartTimer(std::chrono::milliseconds timeout) {
     if (TemplateRuntime::State::DISPLAYING == m_state) {
         ACSDK_DEBUG3(LX("executeStartTimer").d("timeoutInMilliseconds", timeout.count()));
-        m_clearDisplayTimer.start(timeout, [this] { m_executor.submit([this] { executeTimerEvent(); }); });
+        m_clearDisplayTimer.start(timeout, [this] { m_executor.execute([this] { executeTimerEvent(); }); });
     }
 }
 
diff --git a/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp b/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
index 5d9de1ab..1a5e37df 100644
--- a/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
@@ -202,7 +202,7 @@ void ToggleControllerCapabilityAgent::handleDirective(std::shared_ptr<DirectiveI
         return;
     }
 
-    m_executor.submit([this, info] {
+    m_executor.execute([this, info] {
         ACSDK_DEBUG5(LX("handleDirectiveInExecutor"));
         const std::string directiveName = info->directive->getName();
         if (!info->directive->getEndpoint().hasValue() ||
@@ -242,7 +242,7 @@ void ToggleControllerCapabilityAgent::provideState(
     ACSDK_DEBUG5(
         LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
 
-    m_executor.submit([this, stateProviderName, contextRequestToken] {
+    m_executor.execute([this, stateProviderName, contextRequestToken] {
         ACSDK_DEBUG5(LX("provideStateInExecutor"));
         executeProvideState(stateProviderName, contextRequestToken);
     });
@@ -316,7 +316,7 @@ void ToggleControllerCapabilityAgent::onToggleStateChanged(
         return;
     }
 
-    m_executor.submit([this, toggleState, cause] {
+    m_executor.execute([this, toggleState, cause] {
         m_contextManager->reportStateChange(
             CapabilityTag(NAMESPACE, TOGGLESTATE_PROPERTY_NAME, m_endpointId, m_instance),
             buildCapabilityState(toggleState),
diff --git a/ContextManager/src/ContextManager.cpp b/ContextManager/src/ContextManager.cpp
index 6631034a..2a30c12a 100644
--- a/ContextManager/src/ContextManager.cpp
+++ b/ContextManager/src/ContextManager.cpp
@@ -143,7 +143,7 @@ SetStateResult ContextManager::setState(
     ACSDK_DEBUG5(LX(__func__).sensitive("capability", capabilityIdentifier));
 
     if (EMPTY_TOKEN == stateRequestToken) {
-        m_executor.submit([this, capabilityIdentifier, jsonState, refreshPolicy] {
+        m_executor.execute([this, capabilityIdentifier, jsonState, refreshPolicy] {
             updateCapabilityState(capabilityIdentifier, jsonState, refreshPolicy);
         });
         return SetStateResult::SUCCESS;
@@ -169,7 +169,7 @@ SetStateResult ContextManager::setState(
         return SetStateResult::STATE_PROVIDER_NOT_REGISTERED;
     }
 
-    m_executor.submit([this, capabilityIdentifier, jsonState, refreshPolicy, stateRequestToken] {
+    m_executor.execute([this, capabilityIdentifier, jsonState, refreshPolicy, stateRequestToken] {
         updateCapabilityState(capabilityIdentifier, jsonState, refreshPolicy);
         if (jsonState.empty() && (StateRefreshPolicy::ALWAYS == refreshPolicy)) {
             ACSDK_ERROR(LX("setStateFailed")
@@ -218,7 +218,7 @@ void ContextManager::reportStateChange(
     AlexaStateChangeCauseType cause) {
     ACSDK_DEBUG5(LX(__func__).sensitive("capability", capabilityIdentifier));
 
-    m_executor.submit([this, capabilityIdentifier, capabilityState, cause] {
+    m_executor.execute([this, capabilityIdentifier, capabilityState, cause] {
         updateCapabilityState(capabilityIdentifier, capabilityState);
         std::lock_guard<std::mutex> observerMutex{m_observerMutex};
         for (auto& observer : m_observers) {
@@ -233,7 +233,7 @@ void ContextManager::provideStateResponse(
     ContextRequestToken stateRequestToken) {
     ACSDK_DEBUG5(LX(__func__).sensitive("capability", capabilityIdentifier));
 
-    m_executor.submit([this, capabilityIdentifier, capabilityState, stateRequestToken] {
+    m_executor.execute([this, capabilityIdentifier, capabilityState, stateRequestToken] {
         std::function<void()> contextAvailableCallback = NoopCallback;
         {
             std::lock_guard<std::mutex> requestsLock{m_requestsMutex};
@@ -274,7 +274,7 @@ void ContextManager::provideStateUnavailableResponse(
     bool isEndpointUnreachable) {
     ACSDK_DEBUG5(LX(__func__).sensitive("capability", capabilityIdentifier));
 
-    m_executor.submit([this, capabilityIdentifier, stateRequestToken, isEndpointUnreachable] {
+    m_executor.execute([this, capabilityIdentifier, stateRequestToken, isEndpointUnreachable] {
         std::function<void()> contextAvailableCallback = NoopCallback;
         std::function<void()> contextFailureCallback = NoopCallback;
         {
@@ -361,10 +361,10 @@ ContextRequestToken ContextManager::getContextInternal(
     bool bSkipReportableStateProperties) {
     ACSDK_DEBUG5(LX(__func__).sensitive("endpointId", endpointId));
     auto token = generateToken();
-    m_executor.submit([this, contextRequester, endpointId, token, timeout, bSkipReportableStateProperties] {
+    m_executor.execute([this, contextRequester, endpointId, token, timeout, bSkipReportableStateProperties] {
         auto timerToken = m_multiTimer->submitTask(timeout, [this, token] {
             // Cancel request after timeout.
-            m_executor.submit([this, token] {
+            m_executor.execute([this, token] {
                 std::function<void()> contextFailureCallback = NoopCallback;
                 {
                     std::lock_guard<std::mutex> lock{m_requestsMutex};
@@ -487,7 +487,7 @@ std::function<void()> ContextManager::getContextAvailableCallbackIfReadyLocked(
         return NoopCallback;
     }
 
-    AVSContext context;
+    auto context = std::make_shared<AVSContext>();
     auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
     for (auto& capability : m_endpointsState[requestEndpointId]) {
         auto stateProvider = capability.second.stateProvider;
@@ -516,7 +516,7 @@ std::function<void()> ContextManager::getContextAvailableCallbackIfReadyLocked(
 
         if (addState) {
             ACSDK_DEBUG5(LX(__func__).sensitive("addState", capability.first));
-            context.addState(capability.first, stateInfo.capabilityState.value());
+            context->addState(capability.first, stateInfo.capabilityState.value());
         }
     }
     auto contextRequester = request.contextRequester;
diff --git a/ContextManager/test/ContextManagerTest.cpp b/ContextManager/test/ContextManagerTest.cpp
index 54a6b4b1..6885c372 100644
--- a/ContextManager/test/ContextManagerTest.cpp
+++ b/ContextManager/test/ContextManagerTest.cpp
@@ -62,7 +62,7 @@ struct MockLegacyStateProvider : public StateProviderInterface {
 struct MockContextRequester : public ContextRequesterInterface {
     MOCK_METHOD3(
         onContextAvailable,
-        void(const std::string& endpointId, const avs::AVSContext& endpointContext, ContextRequestToken requestToken));
+        void(const std::string& endpointId, const std::shared_ptr<avs::AVSContext>& endpointContext, ContextRequestToken requestToken));
     MOCK_METHOD2(onContextFailure, void(const ContextRequestError error, ContextRequestToken token));
 };
 
@@ -135,8 +135,8 @@ TEST_F(ContextManagerTest, test_getContextLegacyProvider) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     auto requestToken = m_contextManager->getContext(requester);
@@ -263,8 +263,8 @@ TEST_F(ContextManagerTest, test_sometimesProviderWithValidState) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     auto requestToken = m_contextManager->getContext(requester);
@@ -297,8 +297,8 @@ TEST_F(ContextManagerTest, test_sometimesProviderWithEmptyState) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     auto requestToken = m_contextManager->getContext(requester);
@@ -329,8 +329,8 @@ TEST_F(ContextManagerTest, test_neverProvider) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     m_contextManager->getContext(requester);
@@ -366,8 +366,8 @@ TEST_F(ContextManagerTest, test_getEndpointContextShouldIncludeOnlyRelevantState
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     // Get context for the target endpoint.
@@ -439,8 +439,8 @@ TEST_F(ContextManagerTest, test_getContextWhenStateUnavailableShouldReturnCache)
 
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     // Respond that state is unavailable after state has been requested.
@@ -511,14 +511,14 @@ TEST_F(ContextManagerTest, test_getContextInParallelShouldSucceed) {
     auto requester1 = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise1;
     EXPECT_CALL(*requester1, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise1](const AVSContext& context) {
-            contextStatesPromise1.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise1](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise1.set_value(context->getStates());
         })));
     auto requester2 = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise2;
     EXPECT_CALL(*requester2, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise2](const AVSContext& context) {
-            contextStatesPromise2.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise2](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise2.set_value(context->getStates());
         })));
 
     // Get context for both endpoints.
@@ -573,8 +573,8 @@ TEST_F(ContextManagerTest, test_getContextWithoutReportableStateProperties) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     // Get context for the target endpoint.
@@ -620,8 +620,8 @@ TEST_F(ContextManagerTest, test_getContextWithReportableStateProperties) {
     auto requester = std::make_shared<MockContextRequester>();
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     // Get context for the target endpoint.
@@ -660,8 +660,8 @@ TEST_F(ContextManagerTest, test_getContextShouldReturnCache) {
 
     std::promise<AVSContext::States> contextStatesPromise;
     EXPECT_CALL(*requester, onContextAvailable(_, _, _))
-        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
-            contextStatesPromise.set_value(context.getStates());
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const std::shared_ptr<AVSContext>& context) {
+            contextStatesPromise.set_value(context->getStates());
         })));
 
     auto statesFuture = contextStatesPromise.get_future();
diff --git a/Diagnostics/src/DevicePropertyAggregator.cpp b/Diagnostics/src/DevicePropertyAggregator.cpp
index f6a20010..d1319e2a 100644
--- a/Diagnostics/src/DevicePropertyAggregator.cpp
+++ b/Diagnostics/src/DevicePropertyAggregator.cpp
@@ -127,7 +127,7 @@ void DevicePropertyAggregator::onAuthStateChange(
             break;
     }
 
-    m_executor.submit([this, registered]() {
+    m_executor.execute([this, registered]() {
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::REGISTRATION_STATUS] = toString(registered);
     });
 }
@@ -260,7 +260,7 @@ Optional<std::string> DevicePropertyAggregator::getDeviceContextJson() {
 
 void DevicePropertyAggregator::onAlertStateChange(const AlertObserverInterface::AlertInfo& alertInfo) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, alertInfo]() {
+    m_executor.execute([this, alertInfo]() {
         std::stringstream ss;
         ss << alertInfo.type << ":" << alertInfo.state;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::ALERT_TYPE_AND_STATE] = ss.str();
@@ -271,7 +271,7 @@ void DevicePropertyAggregator::onPlayerActivityChanged(
     PlayerActivity state,
     const AudioPlayerObserverInterface::Context& context) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, state, context]() {
+    m_executor.execute([this, state, context]() {
         std::string playerActivityState = avsCommon::avs::playerActivityToString(state);
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::AUDIO_PLAYER_STATE] = playerActivityState;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::CONTENT_ID] = context.audioItemId;
@@ -280,7 +280,7 @@ void DevicePropertyAggregator::onPlayerActivityChanged(
 
 void DevicePropertyAggregator::onConnectionStatusChanged(const Status status, const ChangedReason reason) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, status]() {
+    m_executor.execute([this, status]() {
         std::stringstream ss;
         ss << status;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::CONNECTION_STATE] = ss.str();
@@ -289,7 +289,7 @@ void DevicePropertyAggregator::onConnectionStatusChanged(const Status status, co
 
 void DevicePropertyAggregator::onSetIndicator(IndicatorState state) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         std::stringstream ss;
         ss << state;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::NOTIFICATION_INDICATOR] = ss.str();
@@ -302,7 +302,7 @@ void DevicePropertyAggregator::onNotificationReceived() {
 
 void DevicePropertyAggregator::onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, newState]() {
+    m_executor.execute([this, newState]() {
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::TTS_PLAYER_STATE] =
             DialogUXStateObserverInterface::stateToString(newState);
     });
@@ -313,7 +313,7 @@ void DevicePropertyAggregator::onSpeakerSettingsChanged(
     const ChannelVolumeInterface::Type& type,
     const SpeakerInterface::SpeakerSettings& settings) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, type, settings]() { updateSpeakerSettingsInPropertyMap(type, settings); });
+    m_executor.execute([this, type, settings]() { updateSpeakerSettingsInPropertyMap(type, settings); });
 }
 
 void DevicePropertyAggregator::updateSpeakerSettingsInPropertyMap(
@@ -338,7 +338,7 @@ void DevicePropertyAggregator::updateSpeakerSettingsInPropertyMap(
 
 void DevicePropertyAggregator::onRangeChanged(const RangeState& rangeState, const AlexaStateChangeCauseType cause) {
     ACSDK_DEBUG5(LX(__func__).d("range value", rangeState.value));
-    m_executor.submit([this, rangeState]() {
+    m_executor.execute([this, rangeState]() {
         std::stringstream ss;
         ss << rangeState.value;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::RANGE_CONTROLLER_STATUS] = ss.str();
@@ -349,7 +349,7 @@ void DevicePropertyAggregator::onPowerStateChanged(
     const PowerState& powerState,
     const AlexaStateChangeCauseType cause) {
     ACSDK_DEBUG5(LX(__func__).d("power state", powerState.powerState));
-    m_executor.submit([this, powerState]() {
+    m_executor.execute([this, powerState]() {
         std::stringstream ss;
         ss << powerState.powerState;
         m_asyncPropertyMap[DevicePropertyAggregatorInterface::POWER_CONTROLLER_STATUS] = ss.str();
diff --git a/Endpoints/src/EndpointRegistrationManager.cpp b/Endpoints/src/EndpointRegistrationManager.cpp
index ba026763..bdc8d64c 100644
--- a/Endpoints/src/EndpointRegistrationManager.cpp
+++ b/Endpoints/src/EndpointRegistrationManager.cpp
@@ -117,7 +117,7 @@ std::future<EndpointRegistrationManager::RegistrationResult> EndpointRegistratio
         return promise.get_future();
     }
 
-    m_executor.submit([this, endpoint]() { executeRegisterEndpoint(endpoint); });
+    m_executor.execute([this, endpoint]() { executeRegisterEndpoint(endpoint); });
 
     auto& pending = m_pendingRegistrations[endpointId];
     pending.first = std::move(endpoint);
@@ -160,7 +160,7 @@ std::future<EndpointRegistrationManager::UpdateResult> EndpointRegistrationManag
     }
 
     auto endpoint = m_endpoints[endpointId];
-    m_executor.submit(
+    m_executor.execute(
         [this, endpoint, endpointModificationData]() { executeUpdateEndpoint(endpoint, endpointModificationData); });
     auto& pending = m_pendingUpdates[endpointId];
     pending.first = std::move(endpoint);
@@ -219,7 +219,7 @@ std::future<EndpointRegistrationManager::DeregistrationResult> EndpointRegistrat
 
     auto endpoint = m_endpoints[endpointId];
 
-    m_executor.submit([this, endpoint]() { executeDeregisterEndpoint(endpoint); });
+    m_executor.execute([this, endpoint]() { executeDeregisterEndpoint(endpoint); });
 
     auto& pending = m_pendingDeregistrations[endpointId];
     pending.first = std::move(endpoint);
@@ -472,7 +472,7 @@ void EndpointRegistrationManager::onCapabilityRegistrationStatusChanged(
     const std::pair<CapabilityRegistrationProxy::State, std::vector<EndpointIdentifier>>& addedOrUpdatedEndpoints,
     const std::pair<CapabilityRegistrationProxy::State, std::vector<EndpointIdentifier>>& deletedEndpoints) {
     ACSDK_DEBUG5(LX(__func__));
-    m_executor.submit([this, addedOrUpdatedEndpoints, deletedEndpoints] {
+    m_executor.execute([this, addedOrUpdatedEndpoints, deletedEndpoints] {
         updateAddedOrUpdatedEndpoints(addedOrUpdatedEndpoints);
         removeDeletedEndpoints(deletedEndpoints);
     });
diff --git a/Integration/test/AlertsIntegrationTest.cpp b/Integration/test/AlertsIntegrationTest.cpp
index b9e276df..ed384573 100644
--- a/Integration/test/AlertsIntegrationTest.cpp
+++ b/Integration/test/AlertsIntegrationTest.cpp
@@ -295,7 +295,7 @@ protected:
             m_context->getMessageRouter(), false, m_context->getConnectionStatusObserver(), m_messageInterpreter);
         ASSERT_TRUE(m_avsConnectionManager);
 
-        m_focusManager = std::make_shared<FocusManager>(FocusManager::getDefaultAudioChannels());
+        m_focusManager = afml::FocusManager::create(FocusManager::getDefaultAudioChannels());
         std::shared_ptr<avsCommon::sdkInterfaces::test::MockSpeakerManager> mockSpeakerManager =
             std::make_shared<avsCommon::sdkInterfaces::test::MockSpeakerManager>();
         ON_CALL(*(mockSpeakerManager.get()), getSpeakerSettings(testing::_, testing::_))
diff --git a/Integration/test/AudioInputProcessorIntegrationTest.cpp b/Integration/test/AudioInputProcessorIntegrationTest.cpp
index d1743ae9..7bcf0ff3 100644
--- a/Integration/test/AudioInputProcessorIntegrationTest.cpp
+++ b/Integration/test/AudioInputProcessorIntegrationTest.cpp
@@ -294,7 +294,7 @@ public:
     }
 
     void provideState(const NamespaceAndName& nsname, const unsigned int stateRequestToken) override {
-        m_executor.submit([this, stateRequestToken] {
+        m_executor.execute([this, stateRequestToken] {
             std::ostringstream context;
             context << R"({)"
                        R"("volume":)"
@@ -442,7 +442,7 @@ protected:
 
         m_tapToTalkButton = std::make_shared<tapToTalkButton>();
         m_holdToTalkButton = std::make_shared<holdToTalkButton>();
-        m_focusManager = std::make_shared<FocusManager>(FocusManager::getDefaultAudioChannels());
+        m_focusManager = afml::FocusManager::create(FocusManager::getDefaultAudioChannels());
         m_dialogUXStateAggregator = std::make_shared<avsCommon::avs::DialogUXStateAggregator>();
 
         m_stateProvider = std::make_shared<testStateProvider>(m_context->getContextManager());
diff --git a/Integration/test/AudioPlayerIntegrationTest.cpp b/Integration/test/AudioPlayerIntegrationTest.cpp
index bd3d00f8..ae6db41d 100644
--- a/Integration/test/AudioPlayerIntegrationTest.cpp
+++ b/Integration/test/AudioPlayerIntegrationTest.cpp
@@ -283,7 +283,7 @@ protected:
         std::vector<FocusManager::ChannelConfiguration> channelConfigurations{
             dialogChannelConfig, contentChannelConfig, testChannelConfig};
 
-        m_focusManager = std::make_shared<FocusManager>(channelConfigurations);
+        m_focusManager = afml::FocusManager::create(FocusManager::getDefaultAudioChannels());
         m_testContentClient = std::make_shared<TestClient>();
         ASSERT_TRUE(m_focusManager->acquireChannel(TEST_CHANNEL_NAME, m_testContentClient, TEST_ACTIVITY_ID));
         bool focusChanged;
diff --git a/Integration/test/SpeechSynthesizerIntegrationTest.cpp b/Integration/test/SpeechSynthesizerIntegrationTest.cpp
index 2fda71d7..2c39ce87 100644
--- a/Integration/test/SpeechSynthesizerIntegrationTest.cpp
+++ b/Integration/test/SpeechSynthesizerIntegrationTest.cpp
@@ -344,7 +344,7 @@ protected:
 
         connect();
 
-        m_focusManager = std::make_shared<FocusManager>(FocusManager::getDefaultAudioChannels());
+        m_focusManager = afml::FocusManager::create(FocusManager::getDefaultAudioChannels());
         m_testClient = std::make_shared<TestClient>();
         ASSERT_TRUE(m_focusManager->acquireChannel(FocusManager::ALERT_CHANNEL_NAME, m_testClient, ALERTS_ACTIVITY_ID));
         ASSERT_EQ(m_testClient->waitForFocusChange(WAIT_FOR_TIMEOUT_DURATION), FocusState::FOREGROUND);
diff --git a/MediaPlayer/AndroidSLESMediaPlayer/src/AndroidSLESMediaQueue.cpp b/MediaPlayer/AndroidSLESMediaPlayer/src/AndroidSLESMediaQueue.cpp
index ac1e4242..8eee2e31 100644
--- a/MediaPlayer/AndroidSLESMediaPlayer/src/AndroidSLESMediaQueue.cpp
+++ b/MediaPlayer/AndroidSLESMediaPlayer/src/AndroidSLESMediaQueue.cpp
@@ -89,7 +89,7 @@ std::unique_ptr<AndroidSLESMediaQueue> AndroidSLESMediaQueue::create(
 }
 
 void AndroidSLESMediaQueue::onBufferFree() {
-    m_executor.submit([this]() { fillBuffer(); });
+    m_executor.execute([this]() { fillBuffer(); });
 }
 
 AndroidSLESMediaQueue::~AndroidSLESMediaQueue() {
@@ -212,7 +212,7 @@ void AndroidSLESMediaQueue::enqueueSilence(const PlaybackConfiguration& configur
 void AndroidSLESMediaQueue::fillAllBuffers(const PlaybackConfiguration& configuration) {
     enqueueSilence(configuration);
     for (; m_index < m_buffers.size(); ++m_index) {
-        m_executor.submit([this]() { fillBuffer(); });
+        m_executor.execute([this]() { fillBuffer(); });
     }
     m_index = 0;
 }
diff --git a/Metrics/MetricRecorder/src/MetricRecorder.cpp b/Metrics/MetricRecorder/src/MetricRecorder.cpp
index 4226cc98..a677e2ff 100644
--- a/Metrics/MetricRecorder/src/MetricRecorder.cpp
+++ b/Metrics/MetricRecorder/src/MetricRecorder.cpp
@@ -62,7 +62,7 @@ void MetricRecorder::recordMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
         return;
     }
 
-    m_executor.submit([this, metricEvent]() {
+    m_executor.execute([this, metricEvent]() {
         for (const auto& sink : m_sinks) {
             sink->consumeMetric(metricEvent);
         }
diff --git a/NOTICE.txt b/NOTICE.txt
index 23a42229..5af4c0c7 100644
--- a/NOTICE.txt
+++ b/NOTICE.txt
@@ -59,12 +59,12 @@ of the Amazon Software License is located at:
 ALEXA AUDIO ASSETS
 ******************
 
-Copyright 2018 Amazon.com, Inc. or its affiliates (“Amazon”).
+Copyright 2019-2022 Amazon.com, Inc. or its affiliates ("Amazon").
 All Rights Reserved.
 
-These materials are licensed to you as "Program Materials" under the Program
-Materials License Agreement, which is currently available at
-https://developer.amazon.com/support/legal/pml.
+These materials are licensed to you as “AVS Materials" under the Amazon
+Developer Services Agreement, which is currently available at
+https://developer.amazon.com/support/legal/da
 
 **********************
 THIRD PARTY COMPONENTS
diff --git a/PlaylistParser/src/PlaylistParser.cpp b/PlaylistParser/src/PlaylistParser.cpp
index cbaff442..dbf1d53e 100644
--- a/PlaylistParser/src/PlaylistParser.cpp
+++ b/PlaylistParser/src/PlaylistParser.cpp
@@ -79,7 +79,7 @@ int PlaylistParser::parsePlaylist(
 
     auto id = ++g_id;
 
-    m_executor.submit([this, id, observer, url, playlistTypesToNotBeParsed]() {
+    m_executor.execute([this, id, observer, url, playlistTypesToNotBeParsed]() {
         doDepthFirstSearch(id, observer, url, playlistTypesToNotBeParsed);
     });
     return id;
diff --git a/PlaylistParser/src/UrlContentToAttachmentConverter.cpp b/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
index d0acedde..a029060d 100644
--- a/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
+++ b/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
@@ -118,7 +118,7 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
     if (playlistEntry.type == PlaylistEntry::Type::MEDIA_INIT_INFO &&
         encryptionInfo.method == EncryptionInfo::Method::SAMPLE_AES) {
         auto totalDuration = encryptionInfo.totalDuration;
-        m_executor.submit([this, url, headers, totalDuration, playlistEntry]() {
+        m_executor.execute([this, url, headers, totalDuration, playlistEntry]() {
             ByteVector mediaInitSection;
             if (!download(url, headers, &mediaInitSection, playlistEntry.contentFetcher)) {
                 closeStreamWriter();
@@ -158,14 +158,14 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
     auto contentFetcher = playlistEntry.contentFetcher;
     switch (parseResult) {
         case avsCommon::utils::playlistParser::PlaylistParseResult::ERROR:
-            m_executor.submit([this]() {
+            m_executor.execute([this]() {
                 ACSDK_DEBUG9(LX("closingWriter"));
                 closeStreamWriter();
                 notifyError();
             });
             break;
         case avsCommon::utils::playlistParser::PlaylistParseResult::FINISHED:
-            m_executor.submit([this, url, headers, encryptionInfo, contentFetcher]() {
+            m_executor.execute([this, url, headers, encryptionInfo, contentFetcher]() {
                 ACSDK_DEBUG9(LX("calling writeDecryptedUrlContentIntoStream"));
                 if (!m_streamWriterClosed &&
                     !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo, contentFetcher)) {
@@ -178,7 +178,7 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
             });
             break;
         case avsCommon::utils::playlistParser::PlaylistParseResult::STILL_ONGOING:
-            m_executor.submit([this, url, headers, encryptionInfo, contentFetcher]() {
+            m_executor.execute([this, url, headers, encryptionInfo, contentFetcher]() {
                 if (!m_streamWriterClosed &&
                     !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo, contentFetcher)) {
                     ACSDK_ERROR(LX("writeUrlContentToStreamFailed").d("info", "closingWriter"));
@@ -188,7 +188,7 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
             });
             break;
         case avsCommon::utils::playlistParser::PlaylistParseResult::SHUTDOWN:
-            m_executor.submit([this]() {
+            m_executor.execute([this]() {
                 ACSDK_DEBUG9(LX("closingWriter"));
                 closeStreamWriter();
             });
diff --git a/SampleApp/include/SampleApp/ExternalCapabilitiesBuilder.h b/SampleApp/include/SampleApp/ExternalCapabilitiesBuilder.h
index 616631b9..9825b91f 100644
--- a/SampleApp/include/SampleApp/ExternalCapabilitiesBuilder.h
+++ b/SampleApp/include/SampleApp/ExternalCapabilitiesBuilder.h
@@ -83,6 +83,12 @@ public:
         std::shared_ptr<alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface> commsMediaPlayer,
         std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> commsSpeaker,
         std::shared_ptr<alexaClientSDK::avsCommon::avs::AudioInputStream> sharedDataStream,
+#endif
+#ifdef MULTI_AGENT_EXPERIENCE
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>
+            universalDeviceCommandsInvoker,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>
+            universalDeviceCommandsProvider,
 #endif
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ComponentReporterInterface> softwareComponentReporter,
diff --git a/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h b/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
index 0dec84fa..fb59a948 100644
--- a/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
+++ b/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
@@ -1,17 +1,17 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
+* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License").
+* You may not use this file except in compliance with the License.
+* A copy of the License is located at
+*
+*     http://aws.amazon.com/apache2.0/
+*
+* or in the "license" file accompanying this file. This file is distributed
+* on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+* express or implied. See the License for the specific language governing
+* permissions and limitations under the License.
+*/
 
 #ifndef ALEXA_CLIENT_SDK_SAMPLEAPP_INCLUDE_SAMPLEAPP_PORTAUDIOMICROPHONEWRAPPER_H_
 #define ALEXA_CLIENT_SDK_SAMPLEAPP_INCLUDE_SAMPLEAPP_PORTAUDIOMICROPHONEWRAPPER_H_
@@ -30,98 +30,107 @@ namespace sampleApp {
 /// This acts as a wrapper around PortAudio, a cross-platform open-source audio I/O library.
 class PortAudioMicrophoneWrapper : public applicationUtilities::resources::audio::MicrophoneInterface {
 public:
-    /**
-     * Creates a @c PortAudioMicrophoneWrapper.
-     *
-     * @param stream The shared data stream to write to.
-     * @return A unique_ptr to a @c PortAudioMicrophoneWrapper if creation was successful and @c nullptr otherwise.
-     */
-    static std::unique_ptr<PortAudioMicrophoneWrapper> create(std::shared_ptr<avsCommon::avs::AudioInputStream> stream);
-
-    /**
-     * Stops streaming from the microphone.
-     *
-     * @return Whether the stop was successful.
-     */
-    bool stopStreamingMicrophoneData() override;
-
-    /**
-     * Starts streaming from the microphone.
-     *
-     * @return Whether the start was successful.
-     */
-    bool startStreamingMicrophoneData() override;
-
-    /**
-     * Whether the microphone is currently streaming.
-     *
-     * @return Whether the microphone is streaming.
-     */
-    bool isStreaming() override;
-
-    /**
-     * Destructor.
-     */
-    ~PortAudioMicrophoneWrapper();
+   /**
+    * Creates a @c PortAudioMicrophoneWrapper.
+    *
+    * @param stream The shared data stream to write to.
+    * @return A unique_ptr to a @c PortAudioMicrophoneWrapper if creation was successful and @c nullptr otherwise.
+    */
+   static std::unique_ptr<PortAudioMicrophoneWrapper> create(std::shared_ptr<avsCommon::avs::AudioInputStream> stream);
+
+   /**
+    * Stops streaming from the microphone.
+    *
+    * @return Whether the stop was successful.
+    */
+   bool stopStreamingMicrophoneData() override;
+
+   /**
+    * Starts streaming from the microphone.
+    *
+    * @return Whether the start was successful.
+    */
+   bool startStreamingMicrophoneData() override;
+
+   /**
+    * Whether the microphone is currently streaming.
+    *
+    * @return Whether the microphone is streaming.
+    */
+   bool isStreaming() override;
+
+   /**
+    * Destructor.
+    */
+   ~PortAudioMicrophoneWrapper();
 
 private:
-    /**
-     * Constructor.
-     *
-     * @param stream The shared data stream to write to.
-     */
-    PortAudioMicrophoneWrapper(std::shared_ptr<avsCommon::avs::AudioInputStream> stream);
-
-    /**
-     * The callback that PortAudio will issue when audio is avaiable to read.
-     *
-     * @param inputBuffer The temporary buffer that microphone audio data will be available in.
-     * @param outputBuffer Not used here.
-     * @param numSamples The number of samples available to consume.
-     * @param timeInfo Time stamps indicated when the first sample in the buffer was captured. Not used here.
-     * @param statusFlags Flags that tell us when underflow or overflow conditions occur. Not used here.
-     * @param userData A user supplied pointer.
-     * @return A PortAudio code that will indicate how PortAudio should continue.
-     */
-    static int PortAudioCallback(
-        const void* inputBuffer,
-        void* outputBuffer,
-        unsigned long numSamples,
-        const PaStreamCallbackTimeInfo* timeInfo,
-        PaStreamCallbackFlags statusFlags,
-        void* userData);
-
-    /// Initializes PortAudio
-    bool initialize();
-
-    /**
-     * Get the optional config parameter from @c AlexaClientSDKConfig.json
-     * for setting the PortAudio stream's suggested latency.
-     *
-     * @param[out] suggestedLatency The latency as it is configured in the file.
-     * @return  @c true if the suggestedLatency is defined in the config file, @c false otherwise.
-     */
-    bool getConfigSuggestedLatency(PaTime& suggestedLatency);
-
-    /// The stream of audio data.
-    const std::shared_ptr<avsCommon::avs::AudioInputStream> m_audioInputStream;
-
-    /// The writer that will be used to writer audio data into the sds.
-    std::shared_ptr<avsCommon::avs::AudioInputStream::Writer> m_writer;
-
-    /// The PortAudio stream
-    PaStream* m_paStream;
-
-    /**
-     * A lock to seralize access to startStreamingMicrophoneData() and stopStreamingMicrophoneData() between different
-     * threads.
-     */
-    std::mutex m_mutex;
-
-    /**
-     * Whether the microphone is currently streaming.
-     */
-    bool m_isStreaming;
+   /**
+    * Constructor.
+    *
+    * @param stream The shared data stream to write to.
+    */
+   PortAudioMicrophoneWrapper(std::shared_ptr<avsCommon::avs::AudioInputStream> stream);
+
+   /**
+    * The callback that PortAudio will issue when audio is avaiable to read.
+    *
+    * @param inputBuffer The temporary buffer that microphone audio data will be available in.
+    * @param outputBuffer Not used here.
+    * @param numSamples The number of samples available to consume.
+    * @param timeInfo Time stamps indicated when the first sample in the buffer was captured. Not used here.
+    * @param statusFlags Flags that tell us when underflow or overflow conditions occur. Not used here.
+    * @param userData A user supplied pointer.
+    * @return A PortAudio code that will indicate how PortAudio should continue.
+    */
+   static int PortAudioCallback(
+       const void* inputBuffer,
+       void* outputBuffer,
+       unsigned long numSamples,
+       const PaStreamCallbackTimeInfo* timeInfo,
+       PaStreamCallbackFlags statusFlags,
+       void* userData);
+
+   /// Initializes PortAudio
+   bool initialize();
+
+   /**
+    * Get the optional config parameter from @c AlexaClientSDKConfig.json
+    * for setting the PortAudio stream's suggested latency.
+    *
+    * @param[out] suggestedLatency The latency as it is configured in the file.
+    * @return  @c true if the suggestedLatency is defined in the config file, @c false otherwise.
+    */
+   bool getConfigSuggestedLatency(PaTime& suggestedLatency);
+
+   /**
+    * Get the optional config parameter from @c AlexaClientSDKConfig.json
+    * for setting the PortAudio audio device.
+    *
+    * @param[out] deviceIndex The latency as it is configured in the file.
+    * @return  @c true if the deviceIndex is defined in the config file, @c false otherwise.
+    */
+   bool getConfigAudioDevice(PaDeviceIndex& deviceIndex);
+
+   /// The stream of audio data.
+   const std::shared_ptr<avsCommon::avs::AudioInputStream> m_audioInputStream;
+
+   /// The writer that will be used to writer audio data into the sds.
+   std::shared_ptr<avsCommon::avs::AudioInputStream::Writer> m_writer;
+
+   /// The PortAudio stream
+   PaStream* m_paStream;
+
+   /**
+    * A lock to seralize access to startStreamingMicrophoneData() and stopStreamingMicrophoneData() between different
+    * threads.
+    */
+   std::mutex m_mutex;
+
+   /**
+    * Whether the microphone is currently streaming.
+    */
+   bool m_isStreaming;
 };
 
 }  // namespace sampleApp
diff --git a/SampleApp/include/SampleApp/SampleApplication.h b/SampleApp/include/SampleApp/SampleApplication.h
index 902907c6..c7fefe70 100644
--- a/SampleApp/include/SampleApp/SampleApplication.h
+++ b/SampleApp/include/SampleApp/SampleApplication.h
@@ -61,6 +61,13 @@
 #include <BlueZ/PulseAudioBluetoothInitializer.h>
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+#include <MultiAgentExperience/AlexaAdapter/Agent/MAXConnection.h>
+#include <MultiAgentExperience/AlexaAdapter/Agent/AlexaAgentRegistration.h>
+#include <MultiAgentExperience/AlexaAdapter/Mediator/MAXDialogUXStateObserver.h>
+#include <MultiAgentExperience/AlexaAdapter/Mediator/MAXFocusMediator.h>
+#endif
+
 namespace alexaClientSDK {
 namespace sampleApp {
 
@@ -81,6 +88,9 @@ public:
         std::shared_ptr<alexaClientSDK::sampleApp::ConsoleReader> consoleReader,
         const std::vector<std::string>& configFiles,
         const std::string& logLevel = "",
+#ifdef MULTI_AGENT_EXPERIENCE
+        const std::vector<std::string>& maxConnectionDetails = {},
+#endif
         std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics = nullptr);
 
     /**
@@ -158,6 +168,12 @@ public:
             avsCommon::sdkInterfaces::ChannelVolumeInterface::Type speakerType);
     };
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    std::shared_ptr<alexaClientSDK::multiAgentExperience::agent::AlexaAgentRegistration> getAgentRegistration();
+
+    std::shared_ptr<InteractionManager> getInteractionManager();
+#endif
+
 private:
     /**
      * Initialize a SampleApplication.
@@ -173,7 +189,10 @@ private:
         std::shared_ptr<alexaClientSDK::sampleApp::ConsoleReader> consoleReader,
         const std::vector<std::string>& configFiles,
         const std::string& logLevel,
-        std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics);
+#ifdef MULTI_AGENT_EXPERIENCE
+        const std::vector<std::string>& maxConnectionDetails,
+#endif
+        std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics = nullptr);
 
     /**
      * Create an application media player.
@@ -327,6 +346,15 @@ private:
     /// The adapter that supports authorizing with LWA based methods.
     std::shared_ptr<acsdkAuthorization::lwa::LWAAuthorizationAdapter> m_lwaAdapter;
 #endif
+
+#ifdef MULTI_AGENT_EXPERIENCE
+    std::shared_ptr<alexaClientSDK::multiAgentExperience::mediator::MAXFocusMediator> m_multiAgentExperienceFocusMediator;
+    std::shared_ptr<alexaClientSDK::multiAgentExperience::mediator::MAXDialogUXStateObserver>
+        m_multiAgentDialogUXStateObserver;
+    std::shared_ptr<alexaClientSDK::multiAgentExperience::agent::AlexaAgentRegistration> m_alexaMultiAgentExperienceRegistration;
+    std::shared_ptr<alexaClientSDK::multiAgentExperience::agent::MAXConnection> m_maxConnection;
+#endif
+
 };
 
 }  // namespace sampleApp
diff --git a/SampleApp/src/CMakeLists.txt b/SampleApp/src/CMakeLists.txt
index 9c8705ae..9af14ae9 100644
--- a/SampleApp/src/CMakeLists.txt
+++ b/SampleApp/src/CMakeLists.txt
@@ -161,6 +161,12 @@ if (CRYPTO_FOUND AND PKCS11)
     target_compile_definitions(LibSampleApp PRIVATE ENABLE_PKCS11)
 endif()
 
+if (MULTI_AGENT_EXPERIENCE_ENABLED)
+    message("Linking MultiAgentExperience-Alexa-Adapter with SampleApp")
+    target_link_libraries(LibSampleApp MultiAgentExperience-Alexa-Adapter acsdkMultiAssistant)
+    
+endif()
+
 add_rpath_to_target("LibSampleApp")
 
 add_executable(SampleApp
diff --git a/SampleApp/src/ExternalCapabilitiesBuilder.cpp b/SampleApp/src/ExternalCapabilitiesBuilder.cpp
index e6f71639..68947c05 100644
--- a/SampleApp/src/ExternalCapabilitiesBuilder.cpp
+++ b/SampleApp/src/ExternalCapabilitiesBuilder.cpp
@@ -49,6 +49,10 @@
 #include <RTCSessionController/RtcscCapabilityAgent.h>
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    #include <acsdkMultiAssistant/UniversalDeviceController.h>
+#endif
+
 namespace alexaClientSDK {
 namespace sampleApp {
 
@@ -130,6 +134,12 @@ ExternalCapabilitiesBuilder::buildCapabilities(
     std::shared_ptr<alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface> commsMediaPlayer,
     std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> commsSpeaker,
     std::shared_ptr<alexaClientSDK::avsCommon::avs::AudioInputStream> sharedDataStream,
+#endif
+#ifdef MULTI_AGENT_EXPERIENCE
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface>
+        universalDeviceCommandsInvoker,
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface>
+        universalDeviceCommandsProvider,
 #endif
     std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager,
     std::shared_ptr<avsCommon::sdkInterfaces::ComponentReporterInterface> softwareComponentReporter,
@@ -283,6 +293,26 @@ ExternalCapabilitiesBuilder::buildCapabilities(
     }
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    auto universalDeviceController = alexaClientSDK::acsdkMultiAssistant::UniversalDeviceController::create(
+        exceptionSender,
+        messageSender,
+        contextManager,
+        m_deviceInfo->getDefaultEndpointId(),
+        universalDeviceCommandsInvoker,
+        universalDeviceCommandsProvider);
+
+    requireShutdownObjects.push_back(universalDeviceController);
+    Capability universalDeviceControllerCapability;
+    auto universalDeviceControllerConfigurations =
+        universalDeviceController->getCapabilityConfigurations();
+    universalDeviceControllerCapability.directiveHandler = std::move(universalDeviceController);
+    for (auto& configurationPtr : universalDeviceControllerConfigurations) {
+        universalDeviceControllerCapability.configuration = *configurationPtr;
+        capabilities.push_back(universalDeviceControllerCapability);
+    }
+#endif
+
 #ifdef ENABLE_RTCSC
     auto rtcscCapabilityAgent = capabilityAgents::rtcscCapabilityAgent::RtcscCapabilityAgent::create(
         messageSender, contextManager, exceptionSender);
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 4186d367..bbf53bbe 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -126,7 +126,7 @@ InteractionManager::InteractionManager(
 };
 
 void InteractionManager::begin() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         m_userInterface->printWelcomeScreen();
         if (m_diagnostics && m_diagnostics->getAudioInjector()) {
             m_userInterface->printAudioInjectionHeader();
@@ -136,20 +136,20 @@ void InteractionManager::begin() {
 }
 
 void InteractionManager::help() {
-    m_executor.submit([this]() { m_userInterface->printHelpScreen(); });
+    m_executor.execute([this]() { m_userInterface->printHelpScreen(); });
 }
 
 void InteractionManager::limitedHelp() {
-    m_executor.submit([this]() { m_userInterface->printLimitedHelp(); });
+    m_executor.execute([this]() { m_userInterface->printLimitedHelp(); });
 }
 
 void InteractionManager::settings() {
-    m_executor.submit([this]() { m_userInterface->printSettingsScreen(); });
+    m_executor.execute([this]() { m_userInterface->printSettingsScreen(); });
 }
 
 void InteractionManager::clearCachedEndpointIdentifiers(
     const std::vector<avsCommon::sdkInterfaces::endpoints::EndpointIdentifier>& deletedEndpoints) {
-    m_executor.submit([this, deletedEndpoints]() {
+    m_executor.execute([this, deletedEndpoints]() {
         if (m_dynamicEndpointId.hasValue() &&
             (deletedEndpoints.end() !=
              std::find(deletedEndpoints.begin(), deletedEndpoints.end(), m_dynamicEndpointId.value()))) {
@@ -160,7 +160,7 @@ void InteractionManager::clearCachedEndpointIdentifiers(
 
 #if ENABLE_ENDPOINT_CONTROLLERS
 void InteractionManager::endpointModification() {
-    m_executor.submit([this]() { m_userInterface->printEndpointModificationScreen(); });
+    m_executor.execute([this]() { m_userInterface->printEndpointModificationScreen(); });
 }
 
 bool InteractionManager::addEndpoint(const std::string& friendlyName) {
@@ -230,7 +230,7 @@ bool InteractionManager::updateEndpoint(
 }
 
 void InteractionManager::addDynamicEndpoint() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_dynamicEndpointId.hasValue()) {
             m_userInterface->printEndpointModificationError("Dynamic endpoint already added.");
         } else if (!addEndpoint("light")) {
@@ -240,7 +240,7 @@ void InteractionManager::addDynamicEndpoint() {
 }
 
 void InteractionManager::modifyDynamicEndpoint() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (!m_dynamicEndpointId.hasValue()) {
             m_userInterface->printEndpointModificationError("Dynamic endpoint not added yet.");
         } else {
@@ -265,7 +265,7 @@ void InteractionManager::modifyDynamicEndpoint() {
 }
 
 void InteractionManager::deleteDynamicEndpoint() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (!m_dynamicEndpointId.hasValue()) {
             m_userInterface->printEndpointModificationError("Dynamic endpoint not added yet.");
         } else {
@@ -281,100 +281,100 @@ void InteractionManager::deleteDynamicEndpoint() {
 }
 
 void InteractionManager::endpointController() {
-    m_executor.submit([this]() { m_userInterface->printEndpointControllerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printEndpointControllerScreen(); });
 }
 #endif
 
 #ifdef POWER_CONTROLLER
 void InteractionManager::powerController() {
-    m_executor.submit([this]() { m_userInterface->printPowerControllerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printPowerControllerScreen(); });
 }
 #endif
 
 #ifdef TOGGLE_CONTROLLER
 void InteractionManager::toggleController() {
-    m_executor.submit([this]() { m_userInterface->printToggleControllerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printToggleControllerScreen(); });
 }
 #endif
 
 #ifdef MODE_CONTROLLER
 void InteractionManager::modeController() {
-    m_executor.submit([this]() { m_userInterface->printModeControllerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printModeControllerScreen(); });
 }
 #endif
 
 #ifdef RANGE_CONTROLLER
 void InteractionManager::rangeController() {
-    m_executor.submit([this]() { m_userInterface->printRangeControllerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printRangeControllerScreen(); });
 }
 #endif
 
 void InteractionManager::locale() {
-    m_executor.submit([this]() { m_userInterface->printLocaleScreen(); });
+    m_executor.execute([this]() { m_userInterface->printLocaleScreen(); });
 }
 
 void InteractionManager::alarmVolumeRamp() {
-    m_executor.submit([this]() { m_userInterface->printAlarmVolumeRampScreen(); });
+    m_executor.execute([this]() { m_userInterface->printAlarmVolumeRampScreen(); });
 }
 
 void InteractionManager::wakewordConfirmation() {
-    m_executor.submit([this]() { m_userInterface->printWakeWordConfirmationScreen(); });
+    m_executor.execute([this]() { m_userInterface->printWakeWordConfirmationScreen(); });
 }
 
 void InteractionManager::speechConfirmation() {
-    m_executor.submit([this]() { m_userInterface->printSpeechConfirmationScreen(); });
+    m_executor.execute([this]() { m_userInterface->printSpeechConfirmationScreen(); });
 }
 
 void InteractionManager::timeZone() {
-    m_executor.submit([this]() { m_userInterface->printTimeZoneScreen(); });
+    m_executor.execute([this]() { m_userInterface->printTimeZoneScreen(); });
 }
 
 void InteractionManager::networkInfo() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoScreen(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoScreen(); });
 }
 
 void InteractionManager::networkInfoConnectionTypePrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoConnectionTypePrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoConnectionTypePrompt(); });
 }
 
 void InteractionManager::networkInfoESSIDPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoESSIDPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoESSIDPrompt(); });
 }
 
 void InteractionManager::networkInfoBSSIDPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoBSSIDPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoBSSIDPrompt(); });
 }
 
 void InteractionManager::networkInfoIpPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoIpPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoIpPrompt(); });
 }
 
 void InteractionManager::networkInfoSubnetPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoSubnetPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoSubnetPrompt(); });
 }
 
 void InteractionManager::networkInfoMacPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoMacPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoMacPrompt(); });
 }
 
 void InteractionManager::networkInfoDHCPPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoDHCPPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoDHCPPrompt(); });
 }
 
 void InteractionManager::networkInfoStaticIpPrompt() {
-    m_executor.submit([this]() { m_userInterface->printNetworkInfoStaticIpPrompt(); });
+    m_executor.execute([this]() { m_userInterface->printNetworkInfoStaticIpPrompt(); });
 }
 
 void InteractionManager::doNotDisturb() {
-    m_executor.submit([this]() { m_userInterface->printDoNotDisturbScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDoNotDisturbScreen(); });
 }
 
 void InteractionManager::errorValue() {
-    m_executor.submit([this]() { m_userInterface->printErrorScreen(); });
+    m_executor.execute([this]() { m_userInterface->printErrorScreen(); });
 }
 
 void InteractionManager::microphoneToggle() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (!m_wakeWordAudioProvider) {
             return;
         }
@@ -395,7 +395,7 @@ void InteractionManager::microphoneToggle() {
 }
 
 void InteractionManager::holdToggled() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (!m_isMicOn) {
             return;
         }
@@ -412,7 +412,7 @@ void InteractionManager::holdToggled() {
 }
 
 void InteractionManager::tap() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (!m_isMicOn) {
             return;
         }
@@ -429,31 +429,31 @@ void InteractionManager::tap() {
 }
 
 void InteractionManager::stopForegroundActivity() {
-    m_executor.submit([this]() { m_client->stopForegroundActivity(); });
+    m_executor.execute([this]() { m_client->stopForegroundActivity(); });
 }
 
 void InteractionManager::playbackPlay() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PLAY); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PLAY); });
 }
 
 void InteractionManager::playbackPause() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PAUSE); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PAUSE); });
 }
 
 void InteractionManager::playbackNext() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::NEXT); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::NEXT); });
 }
 
 void InteractionManager::playbackPrevious() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PREVIOUS); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::PREVIOUS); });
 }
 
 void InteractionManager::playbackSkipForward() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::SKIP_FORWARD); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::SKIP_FORWARD); });
 }
 
 void InteractionManager::playbackSkipBackward() {
-    m_executor.submit([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::SKIP_BACKWARD); });
+    m_executor.execute([this]() { m_client->getPlaybackRouter()->buttonPressed(PlaybackButton::SKIP_BACKWARD); });
 }
 
 void InteractionManager::playbackShuffle() {
@@ -481,28 +481,28 @@ void InteractionManager::sendGuiToggleEvent(const std::string& toggleName, Playb
     if (m_guiRenderer) {
         action = !m_guiRenderer->getGuiToggleState(toggleName);
     }
-    m_executor.submit(
+    m_executor.execute(
         [this, toggleType, action]() { m_client->getPlaybackRouter()->togglePressed(toggleType, action); });
 }
 
 void InteractionManager::speakerControl() {
-    m_executor.submit([this]() { m_userInterface->printSpeakerControlScreen(); });
+    m_executor.execute([this]() { m_userInterface->printSpeakerControlScreen(); });
 }
 
 void InteractionManager::firmwareVersionControl() {
-    m_executor.submit([this]() { m_userInterface->printFirmwareVersionControlScreen(); });
+    m_executor.execute([this]() { m_userInterface->printFirmwareVersionControlScreen(); });
 }
 
 void InteractionManager::setFirmwareVersion(avsCommon::sdkInterfaces::softwareInfo::FirmwareVersion firmwareVersion) {
-    m_executor.submit([this, firmwareVersion]() { m_client->setFirmwareVersion(firmwareVersion); });
+    m_executor.execute([this, firmwareVersion]() { m_client->setFirmwareVersion(firmwareVersion); });
 }
 
 void InteractionManager::volumeControl() {
-    m_executor.submit([this]() { m_userInterface->printVolumeControlScreen(); });
+    m_executor.execute([this]() { m_userInterface->printVolumeControlScreen(); });
 }
 
 void InteractionManager::adjustVolume(avsCommon::sdkInterfaces::ChannelVolumeInterface::Type type, int8_t delta) {
-    m_executor.submit([this, type, delta]() {
+    m_executor.execute([this, type, delta]() {
         /*
          * Group the unmute action as part of the same affordance that caused the volume change, so we don't
          * send another event. This isn't a requirement by AVS.
@@ -527,7 +527,7 @@ void InteractionManager::adjustVolume(avsCommon::sdkInterfaces::ChannelVolumeInt
 }
 
 void InteractionManager::setMute(avsCommon::sdkInterfaces::ChannelVolumeInterface::Type type, bool mute) {
-    m_executor.submit([this, type, mute]() {
+    m_executor.execute([this, type, mute]() {
         std::future<bool> future =
             m_client->getSpeakerManager()->setMute(type, mute, SpeakerManagerInterface::NotificationProperties());
         future.get();
@@ -535,7 +535,7 @@ void InteractionManager::setMute(avsCommon::sdkInterfaces::ChannelVolumeInterfac
 }
 
 void InteractionManager::confirmResetDevice() {
-    m_executor.submit([this]() { m_userInterface->printResetConfirmation(); });
+    m_executor.execute([this]() { m_userInterface->printResetConfirmation(); });
 }
 
 void InteractionManager::resetDevice() {
@@ -548,12 +548,12 @@ void InteractionManager::resetDevice() {
 }
 
 void InteractionManager::confirmReauthorizeDevice() {
-    m_executor.submit([this]() { m_userInterface->printReauthorizeConfirmation(); });
+    m_executor.execute([this]() { m_userInterface->printReauthorizeConfirmation(); });
 }
 
 #ifdef ENABLE_COMMS
 void InteractionManager::commsControl() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_userInterface->printCommsControlScreen();
         } else {
@@ -563,7 +563,7 @@ void InteractionManager::commsControl() {
 }
 
 void InteractionManager::acceptCall() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->acceptCommsCall();
         } else {
@@ -573,7 +573,7 @@ void InteractionManager::acceptCall() {
 }
 
 void InteractionManager::stopCall() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->stopCommsCall();
         } else {
@@ -583,7 +583,7 @@ void InteractionManager::stopCall() {
 }
 
 void InteractionManager::muteCallToggle() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsCallMuted()) {
             m_client->unmuteCommsCall();
             m_userInterface->printUnmuteCallScreen();
@@ -595,7 +595,7 @@ void InteractionManager::muteCallToggle() {
 }
 
 void InteractionManager::sendDtmf(avsCommon::sdkInterfaces::CallManagerInterface::DTMFTone dtmfTone) {
-    m_executor.submit([this, dtmfTone]() {
+    m_executor.execute([this, dtmfTone]() {
         if (m_client->isCommsEnabled()) {
             m_client->sendDtmf(dtmfTone);
         } else {
@@ -605,15 +605,15 @@ void InteractionManager::sendDtmf(avsCommon::sdkInterfaces::CallManagerInterface
 }
 
 void InteractionManager::dtmfControl() {
-    m_executor.submit([this]() { m_userInterface->printDtmfScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDtmfScreen(); });
 }
 
 void InteractionManager::errorDtmf() {
-    m_executor.submit([this]() { m_userInterface->printDtmfErrorScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDtmfErrorScreen(); });
 }
 
 void InteractionManager::muteSelf() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->muteCommsCall();
         } else {
@@ -623,7 +623,7 @@ void InteractionManager::muteSelf() {
 }
 
 void InteractionManager::unmuteSelf() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->unmuteCommsCall();
         } else {
@@ -633,7 +633,7 @@ void InteractionManager::unmuteSelf() {
 }
 
 void InteractionManager::enableVideo() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->enableVideo();
         } else {
@@ -643,7 +643,7 @@ void InteractionManager::enableVideo() {
 }
 
 void InteractionManager::disableVideo() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_client->isCommsEnabled()) {
             m_client->disableVideo();
         } else {
@@ -654,7 +654,7 @@ void InteractionManager::disableVideo() {
 #endif
 
 void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         if (DialogUXState::LISTENING == state) {
             if (m_isMicOn && !m_micWrapper->isStreaming()) {
                 m_micWrapper->startStreamingMicrophoneData();
@@ -672,7 +672,7 @@ void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
 }
 
 void InteractionManager::onCallStateChange(CallState state) {
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         if (CallState::CALL_CONNECTED == state) {
             if (!m_micWrapper->isStreaming()) {
                 m_micWrapper->startStreamingMicrophoneData();
@@ -745,26 +745,26 @@ void InteractionManager::setMode(const std::string mode) {
 
 #ifdef ENABLE_PCC
 void InteractionManager::phoneControl() {
-    m_executor.submit([this]() { m_userInterface->printPhoneControlScreen(); });
+    m_executor.execute([this]() { m_userInterface->printPhoneControlScreen(); });
 }
 
 void InteractionManager::callId() {
-    m_executor.submit([this]() { m_userInterface->printCallIdScreen(); });
+    m_executor.execute([this]() { m_userInterface->printCallIdScreen(); });
 }
 
 void InteractionManager::callerId() {
-    m_executor.submit([this]() { m_userInterface->printCallerIdScreen(); });
+    m_executor.execute([this]() { m_userInterface->printCallerIdScreen(); });
 }
 
 void InteractionManager::sendCallActivated(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendCallActivated(callId);
         }
     });
 }
 void InteractionManager::sendCallTerminated(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendCallTerminated(callId);
         }
@@ -772,7 +772,7 @@ void InteractionManager::sendCallTerminated(const std::string& callId) {
 }
 
 void InteractionManager::sendCallFailed(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendCallFailed(callId);
         }
@@ -780,7 +780,7 @@ void InteractionManager::sendCallFailed(const std::string& callId) {
 }
 
 void InteractionManager::sendCallReceived(const std::string& callId, const std::string& callerId) {
-    m_executor.submit([this, callId, callerId]() {
+    m_executor.execute([this, callId, callerId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendCallReceived(callId, callerId);
         }
@@ -788,7 +788,7 @@ void InteractionManager::sendCallReceived(const std::string& callId, const std::
 }
 
 void InteractionManager::sendCallerIdReceived(const std::string& callId, const std::string& callerId) {
-    m_executor.submit([this, callId, callerId]() {
+    m_executor.execute([this, callId, callerId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendCallerIdReceived(callId, callerId);
         }
@@ -796,7 +796,7 @@ void InteractionManager::sendCallerIdReceived(const std::string& callId, const s
 }
 
 void InteractionManager::sendInboundRingingStarted(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendInboundRingingStarted(callId);
         }
@@ -804,7 +804,7 @@ void InteractionManager::sendInboundRingingStarted(const std::string& callId) {
 }
 
 void InteractionManager::sendOutboundCallRequested(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendDialStarted(callId);
         }
@@ -812,7 +812,7 @@ void InteractionManager::sendOutboundCallRequested(const std::string& callId) {
 }
 
 void InteractionManager::sendOutboundRingingStarted(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendOutboundRingingStarted(callId);
         }
@@ -820,7 +820,7 @@ void InteractionManager::sendOutboundRingingStarted(const std::string& callId) {
 }
 
 void InteractionManager::sendSendDtmfSucceeded(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendSendDtmfSucceeded(callId);
         }
@@ -828,7 +828,7 @@ void InteractionManager::sendSendDtmfSucceeded(const std::string& callId) {
 }
 
 void InteractionManager::sendSendDtmfFailed(const std::string& callId) {
-    m_executor.submit([this, callId]() {
+    m_executor.execute([this, callId]() {
         if (m_phoneCaller) {
             m_phoneCaller->sendSendDtmfFailed(callId);
         }
@@ -838,26 +838,26 @@ void InteractionManager::sendSendDtmfFailed(const std::string& callId) {
 
 #ifdef ENABLE_MCC
 void InteractionManager::meetingControl() {
-    m_executor.submit([this]() { m_userInterface->printMeetingControlScreen(); });
+    m_executor.execute([this]() { m_userInterface->printMeetingControlScreen(); });
 }
 
 void InteractionManager::sessionId() {
-    m_executor.submit([this]() { m_userInterface->printSessionIdScreen(); });
+    m_executor.execute([this]() { m_userInterface->printSessionIdScreen(); });
 }
 
 void InteractionManager::calendarItemsFile() {
-    m_executor.submit([this]() { m_userInterface->printCalendarItemsScreen(); });
+    m_executor.execute([this]() { m_userInterface->printCalendarItemsScreen(); });
 }
 
 void InteractionManager::sendMeetingJoined(const std::string& sessionId) {
-    m_executor.submit([this, sessionId]() {
+    m_executor.execute([this, sessionId]() {
         if (m_meetingClient) {
             m_meetingClient->sendMeetingJoined(sessionId);
         }
     });
 }
 void InteractionManager::sendMeetingEnded(const std::string& sessionId) {
-    m_executor.submit([this, sessionId]() {
+    m_executor.execute([this, sessionId]() {
         if (m_meetingClient) {
             m_meetingClient->sendMeetingEnded(sessionId);
         }
@@ -865,7 +865,7 @@ void InteractionManager::sendMeetingEnded(const std::string& sessionId) {
 }
 
 void InteractionManager::sendSetCurrentMeetingSession(const std::string& sessionId) {
-    m_executor.submit([this, sessionId]() {
+    m_executor.execute([this, sessionId]() {
         if (m_meetingClient) {
             m_meetingClient->sendSetCurrentMeetingSession(sessionId);
         }
@@ -873,7 +873,7 @@ void InteractionManager::sendSetCurrentMeetingSession(const std::string& session
 }
 
 void InteractionManager::sendClearCurrentMeetingSession() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_meetingClient) {
             m_meetingClient->sendClearCurrentMeetingSession();
         }
@@ -881,7 +881,7 @@ void InteractionManager::sendClearCurrentMeetingSession() {
 }
 
 void InteractionManager::sendConferenceConfigurationChanged() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_meetingClient) {
             m_meetingClient->sendConferenceConfigurationChanged();
         }
@@ -889,7 +889,7 @@ void InteractionManager::sendConferenceConfigurationChanged() {
 }
 
 void InteractionManager::sendMeetingClientErrorOccured(const std::string& sessionId) {
-    m_executor.submit([this, sessionId]() {
+    m_executor.execute([this, sessionId]() {
         if (m_meetingClient) {
             m_meetingClient->sendMeetingClientErrorOccured(sessionId);
         }
@@ -897,7 +897,7 @@ void InteractionManager::sendMeetingClientErrorOccured(const std::string& sessio
 }
 
 void InteractionManager::sendCalendarItemsRetrieved(const std::string& calendarItemsFile) {
-    m_executor.submit([this, calendarItemsFile]() {
+    m_executor.execute([this, calendarItemsFile]() {
         if (m_calendarClient) {
             m_calendarClient->sendCalendarItemsRetrieved(calendarItemsFile);
         }
@@ -905,7 +905,7 @@ void InteractionManager::sendCalendarItemsRetrieved(const std::string& calendarI
 }
 
 void InteractionManager::sendCalendarClientErrorOccured() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_calendarClient) {
             m_calendarClient->sendCalendarClientErrorOccured();
         }
@@ -918,15 +918,15 @@ void InteractionManager::setDoNotDisturbMode(bool enable) {
 }
 
 void InteractionManager::diagnosticsControl() {
-    m_executor.submit([this]() { m_userInterface->printDiagnosticsScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDiagnosticsScreen(); });
 }
 
 void InteractionManager::devicePropertiesControl() {
-    m_executor.submit([this]() { m_userInterface->printDevicePropertiesScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDevicePropertiesScreen(); });
 }
 
 void InteractionManager::showDeviceProperties() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_diagnostics) {
             auto deviceProperties = m_diagnostics->getDevicePropertyAggregator();
             if (deviceProperties) {
@@ -937,11 +937,11 @@ void InteractionManager::showDeviceProperties() {
 }
 
 void InteractionManager::audioInjectionControl() {
-    m_executor.submit([this]() { m_userInterface->printAudioInjectionScreen(); });
+    m_executor.execute([this]() { m_userInterface->printAudioInjectionScreen(); });
 }
 
 void InteractionManager::injectWavFile(const std::string& absoluteFilePath) {
-    m_executor.submit([this, absoluteFilePath]() {
+    m_executor.execute([this, absoluteFilePath]() {
         if (!m_diagnostics) {
             ACSDK_ERROR(LX("audioInjectionFailed").d("reason", "nullDiagnosticObject"));
             m_userInterface->printAudioInjectionFailureMessage();
@@ -962,11 +962,11 @@ void InteractionManager::injectWavFile(const std::string& absoluteFilePath) {
 }
 
 void InteractionManager::deviceProtocolTraceControl() {
-    m_executor.submit([this]() { m_userInterface->printDeviceProtocolTracerScreen(); });
+    m_executor.execute([this]() { m_userInterface->printDeviceProtocolTracerScreen(); });
 }
 
 void InteractionManager::printProtocolTrace() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_diagnostics) {
             auto protocolTrace = m_diagnostics->getProtocolTracer();
             if (protocolTrace) {
@@ -977,7 +977,7 @@ void InteractionManager::printProtocolTrace() {
 }
 
 void InteractionManager::setProtocolTraceFlag(bool enabled) {
-    m_executor.submit([this, enabled]() {
+    m_executor.execute([this, enabled]() {
         if (m_diagnostics) {
             auto protocolTrace = m_diagnostics->getProtocolTracer();
             if (protocolTrace) {
@@ -989,7 +989,7 @@ void InteractionManager::setProtocolTraceFlag(bool enabled) {
 }
 
 void InteractionManager::clearProtocolTrace() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         if (m_diagnostics) {
             auto protocolTrace = m_diagnostics->getProtocolTracer();
             if (protocolTrace) {
@@ -1012,7 +1012,7 @@ void InteractionManager::doShutdown() {
 }
 
 void InteractionManager::sendDeviceSetupComplete() {
-    m_executor.submit([this]() {
+    m_executor.execute([this]() {
         auto deviceSetup = m_client->getDeviceSetup();
         if (!deviceSetup) {
             ACSDK_ERROR(LX(__func__).m("DeviceSetup is null"));
diff --git a/SampleApp/src/PortAudioMicrophoneWrapper.cpp b/SampleApp/src/PortAudioMicrophoneWrapper.cpp
index 8f6ed686..0af0b69a 100644
--- a/SampleApp/src/PortAudioMicrophoneWrapper.cpp
+++ b/SampleApp/src/PortAudioMicrophoneWrapper.cpp
@@ -1,17 +1,17 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
+* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License").
+* You may not use this file except in compliance with the License.
+* A copy of the License is located at
+*
+*     http://aws.amazon.com/apache2.0/
+*
+* or in the "license" file accompanying this file. This file is distributed
+* on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+* express or implied. See the License for the specific language governing
+* permissions and limitations under the License.
+*/
 
 #include <cstring>
 #include <string>
@@ -35,162 +35,202 @@ static const unsigned long PREFERRED_SAMPLES_PER_CALLBACK = paFramesPerBufferUns
 
 static const std::string SAMPLE_APP_CONFIG_ROOT_KEY("sampleApp");
 static const std::string PORTAUDIO_CONFIG_ROOT_KEY("portAudio");
+static const std::string PORTAUDIO_CONFIG_SUGGESTED_DEVICE_NAME("deviceName");
 static const std::string PORTAUDIO_CONFIG_SUGGESTED_LATENCY_KEY("suggestedLatency");
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("PortAudioMicrophoneWrapper");
 
 /**
- * Create a LogEntry using this file's TAG and the specified event string.
- *
- * @param The event string for this @c LogEntry.
- */
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
 std::unique_ptr<PortAudioMicrophoneWrapper> PortAudioMicrophoneWrapper::create(
-    std::shared_ptr<AudioInputStream> stream) {
-    if (!stream) {
-        ACSDK_CRITICAL(LX("Invalid stream passed to PortAudioMicrophoneWrapper"));
-        return nullptr;
-    }
-    std::unique_ptr<PortAudioMicrophoneWrapper> portAudioMicrophoneWrapper(new PortAudioMicrophoneWrapper(stream));
-    if (!portAudioMicrophoneWrapper->initialize()) {
-        ACSDK_CRITICAL(LX("Failed to initialize PortAudioMicrophoneWrapper"));
-        return nullptr;
-    }
-    return portAudioMicrophoneWrapper;
+   std::shared_ptr<AudioInputStream> stream) {
+   if (!stream) {
+       ACSDK_CRITICAL(LX("Invalid stream passed to PortAudioMicrophoneWrapper"));
+       return nullptr;
+   }
+   std::unique_ptr<PortAudioMicrophoneWrapper> portAudioMicrophoneWrapper(new PortAudioMicrophoneWrapper(stream));
+   if (!portAudioMicrophoneWrapper->initialize()) {
+       ACSDK_CRITICAL(LX("Failed to initialize PortAudioMicrophoneWrapper"));
+       return nullptr;
+   }
+   return portAudioMicrophoneWrapper;
 }
 
 PortAudioMicrophoneWrapper::PortAudioMicrophoneWrapper(std::shared_ptr<AudioInputStream> stream) :
-        m_audioInputStream{stream},
-        m_paStream{nullptr},
-        m_isStreaming{false} {
+       m_audioInputStream{stream},
+       m_paStream{nullptr},
+       m_isStreaming{false} {
 }
 
 PortAudioMicrophoneWrapper::~PortAudioMicrophoneWrapper() {
-    Pa_StopStream(m_paStream);
-    Pa_CloseStream(m_paStream);
-    Pa_Terminate();
+   Pa_StopStream(m_paStream);
+   Pa_CloseStream(m_paStream);
+   Pa_Terminate();
 }
 
 bool PortAudioMicrophoneWrapper::initialize() {
-    m_writer = m_audioInputStream->createWriter(AudioInputStream::Writer::Policy::NONBLOCKABLE);
-    if (!m_writer) {
-        ACSDK_CRITICAL(LX("Failed to create stream writer"));
-        return false;
-    }
-    PaError err;
-    err = Pa_Initialize();
-    if (err != paNoError) {
-        ACSDK_CRITICAL(LX("Failed to initialize PortAudio").d("errorCode", err));
-        return false;
-    }
-
-    PaTime suggestedLatency = -1;
-    bool latencyInConfig = getConfigSuggestedLatency(suggestedLatency);
-
-    if (!latencyInConfig) {
-        err = Pa_OpenDefaultStream(
-            &m_paStream,
-            NUM_INPUT_CHANNELS,
-            NUM_OUTPUT_CHANNELS,
-            paInt16,
-            SAMPLE_RATE,
-            PREFERRED_SAMPLES_PER_CALLBACK,
-            PortAudioCallback,
-            this);
-    } else {
-        ACSDK_INFO(
-            LX("PortAudio suggestedLatency has been configured to ").d("Seconds", std::to_string(suggestedLatency)));
-        if (suggestedLatency < 0) {
-            ACSDK_CRITICAL(LX("Failed to configure PortAudio invalid suggestedLatency"));
-            return false;
-        }
-
-        PaStreamParameters inputParameters;
-        std::memset(&inputParameters, 0, sizeof(inputParameters));
-        inputParameters.device = Pa_GetDefaultInputDevice();
-        inputParameters.channelCount = NUM_INPUT_CHANNELS;
-        inputParameters.sampleFormat = paInt16;
-        inputParameters.suggestedLatency = suggestedLatency;
-        inputParameters.hostApiSpecificStreamInfo = nullptr;
-
-        err = Pa_OpenStream(
-            &m_paStream,
-            &inputParameters,
-            nullptr,
-            SAMPLE_RATE,
-            PREFERRED_SAMPLES_PER_CALLBACK,
-            paNoFlag,
-            PortAudioCallback,
-            this);
-    }
-
-    if (err != paNoError) {
-        ACSDK_CRITICAL(LX("Failed to open PortAudio default stream").d("errorCode", err));
-        return false;
-    }
-    return true;
+   m_writer = m_audioInputStream->createWriter(AudioInputStream::Writer::Policy::NONBLOCKABLE);
+   if (!m_writer) {
+       ACSDK_CRITICAL(LX("Failed to create stream writer"));
+       return false;
+   }
+   PaError err;
+   err = Pa_Initialize();
+   if (err != paNoError) {
+       ACSDK_CRITICAL(LX("Failed to initialize PortAudio").d("errorCode", err));
+       return false;
+   }
+
+   PaDeviceIndex deviceIndex = paNoDevice;
+   bool deviceInConfig = getConfigAudioDevice(deviceIndex);
+   if (!deviceInConfig || deviceIndex == paNoDevice) {
+       LX("Unable to get the device");
+       deviceIndex = Pa_GetDefaultInputDevice();
+   }
+   PaTime suggestedLatency = -1;
+   bool latencyInConfig = getConfigSuggestedLatency(suggestedLatency);
+
+   if (!latencyInConfig) {
+       err = Pa_OpenDefaultStream(
+           &m_paStream,
+           NUM_INPUT_CHANNELS,
+           NUM_OUTPUT_CHANNELS,
+           paInt16,
+           SAMPLE_RATE,
+           PREFERRED_SAMPLES_PER_CALLBACK,
+           PortAudioCallback,
+           this);
+   } else {
+       ACSDK_INFO(
+           LX("PortAudio suggestedLatency has been configured to ").d("Seconds", std::to_string(suggestedLatency)));
+       if (suggestedLatency < 0) {
+           ACSDK_CRITICAL(LX("Failed to configure PortAudio invalid suggestedLatency"));
+           return false;
+       }
+
+       PaStreamParameters inputParameters;
+       std::memset(&inputParameters, 0, sizeof(inputParameters));
+       inputParameters.device = deviceIndex;
+       inputParameters.channelCount = NUM_INPUT_CHANNELS;
+       inputParameters.sampleFormat = paInt16;
+       inputParameters.suggestedLatency = suggestedLatency;
+       inputParameters.hostApiSpecificStreamInfo = nullptr;
+
+       err = Pa_OpenStream(
+           &m_paStream,
+           &inputParameters,
+           nullptr,
+           SAMPLE_RATE,
+           PREFERRED_SAMPLES_PER_CALLBACK,
+           paNoFlag,
+           PortAudioCallback,
+           this);
+   }
+
+   if (err != paNoError) {
+       ACSDK_CRITICAL(LX("Failed to open PortAudio default stream").d("errorCode", err));
+       return false;
+   }
+   return true;
 }
 
 bool PortAudioMicrophoneWrapper::startStreamingMicrophoneData() {
-    ACSDK_INFO(LX(__func__));
-    std::lock_guard<std::mutex> lock{m_mutex};
-    PaError err = Pa_StartStream(m_paStream);
-    if (err != paNoError) {
-        ACSDK_CRITICAL(LX("Failed to start PortAudio stream"));
-        return false;
-    }
-    m_isStreaming = true;
-    return true;
+   ACSDK_INFO(LX(__func__));
+   std::lock_guard<std::mutex> lock{m_mutex};
+   PaError err = Pa_StartStream(m_paStream);
+   if (err != paNoError) {
+       ACSDK_CRITICAL(LX("Failed to start PortAudio stream"));
+       return false;
+   }
+   m_isStreaming = true;
+   return true;
 }
 
 bool PortAudioMicrophoneWrapper::stopStreamingMicrophoneData() {
-    ACSDK_INFO(LX(__func__));
-    std::lock_guard<std::mutex> lock{m_mutex};
-    PaError err = Pa_StopStream(m_paStream);
-    if (err != paNoError) {
-        ACSDK_CRITICAL(LX("Failed to stop PortAudio stream"));
-        return false;
-    }
-    m_isStreaming = false;
-    return true;
+   ACSDK_INFO(LX(__func__));
+   std::lock_guard<std::mutex> lock{m_mutex};
+   PaError err = Pa_StopStream(m_paStream);
+   if (err != paNoError) {
+       ACSDK_CRITICAL(LX("Failed to stop PortAudio stream"));
+       return false;
+   }
+   m_isStreaming = false;
+   return true;
 }
 
 bool PortAudioMicrophoneWrapper::isStreaming() {
-    return m_isStreaming;
+   return m_isStreaming;
 }
 
 int PortAudioMicrophoneWrapper::PortAudioCallback(
-    const void* inputBuffer,
-    void* outputBuffer,
-    unsigned long numSamples,
-    const PaStreamCallbackTimeInfo* timeInfo,
-    PaStreamCallbackFlags statusFlags,
-    void* userData) {
-    PortAudioMicrophoneWrapper* wrapper = static_cast<PortAudioMicrophoneWrapper*>(userData);
-    ssize_t returnCode = wrapper->m_writer->write(inputBuffer, numSamples);
-    if (returnCode <= 0) {
-        ACSDK_CRITICAL(LX("Failed to write to stream."));
-        return paAbort;
-    }
-    return paContinue;
+   const void* inputBuffer,
+   void* outputBuffer,
+   unsigned long numSamples,
+   const PaStreamCallbackTimeInfo* timeInfo,
+   PaStreamCallbackFlags statusFlags,
+   void* userData) {
+   PortAudioMicrophoneWrapper* wrapper = static_cast<PortAudioMicrophoneWrapper*>(userData);
+   ssize_t returnCode = wrapper->m_writer->write(inputBuffer, numSamples);
+   if (returnCode <= 0) {
+       ACSDK_CRITICAL(LX("Failed to write to stream."));
+       return paAbort;
+   }
+   return paContinue;
 }
 
 bool PortAudioMicrophoneWrapper::getConfigSuggestedLatency(PaTime& suggestedLatency) {
-    bool latencyInConfig = false;
-    auto config = avsCommon::utils::configuration::ConfigurationNode::getRoot()[SAMPLE_APP_CONFIG_ROOT_KEY]
-                                                                               [PORTAUDIO_CONFIG_ROOT_KEY];
-    if (config) {
-        latencyInConfig = config.getValue(
-            PORTAUDIO_CONFIG_SUGGESTED_LATENCY_KEY,
-            &suggestedLatency,
-            suggestedLatency,
-            &rapidjson::Value::IsDouble,
-            &rapidjson::Value::GetDouble);
-    }
-
-    return latencyInConfig;
+   bool latencyInConfig = false;
+   auto config = avsCommon::utils::configuration::ConfigurationNode::getRoot()[SAMPLE_APP_CONFIG_ROOT_KEY]
+                                                                              [PORTAUDIO_CONFIG_ROOT_KEY];
+   if (config) {
+       latencyInConfig = config.getValue(
+           PORTAUDIO_CONFIG_SUGGESTED_LATENCY_KEY,
+           &suggestedLatency,
+           suggestedLatency,
+           &rapidjson::Value::IsDouble,
+           &rapidjson::Value::GetDouble);
+   }
+
+   return latencyInConfig;
+}
+
+bool PortAudioMicrophoneWrapper::getConfigAudioDevice(PaDeviceIndex& deviceIndex) {
+   bool deviceInConfig = false;
+   auto config = avsCommon::utils::configuration::ConfigurationNode::getRoot()[SAMPLE_APP_CONFIG_ROOT_KEY]
+                                                                              [PORTAUDIO_CONFIG_ROOT_KEY];
+   std::string deviceName = "";
+   if (config) {
+       deviceInConfig = config.getValue(
+           PORTAUDIO_CONFIG_SUGGESTED_DEVICE_NAME,
+           &deviceName,
+           std::string(""),
+           &rapidjson::Value::IsString,
+           &rapidjson::Value::Get);
+   }
+
+   if (!deviceInConfig) {
+       LX("Device name does not exist ").d("deviceName", deviceName);
+       return false;
+   }
+
+   for (PaDeviceIndex i = 0; i < Pa_GetDeviceCount(); i++)
+   {
+       const PaDeviceInfo* inf = Pa_GetDeviceInfo(i);
+       if (inf && std::strcmp(inf->name, deviceName.c_str()) == 0)
+       {
+           LX("Device name matched ").d("deviceName", deviceName);
+           deviceIndex = i;
+           break;
+       }
+   }
+
+   return deviceInConfig;
 }
 
 }  // namespace sampleApp
diff --git a/SampleApp/src/SampleApplication.cpp b/SampleApp/src/SampleApplication.cpp
index f9bbc2f2..856a75a0 100644
--- a/SampleApp/src/SampleApplication.cpp
+++ b/SampleApp/src/SampleApplication.cpp
@@ -170,6 +170,13 @@ std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ApplicationMediaInterf
 }  // namespace alexaClientSDK
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+#include <MultiAgentExperience/AlexaAdapter/Experience/AlexaNotificationsObserver.h>
+#include <MultiAgentExperience/AlexaAdapter/Experience/DoNotDisturbSettingObserver.h>
+#include <MultiAgentExperience/AlexaAdapter/UniversalDeviceController/UniversalDeviceCommandsInvoker.h>
+#include <MultiAgentExperience/AlexaAdapter/UniversalDeviceController/UniversalDeviceCommandsProvider.h>
+#endif
+
 namespace alexaClientSDK {
 namespace sampleApp {
 
@@ -674,9 +681,21 @@ std::unique_ptr<SampleApplication> SampleApplication::create(
     std::shared_ptr<alexaClientSDK::sampleApp::ConsoleReader> consoleReader,
     const std::vector<std::string>& configFiles,
     const std::string& logLevel,
+#ifdef MULTI_AGENT_EXPERIENCE
+    const std::vector<std::string>& maxConnectionDetails,
+#endif
     std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics) {
+
     auto clientApplication = std::unique_ptr<SampleApplication>(new SampleApplication);
-    if (!clientApplication->initialize(consoleReader, configFiles, logLevel, diagnostics)) {
+
+    if (!clientApplication->initialize(
+        consoleReader,
+        configFiles,
+        logLevel,
+#ifdef MULTI_AGENT_EXPERIENCE
+        maxConnectionDetails,
+#endif
+        diagnostics)) {
         ACSDK_CRITICAL(LX("Failed to initialize SampleApplication"));
         return nullptr;
     }
@@ -773,6 +792,9 @@ bool SampleApplication::initialize(
     std::shared_ptr<alexaClientSDK::sampleApp::ConsoleReader> consoleReader,
     const std::vector<std::string>& configFiles,
     const std::string& logLevel,
+#ifdef MULTI_AGENT_EXPERIENCE
+    const std::vector<std::string>& maxConnectionDetails,
+#endif
     std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface> diagnostics) {
     avsCommon::utils::logger::Level logLevelValue = avsCommon::utils::logger::Level::UNKNOWN;
 
@@ -1323,6 +1345,37 @@ bool SampleApplication::initialize(
         alexaClientSDK::capabilityAgents::aip::AudioProvider::AudioProvider::HoldAudioProvider(
             sharedDataStream, *compatibleAudioFormat);
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    auto doNotDisturbSettingObserver = std::make_shared<multiAgentExperience::experience::DoNotDisturbSettingObserver>();
+    auto notificationsObserver = std::make_shared<alexaClientSDK::multiAgentExperience::experience::AlexaNotificationsObserver>();
+
+    auto universalDeviceCommandsInvoker = std::make_shared<
+        alexaClientSDK::multiAssistant::universalDeviceController::UniversalDeviceCommandsInvoker>();
+    auto universalDeviceCommandsProvider = std::make_shared<
+        alexaClientSDK::multiAssistant::universalDeviceController::UniversalDeviceCommandsProvider>(deviceInfo->getDefaultEndpointId());
+
+    m_multiAgentExperienceFocusMediator = std::make_shared<multiAgentExperience::mediator::MAXFocusMediator>();
+    m_multiAgentDialogUXStateObserver = std::make_shared<multiAgentExperience::mediator::MAXDialogUXStateObserver>(m_multiAgentExperienceFocusMediator);
+
+    // Extract details required for Alexa's connection to MAX
+    auto clientUri = maxConnectionDetails[0];
+    auto serverUri = maxConnectionDetails[1];
+    auto agentName = maxConnectionDetails[2];
+
+    m_alexaMultiAgentExperienceRegistration = std::make_shared<multiAgentExperience::agent::AlexaAgentRegistration>(
+        m_multiAgentExperienceFocusMediator,
+        universalDeviceCommandsInvoker,
+        universalDeviceCommandsProvider,
+        doNotDisturbSettingObserver,
+        notificationsObserver,
+        agentName);
+
+    /// Create the MAXConnection object using the connection configuration details provided
+    ACSDK_INFO(LX("Creating the MAXConnection object"));
+    m_maxConnection = std::make_shared<alexaClientSDK::multiAgentExperience::agent::MAXConnection>(
+        m_alexaMultiAgentExperienceRegistration, m_multiAgentExperienceFocusMediator, clientUri, serverUri);
+#endif
+
     /*
      * Creating the DefaultClient - this component serves as an out-of-box default object that instantiates and "glues"
      * together all the modules.
@@ -1398,7 +1451,15 @@ bool SampleApplication::initialize(
         true,
         std::make_shared<alexaClientSDK::acl::MessageRouterFactory>(),
         nullptr,
+#ifdef MULTI_AGENT_EXPERIENCE
+        tapToTalkAudioProvider,
+        universalDeviceCommandsInvoker,
+        universalDeviceCommandsProvider,
+        m_multiAgentExperienceFocusMediator);
+#else
         tapToTalkAudioProvider);
+#endif
+
     if (!m_client) {
         ACSDK_CRITICAL(LX("Failed to create default SDK client!"));
         return false;
@@ -1406,6 +1467,25 @@ bool SampleApplication::initialize(
 
     m_client->addSpeakerManagerObserver(userInterfaceManager);
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    m_client->addAlexaDialogStateObserver(m_multiAgentDialogUXStateObserver);
+
+    /// Add the MAX DoNotDisturbSetting observer
+    m_client->addDoNotDisturbSettingObserver(doNotDisturbSettingObserver);
+
+    /// Add the MAX Notifications observer
+    m_client->addNotificationsObserver(notificationsObserver);
+
+    if (m_maxConnection != nullptr) {
+        ACSDK_INFO(LX("Establishing connection to MAX"));
+        auto isConnected = m_maxConnection->connect();
+
+        if (!isConnected) {
+            ACSDK_ERROR(LX("Unable to establish connection to MAX"));
+        }
+    }
+#endif
+
     m_client->addNotificationsObserver(userInterfaceManager);
 
     m_client->addBluetoothDeviceObserver(userInterfaceManager);
@@ -1947,5 +2027,16 @@ bool SampleApplication::addControllersToPeripheralEndpoint(
 }
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+std::shared_ptr<alexaClientSDK::multiAgentExperience::agent::AlexaAgentRegistration> SampleApplication::getAgentRegistration() {
+    return m_alexaMultiAgentExperienceRegistration;
+}
+
+std::shared_ptr<InteractionManager> SampleApplication::getInteractionManager() {
+    return m_interactionManager;
+}
+
+#endif
+
 }  // namespace sampleApp
 }  // namespace alexaClientSDK
diff --git a/SampleApp/src/UIManager.cpp b/SampleApp/src/UIManager.cpp
index 36bb4378..4b2ea4ec 100644
--- a/SampleApp/src/UIManager.cpp
+++ b/SampleApp/src/UIManager.cpp
@@ -632,7 +632,7 @@ static const std::string DTMF_MESSAGE =
     "+----------------------------------------------------------------------------+\n";
 
 void UIManager::onDialogUXStateChanged(DialogUXState state) {
-    m_executor.submit([this, state]() {
+    m_executor.execute([this, state]() {
         if (state == m_dialogState) {
             return;
         }
@@ -642,7 +642,7 @@ void UIManager::onDialogUXStateChanged(DialogUXState state) {
 }
 
 void UIManager::onConnectionStatusChanged(const Status status, const ChangedReason reason) {
-    m_executor.submit([this, status]() {
+    m_executor.execute([this, status]() {
         if (m_connectionStatus == status) {
             return;
         }
@@ -652,7 +652,7 @@ void UIManager::onConnectionStatusChanged(const Status status, const ChangedReas
 }
 
 void UIManager::onSettingChanged(const std::string& key, const std::string& value) {
-    m_executor.submit([key, value]() {
+    m_executor.execute([key, value]() {
         std::string msg = key + " set to " + value;
         ConsolePrinter::prettyPrint(msg);
     });
@@ -662,7 +662,7 @@ void UIManager::onSpeakerSettingsChanged(
     const SpeakerManagerObserverInterface::Source& source,
     const ChannelVolumeInterface::Type& type,
     const SpeakerInterface::SpeakerSettings& settings) {
-    m_executor.submit([source, type, settings]() {
+    m_executor.execute([source, type, settings]() {
         std::ostringstream oss;
         oss << "SOURCE:" << source << " TYPE:" << type << " VOLUME:" << static_cast<int>(settings.volume)
             << " MUTE:" << settings.mute;
@@ -671,7 +671,7 @@ void UIManager::onSpeakerSettingsChanged(
 }
 
 void UIManager::onSetIndicator(avsCommon::avs::IndicatorState state) {
-    m_executor.submit([state]() {
+    m_executor.execute([state]() {
         std::ostringstream oss;
         oss << "NOTIFICATION INDICATOR STATE: " << state;
         ConsolePrinter::prettyPrint(oss.str());
@@ -679,11 +679,11 @@ void UIManager::onSetIndicator(avsCommon::avs::IndicatorState state) {
 }
 
 void UIManager::printMessage(const std::string& message) {
-    m_executor.submit([message]() { ConsolePrinter::prettyPrint(message); });
+    m_executor.execute([message]() { ConsolePrinter::prettyPrint(message); });
 }
 
 void UIManager::onAuthStateChange(AuthObserverInterface::State newState, AuthObserverInterface::Error newError) {
-    m_executor.submit([this, newState, newError]() {
+    m_executor.execute([this, newState, newError]() {
         if (m_authState != newState) {
             m_authState = newState;
             switch (m_authState) {
@@ -739,7 +739,7 @@ void UIManager::onCapabilitiesStateChange(
     CapabilitiesDelegateObserverInterface::Error newError,
     const std::vector<avsCommon::sdkInterfaces::endpoints::EndpointIdentifier>& addedOrUpdatedEndpoints,
     const std::vector<avsCommon::sdkInterfaces::endpoints::EndpointIdentifier>& deletedEndpoints) {
-    m_executor.submit([this, newState, newError, addedOrUpdatedEndpoints, deletedEndpoints]() {
+    m_executor.execute([this, newState, newError, addedOrUpdatedEndpoints, deletedEndpoints]() {
         // If one of the added or updated endpointIds is the default endpoint, and the
         // add/update failed, go into limited mode.
         // Limited mode is unnecessary if the failure is for non-default endpoints.
@@ -777,61 +777,61 @@ void UIManager::onCapabilitiesStateChange(
 }
 
 void UIManager::printWelcomeScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ALEXA_WELCOME_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ALEXA_WELCOME_MESSAGE); });
 }
 
 void UIManager::printHelpScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(HELP_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(HELP_MESSAGE); });
 }
 
 void UIManager::printLimitedHelp() {
-    m_executor.submit(
+    m_executor.execute(
         [this]() { ConsolePrinter::simplePrint(LIMITED_HELP_HEADER + m_failureStatus + LIMITED_HELP_MESSAGE); });
 }
 
 void UIManager::printAudioInjectionHeader() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(AUDIO_INJECTION_HEADER); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(AUDIO_INJECTION_HEADER); });
 }
 
 void UIManager::printSettingsScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(SETTINGS_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(SETTINGS_MESSAGE); });
 }
 
 #ifdef ENABLE_ENDPOINT_CONTROLLERS
 void UIManager::printEndpointModificationScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENDPOINT_MODIFICATION_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENDPOINT_MODIFICATION_MESSAGE); });
 }
 
 void UIManager::printEndpointModificationError(const std::string& message) {
-    m_executor.submit([message]() { ConsolePrinter::prettyPrint(message); });
+    m_executor.execute([message]() { ConsolePrinter::prettyPrint(message); });
 }
 
 void UIManager::printEndpointControllerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENDPOINT_CONTROLLER_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENDPOINT_CONTROLLER_MESSAGE); });
 }
 #endif
 
 #ifdef POWER_CONTROLLER
 void UIManager::printPowerControllerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(POWER_CONTROLLER_OPTIONS); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(POWER_CONTROLLER_OPTIONS); });
 }
 #endif
 
 #ifdef TOGGLE_CONTROLLER
 void UIManager::printToggleControllerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(TOGGLE_CONTROLLER_OPTIONS); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(TOGGLE_CONTROLLER_OPTIONS); });
 }
 #endif
 
 #ifdef MODE_CONTROLLER
 void UIManager::printModeControllerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(MODE_CONTROLLER_OPTIONS); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(MODE_CONTROLLER_OPTIONS); });
 }
 #endif
 
 #ifdef RANGE_CONTROLLER
 void UIManager::printRangeControllerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(RANGE_CONTROLLER_OPTIONS); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(RANGE_CONTROLLER_OPTIONS); });
 }
 #endif
 
@@ -858,165 +858,165 @@ void UIManager::printLocaleScreen() {
         ConsolePrinter::simplePrint(LOCALE_MESSAGE_HEADER + optionString + LOCALE_MESSAGE_FOOTER);
     };
 
-    m_executor.submit(printLocaleMessage);
+    m_executor.execute(printLocaleMessage);
 }
 
 void UIManager::printSpeakerControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(SPEAKER_CONTROL_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(SPEAKER_CONTROL_MESSAGE); });
 }
 
 void UIManager::printFirmwareVersionControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(FIRMWARE_CONTROL_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(FIRMWARE_CONTROL_MESSAGE); });
 }
 
 void UIManager::printVolumeControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(VOLUME_CONTROL_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(VOLUME_CONTROL_MESSAGE); });
 }
 
 #ifdef ENABLE_PCC
 void UIManager::printPhoneControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(PHONE_CONTROL_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(PHONE_CONTROL_MESSAGE); });
 }
 
 void UIManager::printCallIdScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENTER_CALL_ID_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENTER_CALL_ID_MESSAGE); });
 }
 
 void UIManager::printCallerIdScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENTER_CALLER_ID_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENTER_CALLER_ID_MESSAGE); });
 }
 #endif
 
 #ifdef ENABLE_MCC
 void UIManager::printMeetingControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(MEETING_CONTROL_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(MEETING_CONTROL_MESSAGE); });
 }
 
 void UIManager::printSessionIdScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENTER_SESSION_ID_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENTER_SESSION_ID_MESSAGE); });
 }
 
 void UIManager::printCalendarItemsScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(ENTER_CALENDAR_ITEMS_FILE_PATH_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(ENTER_CALENDAR_ITEMS_FILE_PATH_MESSAGE); });
 }
 #endif
 
 #ifdef ENABLE_COMMS
 void UIManager::printCommsControlScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(COMMS_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(COMMS_MESSAGE); });
 }
 
 void UIManager::printDtmfScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(DTMF_MESSAGE); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(DTMF_MESSAGE); });
 }
 
 void UIManager::printDtmfErrorScreen() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint("Invalid Dtmf Tones"); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint("Invalid Dtmf Tones"); });
 }
 
 void UIManager::printMuteCallScreen() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint("Mute the call"); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint("Mute the call"); });
 }
 
 void UIManager::printUnmuteCallScreen() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint("Unmute the call"); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint("Unmute the call"); });
 }
 #endif
 
 void UIManager::printErrorScreen() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint("Invalid Option"); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint("Invalid Option"); });
 }
 
 void UIManager::microphoneOff() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint("Microphone Off!"); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint("Microphone Off!"); });
 }
 
 void UIManager::printResetConfirmation() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(RESET_CONFIRMATION); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(RESET_CONFIRMATION); });
 }
 
 void UIManager::printReauthorizeConfirmation() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(REAUTHORIZE_CONFIRMATION); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(REAUTHORIZE_CONFIRMATION); });
 }
 
 void UIManager::printResetWarning() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(RESET_WARNING); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(RESET_WARNING); });
 }
 
 void UIManager::printAlarmVolumeRampScreen() {
-    m_executor.submit([]() {
+    m_executor.execute([]() {
         ConsolePrinter::simplePrint(ALARM_VOLUME_RAMP_HEADER);
         ConsolePrinter::simplePrint(ENABLE_SETTING_MENU);
     });
 }
 
 void UIManager::printDoNotDisturbScreen() {
-    m_executor.submit([]() {
+    m_executor.execute([]() {
         ConsolePrinter::simplePrint(DONOTDISTURB_CONFIRMATION_HEADER);
         ConsolePrinter::simplePrint(ENABLE_SETTING_MENU);
     });
 }
 
 void UIManager::printWakeWordConfirmationScreen() {
-    m_executor.submit([]() {
+    m_executor.execute([]() {
         ConsolePrinter::simplePrint(WAKEWORD_CONFIRMATION_HEADER);
         ConsolePrinter::simplePrint(ENABLE_SETTING_MENU);
     });
 }
 
 void UIManager::printSpeechConfirmationScreen() {
-    m_executor.submit([]() {
+    m_executor.execute([]() {
         ConsolePrinter::simplePrint(SPEECH_CONFIRMATION_HEADER);
         ConsolePrinter::simplePrint(ENABLE_SETTING_MENU);
     });
 }
 
 void UIManager::printTimeZoneScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(TIMEZONE_SETTING_MENU); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(TIMEZONE_SETTING_MENU); });
 }
 
 void UIManager::printNetworkInfoScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(NETWORK_INFO_SETTING_MENU); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(NETWORK_INFO_SETTING_MENU); });
 }
 
 void UIManager::printNetworkInfoConnectionTypePrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_CONNECTION_TYPE_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_CONNECTION_TYPE_PROMPT); });
 }
 
 void UIManager::printNetworkInfoESSIDPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_ESSID_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_ESSID_PROMPT); });
 }
 
 void UIManager::printNetworkInfoBSSIDPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_BSSID_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_BSSID_PROMPT); });
 }
 
 void UIManager::printNetworkInfoIpPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_IP_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_IP_PROMPT); });
 }
 
 void UIManager::printNetworkInfoSubnetPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_SUBNET_MASK_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_SUBNET_MASK_PROMPT); });
 }
 
 void UIManager::printNetworkInfoMacPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_MAC_ADDRESS_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_MAC_ADDRESS_PROMPT); });
 }
 
 void UIManager::printNetworkInfoDHCPPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_DHCP_ADDRESS_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_DHCP_ADDRESS_PROMPT); });
 }
 
 void UIManager::printNetworkInfoStaticIpPrompt() {
-    m_executor.submit([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_STATIC_IP_PROMPT); });
+    m_executor.execute([]() { ConsolePrinter::prettyPrint(NETWORK_INFO_STATIC_IP_PROMPT); });
 }
 
 void UIManager::printDiagnosticsScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(DIAGNOSTICS_SCREEN); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(DIAGNOSTICS_SCREEN); });
 }
 
 void UIManager::printDevicePropertiesScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(DEVICE_PROPERTIES_SCREEN); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(DEVICE_PROPERTIES_SCREEN); });
 }
 
 void UIManager::printAllDeviceProperties(const std::unordered_map<std::string, std::string>& deviceProperties) {
@@ -1025,33 +1025,33 @@ void UIManager::printAllDeviceProperties(const std::unordered_map<std::string, s
         ss << keyVal.first << ":" << keyVal.second << std::endl;
     }
     auto propertiesString = ss.str();
-    m_executor.submit([propertiesString]() { ConsolePrinter::simplePrint(propertiesString); });
+    m_executor.execute([propertiesString]() { ConsolePrinter::simplePrint(propertiesString); });
 }
 
 void UIManager::printDeviceProtocolTracerScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(DEVICE_PROTOCOL_TRACE_SCREEN); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(DEVICE_PROTOCOL_TRACE_SCREEN); });
 }
 
 void UIManager::printProtocolTrace(const std::string& protocolTrace) {
-    m_executor.submit([protocolTrace]() { ConsolePrinter::simplePrint(protocolTrace); });
+    m_executor.execute([protocolTrace]() { ConsolePrinter::simplePrint(protocolTrace); });
 }
 
 void UIManager::printProtocolTraceFlag(bool enabled) {
-    m_executor.submit([enabled]() {
+    m_executor.execute([enabled]() {
         ConsolePrinter::simplePrint("Protocol trace : " + std::string(enabled ? "Enabled" : "Disabled"));
     });
 }
 
 void UIManager::printAudioInjectionScreen() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint(AUDIO_INJECTION_SCREEN); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint(AUDIO_INJECTION_SCREEN); });
 }
 
 void UIManager::printAudioInjectionFailureMessage() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint("Failure injecting audio file."); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint("Failure injecting audio file."); });
 }
 
 void UIManager::microphoneOn() {
-    m_executor.submit([this]() { printState(); });
+    m_executor.execute([this]() { printState(); });
 }
 
 void UIManager::onBooleanSettingNotification(
@@ -1064,7 +1064,7 @@ void UIManager::onBooleanSettingNotification(
         msg = "ERROR: Failed to set " + name + ". ";
     }
     msg += name + " is " + std::string(state ? "ON" : "OFF");
-    m_executor.submit([msg]() { ConsolePrinter::prettyPrint(msg); });
+    m_executor.execute([msg]() { ConsolePrinter::prettyPrint(msg); });
 }
 
 template <typename SettingType>
@@ -1079,7 +1079,7 @@ void UIManager::onSettingNotification(
     }
     stream << name << " is " << settings::toSettingString<SettingType>(value).second;
     std::string msg = stream.str();
-    m_executor.submit([msg]() { ConsolePrinter::prettyPrint(msg); });
+    m_executor.execute([msg]() { ConsolePrinter::prettyPrint(msg); });
 }
 
 void UIManager::printState() {
@@ -1116,7 +1116,7 @@ void UIManager::printState() {
 }
 
 void UIManager::printCommsNotSupported() {
-    m_executor.submit([]() { ConsolePrinter::simplePrint("Comms is not supported in this device."); });
+    m_executor.execute([]() { ConsolePrinter::simplePrint("Comms is not supported in this device."); });
 }
 
 void UIManager::setFailureStatus(const std::string& status) {
@@ -1167,7 +1167,7 @@ bool UIManager::configureSettingsNotifications(std::shared_ptr<settings::DeviceS
 }
 
 void UIManager::onActiveDeviceConnected(const DeviceAttributes& deviceAttributes) {
-    m_executor.submit([deviceAttributes]() {
+    m_executor.execute([deviceAttributes]() {
         std::ostringstream oss;
         oss << "SUPPORTED SERVICES: ";
         std::string separator = "";
@@ -1180,7 +1180,7 @@ void UIManager::onActiveDeviceConnected(const DeviceAttributes& deviceAttributes
 }
 
 void UIManager::onActiveDeviceDisconnected(const DeviceAttributes& deviceAttributes) {
-    m_executor.submit([deviceAttributes]() {
+    m_executor.execute([deviceAttributes]() {
         std::ostringstream oss;
         oss << "SUPPORTED SERVICES: ";
         std::string separator = "";
diff --git a/SampleApp/src/main.cpp b/SampleApp/src/main.cpp
index 9b23bf85..88d9ebf7 100644
--- a/SampleApp/src/main.cpp
+++ b/SampleApp/src/main.cpp
@@ -21,6 +21,10 @@
 #include "SampleApp/SDKDiagnostics.h"
 #endif
 
+#ifdef MULTI_AGENT_EXPERIENCE
+#include <MultiAgentExperience/Utils/Logger/Logger.h>
+#endif
+
 #include <cstdlib>
 #include <string>
 
@@ -55,6 +59,16 @@ int main(int argc, char* argv[]) {
     std::vector<std::string> configFiles;
     std::string logLevel;
 
+#ifdef MULTI_AGENT_EXPERIENCE
+    auto logger = std::make_shared<multiAgentExperience::logger::Logger>();
+    logger->setLogLevel(multiAgentExperience::utils::Log::Level::DEBUG3);
+    multiAgentExperience::logger::setLoggerComponentName("MAX_LIB");
+    multiAgentExperience::logger::setLoggerInstance(logger);
+
+    // To store the client and server URIs required for the MAX IPC connection
+    std::vector<std::string> maxConnectionDetails;
+#endif
+
     if (usesOptStyleArgs(argc, argv)) {
         for (int i = 1; i < argc; i++) {
             if (strcmp(argv[i], "-C") == 0) {
@@ -89,6 +103,22 @@ int main(int argc, char* argv[]) {
 
         configFiles.push_back(std::string(argv[1]));
         ConsolePrinter::simplePrint("configFile " + std::string(argv[1]));
+
+#ifdef MULTI_AGENT_EXPERIENCE
+        /// If the 3rd and 4th command line arguments are supplied then we interpret them as
+        /// clientUri & serverUri which will then be used for establishing a connection to the MAX process.
+        /// 5th parameter is the agent name/id to be used for Alexa.
+        if (6 == argc) {
+            logLevel = std::string(argv[2]);
+            auto clientUri = std::string(argv[3]);
+            auto serverUri = std::string(argv[4]);
+            auto agentName = std::string(argv[5]);
+
+            maxConnectionDetails.push_back(clientUri);
+            maxConnectionDetails.push_back(serverUri);
+            maxConnectionDetails.push_back(agentName);
+        }
+#endif
     }
 
     auto consoleReader = std::make_shared<ConsoleReader>();
@@ -108,9 +138,11 @@ int main(int argc, char* argv[]) {
             consoleReader,
             configFiles,
             logLevel
+#ifdef MULTI_AGENT_EXPERIENCE
+            , maxConnectionDetails
+#endif
 #ifdef DIAGNOSTICS
-            ,
-            diagnostics
+            , diagnostics
 #endif
         );
 
diff --git a/Settings/include/Settings/DoNotDisturbSettingObserverWrapper.h b/Settings/include/Settings/DoNotDisturbSettingObserverWrapper.h
new file mode 100644
index 00000000..3612a6bc
--- /dev/null
+++ b/Settings/include/Settings/DoNotDisturbSettingObserverWrapper.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_DONOTDISTURBSETTINGOBSERVERWRAPPER_H_
+#define ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_DONOTDISTURBSETTINGOBSERVERWRAPPER_H_
+
+#include <AVSCommon/SDKInterfaces/DoNotDisturbSettingObserverInterface.h>
+#include <Settings/DeviceSettingsManager.h>
+
+namespace alexaClientSDK {
+namespace settings {
+
+class DoNotDisturbSettingObserverWrapper : public settings::SettingObserverInterface<DoNotDisturbSetting> {
+public:
+    /// Constructor
+    DoNotDisturbSettingObserverWrapper(std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> doNotDisturbSettingObserver);
+
+    /// Destructor
+    ~DoNotDisturbSettingObserverWrapper() = default;
+
+    /// @name SettingObserverInterface method overrides.
+    /// @{
+    void onSettingNotification(const bool& value,
+                               settings::SettingNotifications notification) override;
+    /// @}
+
+private:
+    bool m_settingValue;
+    std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> m_doNotDisturbSettingObserver;
+};
+
+}
+}
+
+#endif // ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_DONOTDISTURBSETTINGOBSERVERWRAPPER_H_
\ No newline at end of file
diff --git a/Settings/src/CMakeLists.txt b/Settings/src/CMakeLists.txt
index 3a324d8e..091daf02 100644
--- a/Settings/src/CMakeLists.txt
+++ b/Settings/src/CMakeLists.txt
@@ -1,9 +1,10 @@
 add_definitions("-DACSDK_LOG_MODULE=settings")
 
-
-add_library(DeviceSettings
+set(DeviceSettings_SOURCES)
+list(APPEND DeviceSettings_SOURCES
         CloudControlledSettingProtocol.cpp
         DeviceControlledSettingProtocol.cpp
+        DoNotDisturbSettingObserverWrapper.cpp
         SettingEventSender.cpp
         SettingEventRequestObserver.cpp
         SettingConnectionObserver.cpp
@@ -12,6 +13,9 @@ add_library(DeviceSettings
         Types/LocaleWakeWordsSetting.cpp
         Types/NetworkInfo.cpp)
 
+add_library(DeviceSettings
+        "${DeviceSettings_SOURCES}")
+
 target_include_directories(DeviceSettings PUBLIC
     "${AVSCommon_SOURCE_DIR}/include"
     "${CertifiedSender_SOURCE_DIR}/include"
diff --git a/Settings/src/DoNotDisturbSettingObserverWrapper.cpp b/Settings/src/DoNotDisturbSettingObserverWrapper.cpp
new file mode 100644
index 00000000..fa2bb9dc
--- /dev/null
+++ b/Settings/src/DoNotDisturbSettingObserverWrapper.cpp
@@ -0,0 +1,37 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include "Settings/DoNotDisturbSettingObserverWrapper.h"
+
+namespace alexaClientSDK {
+namespace settings {
+
+DoNotDisturbSettingObserverWrapper::DoNotDisturbSettingObserverWrapper(
+    std::shared_ptr<avsCommon::sdkInterfaces::DoNotDisturbSettingObserverInterface> doNotDisturbSettingObserver)
+        : m_settingValue{false},
+          m_doNotDisturbSettingObserver{doNotDisturbSettingObserver} {
+}
+
+void DoNotDisturbSettingObserverWrapper::onSettingNotification(const bool& value, settings::SettingNotifications notification) {
+    if (m_doNotDisturbSettingObserver) {
+        if (value != m_settingValue) {
+            m_settingValue = value;
+            m_doNotDisturbSettingObserver->onDoNotDisturbSettingChanged(m_settingValue);
+        }
+    }
+}
+
+}
+}
\ No newline at end of file
diff --git a/Settings/src/SharedAVSSettingProtocol.cpp b/Settings/src/SharedAVSSettingProtocol.cpp
index 3ff0f55c..f937cb42 100644
--- a/Settings/src/SharedAVSSettingProtocol.cpp
+++ b/Settings/src/SharedAVSSettingProtocol.cpp
@@ -150,7 +150,7 @@ SetSettingResult SharedAVSSettingProtocol::localChange(
     m_pendingRequest = std::unique_ptr<Request>(new Request(applyChange, revertChange, notifyObservers));
 
     if (executorReady) {
-        m_executor.submit([this]() {
+        m_executor.execute([this]() {
             std::unique_lock<std::mutex> lock(m_requestLock);
             auto request = std::move(m_pendingRequest);
             lock.unlock();
@@ -219,7 +219,7 @@ bool SharedAVSSettingProtocol::avsChange(
     m_pendingRequest = std::unique_ptr<Request>(new Request(applyChange, revertChange, notifyObservers));
 
     if (executorReady) {
-        m_executor.submit([this]() {
+        m_executor.execute([this]() {
             std::unique_lock<std::mutex> lock(m_requestLock);
             auto request = std::move(m_pendingRequest);
             lock.unlock();
@@ -368,7 +368,7 @@ void SharedAVSSettingProtocol::executeSynchronizeOnConnected() {
 
 void SharedAVSSettingProtocol::connectionStatusChangeCallback(bool isConnected) {
     if (isConnected) {
-        m_executor.submit(std::bind(&SharedAVSSettingProtocol::executeSynchronizeOnConnected, this));
+        m_executor.execute(std::bind(&SharedAVSSettingProtocol::executeSynchronizeOnConnected, this));
     }
 }
 
diff --git a/Settings/src/Types/LocaleWakeWordsSetting.cpp b/Settings/src/Types/LocaleWakeWordsSetting.cpp
index f51d835f..2a136eda 100644
--- a/Settings/src/Types/LocaleWakeWordsSetting.cpp
+++ b/Settings/src/Types/LocaleWakeWordsSetting.cpp
@@ -253,7 +253,7 @@ SetSettingResult LocaleWakeWordsSetting::setLocales(const DeviceLocales& locales
 
     RequestParameters request{requestType, locales, wakeWordsRequestType, wakeWords};
     m_pendingRequest.reset(new RequestParameters(request));
-    m_executor.submit([this, request] { executeChangeValue(request); });
+    m_executor.execute([this, request] { executeChangeValue(request); });
     return SetSettingResult::ENQUEUED;
 }
 
@@ -309,7 +309,7 @@ SetSettingResult LocaleWakeWordsSetting::setWakeWords(const WakeWords& wakeWords
 
     RequestParameters request{localeRequestType, locales, requestType, wakeWords};
     m_pendingRequest.reset(new RequestParameters(request));
-    m_executor.submit([this, request] { executeChangeValue(request); });
+    m_executor.execute([this, request] { executeChangeValue(request); });
     return SetSettingResult::ENQUEUED;
 }
 
@@ -415,9 +415,9 @@ void LocaleWakeWordsSetting::restoreInitialValue() {
         RequestType wakeWordsRequestType = toRequestType(m_wakeWordsStatus);
         auto pendingRequest = RequestParameters(localeRequestType, locales, wakeWordsRequestType, wakeWords);
         m_pendingRequest.reset(new RequestParameters(pendingRequest));
-        m_executor.submit([this, pendingRequest] { executeChangeValue(pendingRequest); });
+        m_executor.execute([this, pendingRequest] { executeChangeValue(pendingRequest); });
     } else {
-        m_executor.submit([this, locales, wakeWords] {
+        m_executor.execute([this, locales, wakeWords] {
             // Make sure assets manager is correctly initialized.
             if (!m_assetsManager->changeAssets(locales, wakeWords)) {
                 ACSDK_ERROR(LX("restoreInitialValueFailed")
@@ -667,7 +667,7 @@ void LocaleWakeWordsSetting::onConnectionStatusChanged(const Status status, cons
     if (Status::CONNECTED == status) {
         // Create a dummy request that doesn't interrupt any ongoing operation but that respect newer requests.
         RequestParameters request(RequestType::NONE, DeviceLocales(), RequestType::NONE, WakeWords());
-        m_executor.submit([this, request] { synchronize(request); });
+        m_executor.execute([this, request] { synchronize(request); });
     }
 }
 
diff --git a/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h b/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
index 6b8a0874..29b352c7 100644
--- a/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
+++ b/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
@@ -43,6 +43,7 @@ using AlexaCommunicationsComponent = acsdkManufactory::Component<
     acsdkManufactory::Import<acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::AVSConnectionManagerInterface,
         avsCommon::utils::libcurlUtils::LibcurlSetCurlOptionsCallbackFactoryInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>>;
 
diff --git a/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h b/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
index bcde9482..9101d393 100644
--- a/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
+++ b/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
@@ -46,6 +46,7 @@
 #include <AVSCommon/SDKInterfaces/Diagnostics/DiagnosticsInterface.h>
 #include <AVSCommon/SDKInterfaces/ExpectSpeechTimeoutHandlerInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h>
 #include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/VisualFocusAnnotation.h>
 #include <AVSCommon/Utils/Configuration/ConfigurationNode.h>
@@ -79,6 +80,9 @@ using PreviewAlexaClientComponent = acsdkManufactory::Component<
         Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
     acsdkManufactory::
         Annotated<avsCommon::sdkInterfaces::VisualFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::AudioFocusAnnotation,
+        avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
     acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
         avsCommon::sdkInterfaces::endpoints::EndpointBuilderInterface>,
@@ -152,7 +156,8 @@ PreviewAlexaClientComponent getComponent(
     const std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface>& diagnostics,
     const std::shared_ptr<sampleApp::PlatformSpecificValues>& platformSpecificValues,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager);
+    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator);
 
 }  // namespace acsdkPreviewAlexaClient
 }  // namespace alexaClientSDK
diff --git a/applications/acsdkPreviewAlexaClient/src/CMakeLists.txt b/applications/acsdkPreviewAlexaClient/src/CMakeLists.txt
index f0ea97a3..ed1e65c9 100644
--- a/applications/acsdkPreviewAlexaClient/src/CMakeLists.txt
+++ b/applications/acsdkPreviewAlexaClient/src/CMakeLists.txt
@@ -20,6 +20,7 @@ target_link_libraries(LibPreviewAlexaClient
         ${ACSDKMETRICRECORDER_LIB}
         ${ACSDKSPEECHENCODER_LIB}
         ${ACSDKSYSTEMTIMEZONE_LIB}
+        AFML
         acsdkAlerts
         acsdkApplicationAudioPipelineFactoryInterfaces
         acsdkCore
diff --git a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
index 50cf2cb0..b49ce83f 100644
--- a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
+++ b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
@@ -160,6 +160,9 @@ using PreviewAlexaClientManufactory = Manufactory<
     acsdkManufactory::Annotated<
         avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
         avsCommon::sdkInterfaces::endpoints::EndpointBuilderInterface>,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::AudioFocusAnnotation,
+        avsCommon::sdkInterfaces::ExternalFocusMediatorCallbackInterface>,
     std::shared_ptr<acsdkAlertsInterfaces::AlertsCapabilityAgentInterface>,
     std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::ApplicationAudioPipelineFactoryInterface>,
     std::shared_ptr<acsdkAudioPlayerInterfaces::AudioPlayerInterface>,
@@ -791,7 +794,7 @@ bool PreviewAlexaClient::initialize(
     auto initParams = builder->build();
 
     auto previewAlexaClientComponent = acsdkPreviewAlexaClient::getComponent(
-        std::move(initParams), diagnostics, platformSpecificValues, nullptr, powerResourceManager);
+        std::move(initParams), diagnostics, platformSpecificValues, nullptr, powerResourceManager, nullptr);
 
     std::shared_ptr<PreviewAlexaClientManufactory> manufactory =
         PreviewAlexaClientManufactory::create(previewAlexaClientComponent);
@@ -1105,6 +1108,10 @@ bool PreviewAlexaClient::initialize(
         nullptr,
         diagnostics,
         std::make_shared<alexaClientSDK::sampleApp::ExternalCapabilitiesBuilder>(deviceInfo),
+#ifdef MULTI_AGENT_EXPERIENCE
+        nullptr,
+        nullptr,
+#endif
         tapToTalkAudioProvider);
     if (!client) {
         ACSDK_CRITICAL(LX("Failed to create default SDK client!"));
diff --git a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
index 35729349..a5807ce7 100644
--- a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
+++ b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
@@ -18,6 +18,7 @@
 #include <acsdkAlexaCommunications/AlexaCommunicationsComponent.h>
 #include <acsdkApplicationAudioPipelineFactory/ApplicationAudioPipelineFactoryComponent.h>
 #include <acsdkAudioInputStream/AudioInputStreamComponent.h>
+#include <AFML/FocusManagementComponent.h>
 #include <acsdkAudioPlayer/AudioPlayerComponent.h>
 #include <acsdkAuthorizationDelegate/AuthorizationDelegateComponent.h>
 #include <acsdkBluetooth/BasicDeviceConnectionRulesProvider.h>
@@ -149,7 +150,8 @@ PreviewAlexaClientComponent getComponent(
     const std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface>& diagnostics,
     const std::shared_ptr<sampleApp::PlatformSpecificValues>& platformSpecificValues,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>& externalFocusMediator) {
     /// This component is provided as a preview of changes to come. The imports, exports, and factory methods
     /// will change while manufactory integration is incrementally released over the next several releases.
 
@@ -165,6 +167,7 @@ PreviewAlexaClientComponent getComponent(
         /// Implementations created at the application level, added to the manufactory to satisfy dependencies.
         .addInstance(expectSpeechTimeoutHandler)
         .addInstance(powerResourceManager)
+        .addInstance(externalFocusMediator)
 
         /// Baseline SDK components. Applications are not expected to modify these.
         .addComponent(acsdkCore::getComponent())
@@ -172,6 +175,7 @@ PreviewAlexaClientComponent getComponent(
         .addComponent(acsdkInternetConnectionMonitor::getComponent())
         .addComponent(acsdkHTTPContentFetcher::getComponent())
         .addComponent(acsdkShared::getComponent())
+        .addComponent(afml::getComponent())
         .addRetainedFactory(certifiedSender::CertifiedSender::create)
         .addRetainedFactory(createSetCurlOptionsCallbackForAVSConnectionManager)
         .addRetainedFactory(createSetCurlOptionsCallbackForHTTPContentFetcherInterfaceFactory)
diff --git a/capabilities/Alerts/acsdkAlerts/src/Alert.cpp b/capabilities/Alerts/acsdkAlerts/src/Alert.cpp
index c6175340..d3e96abb 100644
--- a/capabilities/Alerts/acsdkAlerts/src/Alert.cpp
+++ b/capabilities/Alerts/acsdkAlerts/src/Alert.cpp
@@ -641,6 +641,13 @@ void Alert::onRendererStateChange(RendererObserverInterface::State state, const
         // more CAs than just Alerts/Reminders.
         std::this_thread::sleep_for(std::chrono::milliseconds(75));
         startRenderer();
+        {
+            std::lock_guard<std::mutex> lockAgain(m_mutex);
+            if (State::STOPPING == m_dynamicData.state) {
+                ACSDK_WARN(LX("The Alert was deactiveated while sleeping, immediately stop."));
+                m_renderer->stop();
+            }
+        }
     }
 }
 
diff --git a/capabilities/Alerts/acsdkAlerts/test/AlertTest.cpp b/capabilities/Alerts/acsdkAlerts/test/AlertTest.cpp
index 6dcc6fc9..d6f4db6a 100644
--- a/capabilities/Alerts/acsdkAlerts/test/AlertTest.cpp
+++ b/capabilities/Alerts/acsdkAlerts/test/AlertTest.cpp
@@ -573,6 +573,74 @@ TEST_F(AlertTest, test_focusChangeDuringActivation) {
     m_alert->onRendererStateChange(RendererObserverInterface::State::STARTED, "started");
 }
 
+TEST_F(AlertTest, test_deactivation_while_resuming_from_background_during_a_thread_sleep) {
+    // This test mimics the real threading model. The test thread is the focus manager thread, and this new thread is
+    // the renderer thread.
+    avsCommon::utils::threading::Executor m_renderingThread;
+
+    // reset the alert to a valid alert
+    m_alert->reset();
+    std::string schedTime{"2030-02-02T12:56:34+0000"};
+    Alert::DynamicData dynamicData;
+    m_alert->getAlertData(nullptr, &dynamicData);
+    ASSERT_TRUE(dynamicData.timePoint.setTime_ISO_8601(schedTime));
+    m_alert->setAlertData(nullptr, &dynamicData);
+    ASSERT_EQ(m_alert->getState(), Alert::State::SET);
+
+    // Activate alert and put it in the FOREGROUND.
+    EXPECT_CALL(*(m_renderer.get()), start(_, _, _, _, _, _, _)).Times(3);
+    EXPECT_CALL(*(m_renderer.get()), stop()).Times(4);
+    m_alert->setFocusState(avsCommon::avs::FocusState::FOREGROUND, avsCommon::avs::MixingBehavior::PRIMARY);
+    m_alert->activate();
+    ASSERT_EQ(m_alert->getState(), Alert::State::ACTIVATING);
+    m_alert->setStateActive();
+    ASSERT_EQ(m_alert->getState(), Alert::State::ACTIVE);
+
+    m_renderingThread.submit([this](){
+        m_alert->onRendererStateChange(RendererObserverInterface::State::STARTED, "started");
+    });
+
+    // Wait for rendering to start and for the alert to be in the started rendering state.
+    m_renderingThread.waitForSubmittedTasks();
+
+    // Move the alert to the background.
+    m_alert->setFocusState(avsCommon::avs::FocusState::BACKGROUND, avsCommon::avs::MixingBehavior::MAY_DUCK);
+    m_renderingThread.submit([this](){
+        m_alert->onRendererStateChange(RendererObserverInterface::State::STOPPED, "stopped");
+    });
+
+    // Wait for the rendering to stop. This will wait the 75 milliseconds in the retry case.
+    m_renderingThread.waitForSubmittedTasks();
+
+
+    // Move the alert back to the foreground
+    m_alert->setFocusState(avsCommon::avs::FocusState::FOREGROUND, avsCommon::avs::MixingBehavior::PRIMARY);
+
+    // Schedule both rendering updates from this transition.
+    m_renderingThread.submit([this](){
+        m_alert->onRendererStateChange(RendererObserverInterface::State::STARTED, "started");
+    });
+
+    m_renderingThread.submit([this](){
+        m_alert->onRendererStateChange(RendererObserverInterface::State::STOPPED, "stopped");
+    });
+
+    // Wait for some time, this must be long enough to allow the STOPPED update to start sleeping, and short enough that
+    // it has not finished yet.
+    std::this_thread::sleep_for(std::chrono::milliseconds(20));
+
+    // Deactivate the alert
+    Alert::StopReason stopReason = Alert::StopReason::LOCAL_STOP;
+    m_alert->deactivate(stopReason);
+
+    // Wait for the sleep to finish
+    m_renderingThread.waitForSubmittedTasks();
+
+    // This test will fail if the expected number of starts and stops are not called. These expected values are 3 starts
+    // and 4 stops. They are not an equal number as the focus change to FOREGROUND will blindly call stop on the renderer
+    // even though it is not active. The other 3 stops match the calls to start.
+}
+
 }  // namespace test
 }  // namespace acsdkAlerts
 }  // namespace alexaClientSDK
diff --git a/capabilities/MultiAssistantUniversalDeviceController/CMakeLists.txt b/capabilities/MultiAssistantUniversalDeviceController/CMakeLists.txt
new file mode 100644
index 00000000..1c939650
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/CMakeLists.txt
@@ -0,0 +1,3 @@
+cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
+
+add_subdirectory("acsdkMultiAssistant")
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/CMakeLists.txt b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/CMakeLists.txt
new file mode 100644
index 00000000..7d43f723
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/CMakeLists.txt
@@ -0,0 +1,10 @@
+cmake_minimum_required(VERSION 3.10)
+if(MULTI_AGENT_EXPERIENCE_ENABLED)
+    project(acsdkMultiAssistant LANGUAGES CXX)
+    include(${AVS_CMAKE_BUILD}/BuildDefaults.cmake)
+    add_subdirectory("src")
+
+    if (BUILD_TESTING)
+        add_subdirectory("test")
+    endif()
+endif()
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/include/acsdkMultiAssistant/UniversalDeviceController.h b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/include/acsdkMultiAssistant/UniversalDeviceController.h
new file mode 100644
index 00000000..f8d9515c
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/include/acsdkMultiAssistant/UniversalDeviceController.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#ifndef ACSDKMULTIASSISTANTINTERFACES_UNIVERSALDEVICECONTROLLER_H
+#define ACSDKMULTIASSISTANTINTERFACES_UNIVERSALDEVICECONTROLLER_H
+
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsInvokerInterface.h"
+#include "AVSCommon/SDKInterfaces/UniversalDeviceCommandsProviderInterface.h"
+#include "AVSCommon/SDKInterfaces/ContextManagerInterface.h"
+#include "AVSCommon/AVS/CapabilityAgent.h"
+#include "AVSCommon/SDKInterfaces/CapabilitiesDelegateInterface.h"
+#include "AVSCommon/SDKInterfaces/ContextRequesterInterface.h"
+#include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
+#include "AVSCommon/Utils/RequiresShutdown.h"
+#include "AVSCommon/Utils/Threading/Executor.h"
+
+namespace alexaClientSDK {
+namespace acsdkMultiAssistant {
+
+    class UniversalDeviceController
+        : public avsCommon::avs::CapabilityAgent
+          , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+          , public avsCommon::utils::RequiresShutdown {
+    public:
+        /**
+         * Constructs a @c UniversalDeviceController instance.
+         *
+         * @param messageSender Sends events to AVS.
+         */
+        static std::shared_ptr<UniversalDeviceController> create(
+            std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+            std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+            std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+            avsCommon::sdkInterfaces::endpoints::EndpointIdentifier endPointIdentifier,
+            std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface> universalDeviceCommandsInvoker,
+            std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> universalDeviceCommandsProvider);
+
+        /// @name CapabilityAgent/DirectiveHandlerInterface Functions
+        /// @{
+        void handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
+        void preHandleDirective(std::shared_ptr<DirectiveInfo> info) override;
+        void handleDirective(std::shared_ptr<DirectiveInfo> info) override;
+        void cancelDirective(std::shared_ptr<DirectiveInfo> info) override;
+        avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+        /// @}
+
+        /// @name CapabilityConfigurationInterface Functions
+        /// @{
+        std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+        /// @}
+
+        /// @name RequiresShutdown Functions
+        /// @{
+        void doShutdown() override;
+        /// @}
+
+        /// @name StateProviderInterface Functions
+        /// @{
+        void provideState(
+            const avsCommon::avs::CapabilityTag& stateProviderName,
+            const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) override;
+        bool canStateBeRetrieved() override;
+        bool hasReportableStateProperties() override;
+        bool shouldQueryState() override;
+        /// @}
+
+    private:
+        /**
+         * Constructor. Will only be called with non-null parameters via the create() methods.
+         *
+         * @param exceptionSender Sends exceptions to AVS.
+         * @param messageSender Sends events to AVS.
+         * @param universalDeviceCommandsInvoker Used to actually invoke an UDC.
+         */
+        UniversalDeviceController(
+            std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+            std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+            std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+            avsCommon::sdkInterfaces::endpoints::EndpointIdentifier endPointIdentifier,
+            std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface> universalDeviceCommandsInvoker,
+            std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> universalDeviceCommandsProvider);
+
+        bool retreiveCommandIdFromDirectiveInfo(std::shared_ptr<DirectiveInfo> info, std::string& commandId);
+
+        bool parseDirectivePayload(std::string payloadString, rapidjson::Document* document) noexcept;
+
+        bool checkForValidCommandId(const std::string& commandId);
+
+        void sendExceptionEncountered(
+            std::shared_ptr<CapabilityAgent::DirectiveInfo> info,
+            const std::string& message,
+            avsCommon::avs::ExceptionErrorType type) noexcept;
+
+        void invokeControl(const std::string& universalDeviceCommand);
+
+        std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
+        std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface> m_universalDeviceCommandsInvoker;
+        std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> m_universalDeviceCommandsProvider;
+        avsCommon::utils::threading::Executor m_executor;
+        avsCommon::sdkInterfaces::endpoints::EndpointIdentifier m_endPointIdentifier;
+    };
+
+}  // namespace acsdkMultiAssistant
+}  // namespace alexaClientSDK
+
+#endif  // ACSDKMULTIASSISTANTINTERFACES_UNIVERSALDEVICECONTROLLER_H
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/CMakeLists.txt b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/CMakeLists.txt
new file mode 100644
index 00000000..19d4414a
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/CMakeLists.txt
@@ -0,0 +1,18 @@
+add_definitions("-DACSDK_LOG_MODULE=acsdkMultiAssistant")
+
+set(MultiAssistant_SOURCES)
+list(APPEND MultiAssistant_SOURCES
+        UniversalDeviceController.cpp)
+
+add_library(acsdkMultiAssistant
+        "${MultiAssistant_SOURCES}")
+
+target_include_directories(acsdkMultiAssistant PUBLIC
+        "${acsdkMultiAssistant_SOURCE_DIR}/include")
+
+target_link_libraries(acsdkMultiAssistant
+        AVSCommon
+        MultiAgentExperience-Alexa-Adapter)
+
+# install target
+asdk_install()
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/UniversalDeviceController.cpp b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/UniversalDeviceController.cpp
new file mode 100644
index 00000000..d0b04e86
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/src/UniversalDeviceController.cpp
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+#include <acsdkMultiAssistant/UniversalDeviceController.h>
+
+#include <rapidjson/document.h>
+#include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+
+namespace alexaClientSDK {
+namespace acsdkMultiAssistant {
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("UniversalDeviceController");
+
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+const std::string NAMESPACE = "MultiAssistant.UniversalDeviceController";
+
+/// The @c InvokeCommand directive identifier.
+const avsCommon::avs::NamespaceAndName INVOKE_COMMAND{NAMESPACE, "InvokeCommand"};
+
+/// The @c command key in the @c GLOBAL_FOREGROUND_STOP AVS directive.
+const char COMMAND_KEY[] = "command";
+
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_NAME = "MultiAssistant.UniversalDeviceController";
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_VERSION = "1.0";
+
+const std::vector<std::string> VALID_COMMAND_IDS = {
+    "GLOBAL_FOREGROUND_STOP"
+};
+
+std::shared_ptr<avsCommon::avs::CapabilityConfiguration> getUniversalDeviceControllerCapabilityConfiguration() {
+    std::unordered_map<std::string, std::string> configMap;
+    configMap.insert({avsCommon::avs::CAPABILITY_INTERFACE_TYPE_KEY, UNIVERSALDEVICECONTROLLER_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({avsCommon::avs::CAPABILITY_INTERFACE_NAME_KEY, UNIVERSALDEVICECONTROLLER_CAPABILITY_NAME});
+    configMap.insert({avsCommon::avs::CAPABILITY_INTERFACE_VERSION_KEY, UNIVERSALDEVICECONTROLLER_CAPABILITY_VERSION});
+
+    return std::make_shared<avsCommon::avs::CapabilityConfiguration>(configMap);
+}
+
+UniversalDeviceController::UniversalDeviceController(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+    avsCommon::sdkInterfaces::endpoints::EndpointIdentifier endPointIdentifier,
+    std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface> universalDeviceCommandsInvoker,
+    std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> universalDeviceCommandsProvider) :
+    CapabilityAgent{NAMESPACE, std::move(exceptionSender)},
+    RequiresShutdown{"UniversalDeviceController"},
+    m_messageSender{std::move(messageSender)},
+    m_contextManager{contextManager},
+    m_universalDeviceCommandsInvoker{universalDeviceCommandsInvoker},
+    m_universalDeviceCommandsProvider{universalDeviceCommandsProvider},
+    m_endPointIdentifier{endPointIdentifier} {
+    m_capabilityConfigurations.insert(getUniversalDeviceControllerCapabilityConfiguration());
+}
+
+std::shared_ptr<UniversalDeviceController> UniversalDeviceController::create(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+    avsCommon::sdkInterfaces::endpoints::EndpointIdentifier endPointIdentifier,
+    std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsInvokerInterface> universalDeviceCommandsInvoker,
+    std::shared_ptr<avsCommon::sdkInterfaces::UniversalDeviceCommandsProviderInterface> universalDeviceCommandsProvider) {
+
+    if (!exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "emptyExceptionSender"));
+        return nullptr;
+    }
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "emptyMessageSender"));
+        return nullptr;
+    }
+    if (!universalDeviceCommandsInvoker) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "emptyUniversalDeviceCommandsInvoker"));
+        return nullptr;
+    }
+    if (!universalDeviceCommandsProvider) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "emptyUniversalDeviceCommandsProvider"));
+        return nullptr;
+    }
+
+    auto universalDeviceController =
+        std::shared_ptr<UniversalDeviceController>(new UniversalDeviceController(exceptionSender,
+                                                                                 messageSender,
+                                                                                 contextManager,
+                                                                                 endPointIdentifier,
+                                                                                 universalDeviceCommandsInvoker,
+                                                                                 universalDeviceCommandsProvider));
+    if (!universalDeviceController) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "instantiationFailed"));
+        return nullptr;
+    }
+
+    contextManager->addStateProvider(
+        universalDeviceCommandsProvider->getUniversalDeviceControllerTag(),
+        universalDeviceController);
+
+    return universalDeviceController;
+}
+
+void UniversalDeviceController::handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) {
+    if (!directive) {
+        ACSDK_ERROR(LX("handleDirectiveImmediatelyFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+}
+
+void UniversalDeviceController::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
+    // No-op.
+}
+
+void UniversalDeviceController::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    if (!info) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+    if (!info->directive) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirective"));
+        return;
+    }
+
+    m_executor.execute([this, info] {
+        std::string commandId;
+        if (!retreiveCommandIdFromDirectiveInfo(info, commandId)) {
+            sendExceptionEncountered(
+                info,
+                "Retreiving CommandId Failed",
+                avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        if (!checkForValidCommandId(commandId)) {
+            sendExceptionEncountered(
+                info, "Invalid CommandId", avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        // Directives always correspond to UDC
+        invokeControl(commandId);
+    });
+}
+
+void UniversalDeviceController::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG9(LX(__func__));
+    if (!info || !info->directive) {
+        ACSDK_ERROR(LX("cancelDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+    CapabilityAgent::removeDirective(info->directive->getMessageId());
+}
+
+avsCommon::avs::DirectiveHandlerConfiguration UniversalDeviceController::getConfiguration() const {
+    auto neitherNonBlockingPolicy = avsCommon::avs::BlockingPolicy(avsCommon::avs::BlockingPolicy::MEDIUMS_NONE, false);
+
+    avsCommon::avs::DirectiveHandlerConfiguration configuration;
+    configuration[INVOKE_COMMAND] = neitherNonBlockingPolicy;
+
+    return configuration;
+}
+
+std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> UniversalDeviceController::
+getCapabilityConfigurations() {
+    return m_capabilityConfigurations;
+}
+
+void UniversalDeviceController::doShutdown() {
+    m_messageSender.reset();
+    m_executor.shutdown();
+    m_contextManager->removeStateProvider(m_universalDeviceCommandsProvider->getUniversalDeviceControllerTag());
+}
+
+void UniversalDeviceController::invokeControl(const std::string& universalDeviceCommands) {
+    if (!m_universalDeviceCommandsInvoker->invokeCommand(universalDeviceCommands)) {
+        ACSDK_ERROR(LX("invokeControlFailed")
+                        .d("reason", "UniversalDeviceCommandsInvoker::invokeControlFailed")
+                        .d("control", universalDeviceCommands));
+        return;
+    }
+}
+
+bool UniversalDeviceController::retreiveCommandIdFromDirectiveInfo(
+    std::shared_ptr<DirectiveInfo> info,
+    std::string& commandId) {
+    rapidjson::Document payload(rapidjson::kObjectType);
+    if (!parseDirectivePayload(info->directive->getPayload(), &payload)) {
+        sendExceptionEncountered(
+            info, "Payload Parsing Failed", avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    if (info->directive->getName() == INVOKE_COMMAND.name) {
+        if (!avsCommon::utils::json::jsonUtils::retrieveValue(payload, COMMAND_KEY, &commandId)) {
+            ACSDK_ERROR(LX("retreiveCommandIdFromDirectiveInfoFailed")
+                            .d("reason", "retrieveCommandIdFailed")
+                            .d("namespace", info->directive->getNamespace())
+                            .d("name", info->directive->getName()));
+            sendExceptionEncountered(
+                info,
+                "Parsing commandId Payload Value Failed",
+                avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return false;
+        }
+    } else {
+        ACSDK_ERROR(LX("retreiveCommandIdFromDirectiveInfoFailed")
+                        .d("reason", "unknownDirective")
+                        .d("namespace", info->directive->getNamespace())
+                        .d("name", info->directive->getName()));
+        sendExceptionEncountered(
+            info, "Unexpected Directive", avsCommon::avs::ExceptionErrorType::UNSUPPORTED_OPERATION);
+        return false;
+    }
+
+    return true;
+}
+
+bool UniversalDeviceController::parseDirectivePayload(std::string payload, rapidjson::Document* document) noexcept {
+    ACSDK_DEBUG9(LX(__func__));
+    if (!document) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed").d("reason", "nullDocument"));
+        return false;
+    }
+
+    rapidjson::ParseResult result = document->Parse(payload);
+    if (!result) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed")
+                        .d("reason", "parseFailed")
+                        .d("error", GetParseError_En(result.Code()))
+                        .d("offset", result.Offset()));
+        return false;
+    }
+    return true;
+}
+
+bool UniversalDeviceController::checkForValidCommandId(const std::string& commandId) {
+    return VALID_COMMAND_IDS.end() != std::find(VALID_COMMAND_IDS.begin(), VALID_COMMAND_IDS.end(), commandId);
+}
+
+void UniversalDeviceController::sendExceptionEncountered(
+    std::shared_ptr<CapabilityAgent::DirectiveInfo> info,
+    const std::string& message,
+    avsCommon::avs::ExceptionErrorType type) noexcept {
+    ACSDK_DEBUG9(LX(__func__));
+    m_exceptionEncounteredSender->sendExceptionEncountered(
+        info->directive->getUnparsedDirective(),
+        avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED,
+        message);
+    if (info->result) {
+        info->result->setFailed(message);
+    }
+}
+
+void UniversalDeviceController::provideState(
+    const avsCommon::avs::CapabilityTag& stateProviderName,
+    const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) {
+    m_executor.execute([this, stateProviderName, contextRequestToken] {
+        if (m_contextManager) {
+            auto udcState = m_universalDeviceCommandsProvider->getUniversalDeviceControllerState();
+            m_contextManager->provideStateResponse(
+                    stateProviderName, udcState, contextRequestToken);
+        } else {
+            ACSDK_ERROR(LX("provideStateFailed").d("reason", "null ContextManager"));
+            m_contextManager->provideStateUnavailableResponse(stateProviderName, contextRequestToken, false);
+        }
+    });
+}
+
+bool UniversalDeviceController::canStateBeRetrieved() {
+    return false;
+}
+
+bool UniversalDeviceController::hasReportableStateProperties() {
+    return false;
+}
+
+bool UniversalDeviceController::shouldQueryState() {
+    return false;
+}
+
+}  // namespace acsdkMultiAssistant
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/CMakeLists.txt b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/CMakeLists.txt
new file mode 100644
index 00000000..c9efeaa6
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/CMakeLists.txt
@@ -0,0 +1,12 @@
+cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${acsdkMultiAssistant_INCLUDE_DIRS}"
+        "${AVSCommon_SOURCE_DIR}/AVS/test")
+
+set(LIBS
+        "acsdkMultiAssistant"
+        "SDKInterfacesTests")
+
+#discover_unit_tests("${INCLUDE_PATH}" "${LIBS}")
+discover_unit_tests("${INCLUDE_PATH}" "${LIBS}" "acsdkMultiAssistant;MultiAssistantUniversalDeviceController;SDKInterfacesTests")
\ No newline at end of file
diff --git a/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/UniversalDeviceControllerTest.cpp b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/UniversalDeviceControllerTest.cpp
new file mode 100644
index 00000000..deb8ad2a
--- /dev/null
+++ b/capabilities/MultiAssistantUniversalDeviceController/acsdkMultiAssistant/test/UniversalDeviceControllerTest.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * You may not use this file except in compliance with the terms and conditions
+ * set forth in the accompanying LICENSE file.
+ */
+
+/// @file UniversalDeviceControllerTest.cpp
+
+#include <gtest/gtest.h>
+
+#include <rapidjson/document.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <acsdkMultiAssistant/UniversalDeviceController.h>
+
+#include <AVSCommon/AVS/CapabilityState.h>
+#include <AVSCommon/AVS/CapabilityTag.h>
+#include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
+#include <AVSCommon/SDKInterfaces/MockContextManager.h>
+#include <AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h>
+#include <AVSCommon/SDKInterfaces/MockMessageSender.h>
+#include <AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsInvoker.h>
+#include <AVSCommon/SDKInterfaces/MockUniversalDeviceCommandsProvider.h>
+#include <AVSCommon/Utils/Memory/Memory.h>
+
+
+namespace alexaClientSDK {
+namespace acsdkMultiAssistant {
+namespace test {
+
+using namespace testing;
+
+/// The test EndpointIdentifier.
+static const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier ENDPOINT_IDENTIFIER{"test_endpoint_id"};
+
+/// Empty UniversalDeviceController Payload
+const std::string AVAILABLE_COMMANDS_PAYLOAD_TEMPLATE = R"({"availableCommands" : []})";
+
+/// Empty UniversalDeviceController CapabilityState
+static const avsCommon::avs::CapabilityState UDC_CAPABILITY_STATE = avsCommon::avs::CapabilityState(AVAILABLE_COMMANDS_PAYLOAD_TEMPLATE);
+
+/// UniversalDeviceController CapabilityTag
+static const avsCommon::avs::CapabilityTag UDC_CAPABILITY_TAG = avsCommon::avs::CapabilityTag(
+    "MultiAssistant.UniversalDeviceController",
+    "UniversalDeviceControllerState",
+    ENDPOINT_IDENTIFIER);
+
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_NAME = "MultiAssistant.UniversalDeviceController";
+const std::string UNIVERSALDEVICECONTROLLER_CAPABILITY_VERSION = "1.0";
+
+/// The namespace for this capability agent.
+static const std::string NAMESPACE = "MultiAssistant.UniversalDeviceController";
+
+/// The ExpectSpeech directive signature.
+static const avsCommon::avs::NamespaceAndName INVOKE_COMMAND{NAMESPACE, "InvokeCommand"};
+
+/// Value used in the tests for an invoke command timeout.
+static const std::string INVOKE_COMMAND_VALUE = "GLOBAL_FOREGROUND_STOP";
+
+/// JSON key for the timeout field of an invoke command directive.
+static const std::string INVOKE_COMMAND_KEY = "command";
+
+/// JSON key for the directive section of a message.
+static const std::string MESSAGE_DIRECTIVE_KEY = "directive";
+
+/// JSON key for the header section of a message.
+static const std::string MESSAGE_HEADER_KEY = "header";
+
+/// JSON key for the payload section of an message.
+static const std::string MESSAGE_PAYLOAD_KEY = "payload";
+
+/// JSON key for the namespace field of a message header.
+static const std::string MESSAGE_NAMESPACE_KEY = "namespace";
+
+/// JSON key for the name field of a message header.
+static const std::string MESSAGE_NAME_KEY = "name";
+
+/// JSON key for the message ID field of a message header.
+static const std::string MESSAGE_MESSAGE_ID_KEY = "messageId";
+
+/// Test harness for @c UniversalDeviceController class.
+class UniversalDeviceControllerTest : public ::testing::Test {
+public:
+    /// Set up the test harness for running a test.
+    void SetUp() override {
+        m_mockExceptionEncounteredSender =
+            std::make_shared<avsCommon::sdkInterfaces::test::MockExceptionEncounteredSender>();
+        m_mockMessageSender = std::make_shared<avsCommon::sdkInterfaces::test::MockMessageSender>();
+        m_mockContextManager = std::make_shared<avsCommon::sdkInterfaces::test::MockContextManager>();
+        m_mockUDCInvoker = std::make_shared<testing::StrictMock
+            <avsCommon::sdkInterfaces::test::MockUniversalDeviceCommandsInvoker>>();
+        m_mockUDCProvider = std::make_shared<testing::StrictMock
+            <avsCommon::sdkInterfaces::test::MockUniversalDeviceCommandsProvider>>();
+
+        EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerTag()).WillOnce(Return(UDC_CAPABILITY_TAG));
+        m_udcController = UniversalDeviceController::create(
+            m_mockExceptionEncounteredSender,
+            m_mockMessageSender,
+            m_mockContextManager,
+            ENDPOINT_IDENTIFIER,
+            m_mockUDCInvoker,
+            m_mockUDCProvider);
+    }
+
+protected:
+    std::shared_ptr<UniversalDeviceController> m_udcController;
+
+    /// The mock @c ExceptionEncounteredSenderInterface.
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockExceptionEncounteredSender> m_mockExceptionEncounteredSender;
+    /// The mock @c MessageSenderInterface for AIP.
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockMessageSender> m_mockMessageSender;
+    /// The mock @c ContextManagerInterface.
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockContextManager> m_mockContextManager;
+    /// The mock @c UniversalDeviceCommandsInvokerInterface.
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockUniversalDeviceCommandsInvoker> m_mockUDCInvoker;
+    /// The mock @c UniversalDeviceCommandsProviderInterface.
+    std::shared_ptr<avsCommon::sdkInterfaces::test::MockUniversalDeviceCommandsProvider> m_mockUDCProvider;
+    /// Message ID in directive
+    std::string m_messageId;
+};
+
+TEST_F(UniversalDeviceControllerTest, test_canStateBeRetrieved_returns_false) {
+    ASSERT_FALSE(m_udcController->canStateBeRetrieved());
+}
+
+TEST_F(UniversalDeviceControllerTest, test_hasReportableStateProperties_returns_false) {
+    ASSERT_FALSE(m_udcController->hasReportableStateProperties());
+}
+
+TEST_F(UniversalDeviceControllerTest, test_shouldQueryState_returns_false) {
+    ASSERT_FALSE(m_udcController->shouldQueryState());
+}
+
+TEST_F(UniversalDeviceControllerTest, test_provideState_calls_udcProvider_getUniversalDeviceControllerState) {
+    EXPECT_CALL(*m_mockUDCProvider, getUniversalDeviceControllerState(_)).Times(1);
+    m_udcController->provideState(UDC_CAPABILITY_TAG, avsCommon::sdkInterfaces::ContextRequestToken());
+}
+
+TEST_F(UniversalDeviceControllerTest, test_getCapabilityConfigurations_returns_correct_value) {
+    auto udcCapabilityConfig = m_udcController->getCapabilityConfigurations();
+
+    ASSERT_EQ(UNIVERSALDEVICECONTROLLER_CAPABILITY_INTERFACE_TYPE, udcCapabilityConfig.begin()->get()->type);
+    ASSERT_EQ(UNIVERSALDEVICECONTROLLER_CAPABILITY_NAME, udcCapabilityConfig.begin()->get()->interfaceName);
+    ASSERT_EQ(UNIVERSALDEVICECONTROLLER_CAPABILITY_VERSION, udcCapabilityConfig.begin()->get()->version);
+}
+
+}  // namespace test
+}  // namespace acsdkMultiAssistant
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
index ed94f6d7..e509db88 100644
--- a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
+++ b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
@@ -122,6 +122,11 @@ public:
      * completely rendered.
      */
     void onNotificationRenderingFinished() override;
+
+    /**
+     * This function takes some action when a Notification is about to be rendered.
+     */
+    void onNotificationRenderingStarted() override;
     /// @}
 
     /**
@@ -397,6 +402,16 @@ private:
 
     /// Serialize access to m_shutdownTrigger.
     std::mutex m_shutdownMutex;
+
+    /**
+     * @c The NotificationIndicator value retrieved from the payload of the latest Notifications.SetIndicator directive
+     * that was stored.
+     *
+     * @note We store this value because we have postponed the execution of the indicator state change until we
+     * receive an indication from NotificationRenderer, that the Notification chime is about to be rendered. Hence,
+     * this value will be passed to `executePossibleIndicatorStateChange`.
+     */
+    NotificationIndicator m_latestStoredNotificationIndicator;
 };
 
 }  // namespace acsdkNotifications
diff --git a/capabilities/Notifications/acsdkNotifications/src/NotificationRenderer.cpp b/capabilities/Notifications/acsdkNotifications/src/NotificationRenderer.cpp
index 857fe900..af1254da 100644
--- a/capabilities/Notifications/acsdkNotifications/src/NotificationRenderer.cpp
+++ b/capabilities/Notifications/acsdkNotifications/src/NotificationRenderer.cpp
@@ -89,19 +89,40 @@ void NotificationRenderer::onFocusChanged(FocusState newFocus, MixingBehavior be
         std::lock_guard<std::mutex> locker(m_mutex);
         auto currentFocus = m_focusState;
         m_focusState = newFocus;
-        // If we haven't obtained focus, we don't need to do anything.
-        // If we already have focus, it means we are playing something already, so
-        // we should return out. Additionally, if mixing behavior isn't PRIMARY or
-        // UNDEFINED, we should return out as it means another activity is the
-        // primary activity.
-        if ((FocusState::NONE == newFocus || FocusState::NONE != currentFocus) ||
+
+        /**
+         * We should not take any action in the following scenarios:
+         * 1. If we haven't obtained focus (i.e. newFocus==NONE), we return out.
+         * 2. If we are given BG focus, we return out.
+         * 3. If newFocus == currentFocus, we return out. We don't take any action on FG->FG or BG->BG transitions.
+         * 4. If the mixing behavior given to us, is not PRIMARY or UNDEFINED, we should return out. Since it means
+         *      another activity is the primary activity.
+         */
+        if (newFocus == FocusState::NONE ||
+            newFocus == FocusState::BACKGROUND ||
+            currentFocus == newFocus ||
             !(behavior == MixingBehavior::UNDEFINED || behavior == MixingBehavior::PRIMARY)) {
+            ACSDK_DEBUG5(LX(__func__).m("Not playing the Notifications chime now.")
+                                     .d("newFocus", newFocus)
+                                     .d("currentFocus", currentFocus)
+                                     .d("behavior", behavior));
             return;
         }
     }
 
-    // If we reach here, we must have acquired focus (either background or
-    // foreground).
+    // If we reach here, we must have acquired foreground focus. We may render the Notification now.
+
+    // Notify observers that the Notifications chime will be played.
+    std::unordered_set<std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererObserverInterface>> localObservers;
+    {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        localObservers = m_observers;
+    }
+    for (const auto& observer : localObservers) {
+        observer->onNotificationRenderingStarted();
+    }
+
+    // Play the chime
     m_executor.submit([this]() {
         if (MediaPlayerInterface::ERROR == m_sourceId) {
             ACSDK_ERROR(LX("renderNotificationPreferredFailed").d("reason", "invalid sourceId"));
diff --git a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
index dabde16f..bb27ac59 100644
--- a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
+++ b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
@@ -180,7 +180,8 @@ NotificationsCapabilityAgent::NotificationsCapabilityAgent(
         m_renderer{std::move(renderer)},
         m_notificationsAudioFactory{std::move(notificationsAudioFactory)},
         m_isEnabled{false},
-        m_currentState{NotificationsCapabilityAgentState::IDLE} {
+        m_currentState{NotificationsCapabilityAgentState::IDLE},
+        m_latestStoredNotificationIndicator{NotificationIndicator()} {
     m_capabilityConfigurations.insert(getNotificationsCapabilityConfiguration());
 
     m_notifier = std::make_shared<NotificationsNotifier>();
@@ -390,7 +391,6 @@ void NotificationsCapabilityAgent::handleSetIndicatorDirective(std::shared_ptr<D
 
 void NotificationsCapabilityAgent::executeRenderNotification(const NotificationIndicator& notificationIndicator) {
     m_currentAssetId = notificationIndicator.asset.assetId;
-
     executeSetState(NotificationsCapabilityAgentState::PLAYING);
     if (notificationIndicator.playAudioIndicator) {
         if (!m_renderer->renderNotification(
@@ -448,7 +448,23 @@ void NotificationsCapabilityAgent::executeSetIndicator(
                 submitMetric(m_metricRecorder, "setIndicatorFailed");
                 return;
             }
-            executePossibleIndicatorStateChange(intToIndicatorState(nextNotificationIndicator.persistVisualIndicator));
+
+            if (nextNotificationIndicator.playAudioIndicator) {
+                /**
+                 * If the `playAudioIndicator` parameter is true, we do not execute an indicator state change. This is
+                 * because we want to wait until NotificationRenderer indicates that the Notification audio is about to
+                 * be rendered. This helps us sync the Notification indicator with the chime. We store the
+                 * value of `nextNotificationIndicator`, so that it can be used in @c onNotificationRenderingStarted.
+                 */
+                m_latestStoredNotificationIndicator = nextNotificationIndicator;
+            } else {
+                /**
+                 * We only execute a state change if the `playAudioIndicator` parameter is false, implying that we don't
+                 * have to wait for the Notification audio to be rendered.
+                 */
+                executePossibleIndicatorStateChange(intToIndicatorState(nextNotificationIndicator.persistVisualIndicator));
+            }
+
             // only want to start playing if current state is idle, this check is needed
             // due to the fall-through above
             if (NotificationsCapabilityAgentState::IDLE == m_currentState) {
@@ -534,6 +550,8 @@ void NotificationsCapabilityAgent::executeClearIndicator(std::shared_ptr<Directi
 
     setHandlingCompleted(info);
     m_isEnabled = false;
+
+    // Attempts to turn the Notification indicator off.
     executePossibleIndicatorStateChange(IndicatorState::OFF);
 
     executeProvideState();
@@ -605,6 +623,20 @@ void NotificationsCapabilityAgent::onNotificationRenderingFinished() {
     m_executor.submit([this] { executeOnPlayFinished(); });
 }
 
+void NotificationsCapabilityAgent::onNotificationRenderingStarted() {
+    ACSDK_DEBUG5(LX(__func__));
+
+    if (!m_latestStoredNotificationIndicator.playAudioIndicator) {
+        ACSDK_DEBUG5(LX(__func__).m("Not executing an indicator state change since `playAudioIndicator` was false."));
+        return;
+    }
+
+    // Attempts to turn the Notification indicator on.
+    m_executor.submit([this] {
+        executePossibleIndicatorStateChange(intToIndicatorState(m_latestStoredNotificationIndicator.persistVisualIndicator));
+    });
+}
+
 void NotificationsCapabilityAgent::executeOnPlayFinished() {
     int queueSize = 0;
     m_currentAssetId = "";
diff --git a/capabilities/Notifications/acsdkNotifications/test/NotificationRendererTest.cpp b/capabilities/Notifications/acsdkNotifications/test/NotificationRendererTest.cpp
index 7a6c4b7e..d2978d63 100644
--- a/capabilities/Notifications/acsdkNotifications/test/NotificationRendererTest.cpp
+++ b/capabilities/Notifications/acsdkNotifications/test/NotificationRendererTest.cpp
@@ -74,6 +74,7 @@ public:
     MockNotificationRendererObserver();
 
     MOCK_METHOD0(onNotificationRenderingFinished, void());
+    MOCK_METHOD0(onNotificationRenderingStarted, void());
 
     /**
      * Wait for the @c onNotificationRenderingFinished() callback.
@@ -259,6 +260,7 @@ TEST_F(NotificationRendererTest, test_playPreferredStream) {
     EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(1);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
 
     m_renderer->renderNotification(goodStreamFunction, "");
@@ -278,6 +280,7 @@ TEST_F(NotificationRendererTest, testTimer_playDefaultStream) {
     EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(1);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(2);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
 
     m_renderer->renderNotification(goodStreamFunction, "");
@@ -302,6 +305,7 @@ TEST_F(NotificationRendererTest, test_secondPlayRejected) {
     EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(1);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
 
     ASSERT_TRUE(m_renderer->renderNotification(goodStreamFunction, ""));
@@ -320,6 +324,7 @@ TEST_F(NotificationRendererTest, testTimer_secondPlayWhilePlayingDefaultStream)
     EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(1);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(2);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
 
     ASSERT_TRUE(m_renderer->renderNotification(goodStreamFunction, ""));
@@ -348,6 +353,7 @@ TEST_F(NotificationRendererTest, test_cancelNotificationRendering) {
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), stop(_)).Times(1);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
 
     ASSERT_TRUE(m_renderer->renderNotification(goodStreamFunction, ""));
@@ -403,6 +409,7 @@ TEST_F(NotificationRendererTest, test_renderWhenAcquireChannelsSucceeds) {
     EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
     EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
     EXPECT_CALL(*(m_player.get()), play(_)).Times(1);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(1);
     EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
     EXPECT_CALL(*(m_focusManager.get()), acquireChannel(_, _)).Times(1);
     EXPECT_CALL(*(m_focusManager.get()), releaseChannel(_, _)).Times(1);
@@ -436,6 +443,81 @@ TEST_F(NotificationRendererTest, testShutdown) {
     ASSERT_TRUE(m_player->getObservers().empty());
 }
 
+/**
+ * Test that rendering does not occur when given background focus. Verify that the MediaPlayer's
+ * play() method does not get called and that the NotificationRenderer's observer does not get called back to indicate
+ * that playback has started (onNotificationRenderingStarted).
+ */
+TEST_F(NotificationRendererTest, test_doesNotRenderWhenGivenBackgroundFocus) {
+    EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
+    EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
+
+    // We do not expect `play` or `onNotificationRenderingStarted` to be invoked.
+    EXPECT_CALL(*(m_player.get()), play(_)).Times(0);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(0);
+
+    // We expect this call because of `m_player->mockFinished`. If we do not invoke `mockFinished`, the test
+    // would wait for a few seconds until it times out.
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
+
+    m_renderer->renderNotification(goodStreamFunction, "");
+    m_renderer->onFocusChanged(FocusState::BACKGROUND, MixingBehavior::UNDEFINED);
+    m_player->waitUntilPlaybackStarted();
+    m_player->mockFinished(m_player->getCurrentSourceId());
+
+    ASSERT_TRUE(m_observer->waitForFinished());
+}
+
+/**
+ * Test that rendering does not occur when given MixingBehavior::MAY_DUCK and foreground focus. Verify that the MediaPlayer's
+ * play() method does not get called and that the NotificationRenderer's observer does not get called back to indicate
+ * that playback has started (onNotificationRenderingStarted).
+ */
+TEST_F(NotificationRendererTest, test_doesNotRenderWhenGivenMixingBehaviorMayDuck) {
+    EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
+    EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
+
+    // We do not expect `play` or `onNotificationRenderingStarted` to be invoked.
+    EXPECT_CALL(*(m_player.get()), play(_)).Times(0);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(0);
+
+    // We expect this call because of `m_player->mockFinished`. If we do not invoke `mockFinished`, the test
+    // would wait for a few seconds until it times out.
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
+
+    m_renderer->renderNotification(goodStreamFunction, "");
+    m_renderer->onFocusChanged(FocusState::FOREGROUND, MixingBehavior::MAY_DUCK);
+    m_player->waitUntilPlaybackStarted();
+    m_player->mockFinished(m_player->getCurrentSourceId());
+
+    ASSERT_TRUE(m_observer->waitForFinished());
+}
+
+/**
+ * Test that rendering does not occur when given MixingBehavior::MUST_PAUSE and foreground focus. Verify that the MediaPlayer's
+ * play() method does not get called and that the NotificationRenderer's observer does not get called back to indicate
+ * that playback has started (onNotificationRenderingStarted).
+ */
+TEST_F(NotificationRendererTest, test_doesNotRenderWhenGivenMixingBehaviorMustPause) {
+    EXPECT_CALL(*(m_player.get()), urlSetSource(_)).Times(1);
+    EXPECT_CALL(*(m_player.get()), streamSetSource(_, _)).Times(0);
+
+    // We do not expect `play` or `onNotificationRenderingStarted` to be invoked.
+    EXPECT_CALL(*(m_player.get()), play(_)).Times(0);
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingStarted()).Times(0);
+
+    // We expect this call because of `m_player->mockFinished`. If we do not invoke `mockFinished`, the test
+    // would wait for a few seconds until it times out.
+    EXPECT_CALL(*(m_observer.get()), onNotificationRenderingFinished()).Times(1);
+
+    m_renderer->renderNotification(goodStreamFunction, "");
+    m_renderer->onFocusChanged(FocusState::FOREGROUND, MixingBehavior::MUST_PAUSE);
+    m_player->waitUntilPlaybackStarted();
+    m_player->mockFinished(m_player->getCurrentSourceId());
+
+    ASSERT_TRUE(m_observer->waitForFinished());
+}
+
 }  // namespace test
 }  // namespace acsdkNotifications
 }  // namespace alexaClientSDK
diff --git a/capabilities/Notifications/acsdkNotifications/test/NotificationsCapabilityAgentTest.cpp b/capabilities/Notifications/acsdkNotifications/test/NotificationsCapabilityAgentTest.cpp
index 7b1c6e56..24771443 100644
--- a/capabilities/Notifications/acsdkNotifications/test/NotificationsCapabilityAgentTest.cpp
+++ b/capabilities/Notifications/acsdkNotifications/test/NotificationsCapabilityAgentTest.cpp
@@ -513,6 +513,11 @@ bool MockNotificationRenderer::mockRender(
     std::function<std::pair<std::unique_ptr<std::istream>, const avsCommon::utils::MediaType>()> audioFactory,
     const std::string& url) {
     std::lock_guard<std::mutex> lock(m_mutex);
+    ACSDK_DEBUG5(LX(__func__));
+
+    /// We should notify the observers that rendering has started. This is in line with what happens
+    /// in @c NotificationRenderer::onFocusChanged().
+    m_observer->onNotificationRenderingStarted();
 
     if (m_renderStartedThread.joinable() && m_renderFinishedThread.joinable()) {
         m_renderStartedThread.join();
@@ -1120,6 +1125,7 @@ TEST_F(NotificationsCapabilityAgentTest, test_multipleSetIndicators) {
 TEST_F(NotificationsCapabilityAgentTest, test_clearData) {
     initializeCapabilityAgent();
     sendSetIndicatorDirective(generatePayload(true, true, "assetId1"), "firstIndicatorMessageId");
+    ASSERT_TRUE(m_testNotificationsObserver->waitFor(IndicatorState::ON, MY_WAIT_TIMEOUT));
     ASSERT_TRUE(m_renderer->waitUntilRenderingStarted());
 
     // Check that indicator is ON
diff --git a/capabilities/Notifications/acsdkNotificationsInterfaces/include/acsdkNotificationsInterfaces/NotificationRendererObserverInterface.h b/capabilities/Notifications/acsdkNotificationsInterfaces/include/acsdkNotificationsInterfaces/NotificationRendererObserverInterface.h
index 267e4e74..aa8571d1 100755
--- a/capabilities/Notifications/acsdkNotificationsInterfaces/include/acsdkNotificationsInterfaces/NotificationRendererObserverInterface.h
+++ b/capabilities/Notifications/acsdkNotificationsInterfaces/include/acsdkNotificationsInterfaces/NotificationRendererObserverInterface.h
@@ -30,6 +30,11 @@ public:
      * Notify our observer that rendering a notification audio clip has finished.
      */
     virtual void onNotificationRenderingFinished() = 0;
+
+    /**
+     * Notify our observer that a notification audio clip will start rendering.
+     */
+    virtual void onNotificationRenderingStarted() = 0;
 };
 
 }  // namespace acsdkNotificationsInterfaces
diff --git a/cmakeBuild/BuildDefaults.cmake b/cmakeBuild/BuildDefaults.cmake
index 742297e5..bd3b533e 100644
--- a/cmakeBuild/BuildDefaults.cmake
+++ b/cmakeBuild/BuildDefaults.cmake
@@ -22,8 +22,10 @@ macro(include_once module)
     endif()
 endmacro()
 
-# Disallow out-of-source-builds.
-include_once(DisallowOutOfSourceBuilds)
+if (NOT DEFINED ALLOW_OUT_OF_SOURCE_BUILDS)
+    # Disallow out-of-source-builds.
+    include_once(DisallowOutOfSourceBuilds)
+endif()
 
 # Setup default build options, like compiler flags and build type.
 include_once(BuildOptions)
@@ -153,3 +155,6 @@ include_once(LibArchive)
 
 # Setup AssetManager options.
 include_once(AssetManager)
+
+# Setup MultiAgentExperience variables.
+include_once(MultiAgentExperience)
diff --git a/cmakeBuild/Linux.cmake b/cmakeBuild/Linux.cmake
new file mode 100644
index 00000000..2b05994e
--- /dev/null
+++ b/cmakeBuild/Linux.cmake
@@ -0,0 +1,37 @@
+message("Using Linux cmake to build ${PROJECT_NAME}")
+
+set(CMAKE_INSTALL_PREFIX ${CMAKE_SOURCE_DIR}/../../cmake-install/Ctdl-avs-cpp-sdk/)
+
+set(ALLOW_OUT_OF_SOURCE_BUILDS ON)
+set(GSTREAMER_MEDIA_PLAYER ON)
+set(PORTAUDIO ON)
+set(DPKCS11 OFF)
+set(AUTH_MANAGER ON)
+set(BUILD_SHARED_LIBS ON)
+set(CMAKE_BUILD_TYPE DEBUG)
+# Adding flags for using MultiAgentExperience specific constructs
+set(MULTI_AGENT_EXPERIENCE_ENABLED ON)
+execute_process(COMMAND /usr/bin/uname -m
+        OUTPUT_VARIABLE CMAKE_HOST_SYSTEM_PROCESSOR)
+
+set(CURL_LIBRARY /usr/lib64/libcurl.so)
+set(CURL_INCLUDE_DIR /usr/include/curl/)
+set(CRYPTO_LIBRARY /usr/lib64/libcrypto.so)
+set(CRYPTO_INCLUDE_DIR /usr/include/openssl/)
+set(PORTAUDIO_LIB_PATH /usr/local/lib/libportaudio.a)
+set(PORTAUDIO_INCLUDE_DIR /usr/local/include)
+set(ENV{PKG_CONFIG_PATH} "/usr/lib64/pkgconfig")
+
+#set(CUSTOM_CXX_FLAGS "-Wno-unqualified-std-cast-call -Wno-unused-but-set-variable ")
+set(MultiAgentExperience-API_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-API/cmake)
+set(MultiAgentExperience-Logger_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-Logger/cmake)
+set(MultiAgentExperience-Testable-Device-Agent-API_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-Testable-Device-Agent-API/cmake)
+set(MultiAgentExperience-TestableDevice_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-TestableDevice/cmake)
+set(MultiAgentExperience_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience/cmake)
+set(MultiAgentExperience-API-TestHelper_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-API-TestHelper/cmake)
+set(MultiAgentExperience-ThreadExecutor_DIR ${CMAKE_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-ThreadExecutor/cmake)
+set(MultiAgentExperience-IPC_DIR ${CMAKE_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-IPC/cmake)
+set(MultiAgentExperience-IPC-gRPC_DIR ${CMAKE_SOURCE_DIR}/../../cmake-install/MultiAgentExperience-IPC-gRPC/cmake)
+
+# When added to EXTENSION_PATHS, the MultiAgentExperience-Alexa-Adapter will be added as a subdirectory to the Ctdl-avs-cpp-sdk package.
+list(APPEND EXTENSION_PATHS ${CMAKE_SOURCE_DIR}/../MultiAgentExperience-Alexa-Adapter)
\ No newline at end of file
diff --git a/cmakeBuild/cmake/BuildOptions.cmake b/cmakeBuild/cmake/BuildOptions.cmake
index 245ec1ac..f56d5ace 100644
--- a/cmakeBuild/cmake/BuildOptions.cmake
+++ b/cmakeBuild/cmake/BuildOptions.cmake
@@ -60,9 +60,9 @@ set(POSITION_INDEPENDENT_CODE ON CACHE BOOL "Build position-independent code")
 
 # Determine the platform and compiler dependent flags.
 if (NOT MSVC)
-    set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "-DDEBUG -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED -Wall -Werror -Wsign-compare -g")
-    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "-DNDEBUG -Wall -Werror -O2")
-    set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "-DNDEBUG -Wall -Werror -Os")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "-DDEBUG -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED -Wall -Werror ${CUSTOM_CXX_FLAGS} -Wno-deprecated -Wsign-compare -g")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "-DNDEBUG -Wall -Werror -Wno-deprecated -O2")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "-DNDEBUG -Wall -Werror -Wno-deprecated -Os")
     if (CMAKE_COMPILER_IS_GNUCXX AND (NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "8.0")))
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=class-memaccess")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=class-memaccess")
@@ -88,7 +88,8 @@ else()
     set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
     add_definitions("-DWIN32_LEAN_AND_MEAN")
 endif()
-if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+    message(STATUS "Setting additional flags for Clang compiler")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
diff --git a/cmakeBuild/cmake/MultiAgentExperience.cmake b/cmakeBuild/cmake/MultiAgentExperience.cmake
new file mode 100644
index 00000000..cbdcbb6b
--- /dev/null
+++ b/cmakeBuild/cmake/MultiAgentExperience.cmake
@@ -0,0 +1,4 @@
+if(MULTI_AGENT_EXPERIENCE_ENABLED)
+    message("Creating ${PROJECT_NAME} with MultiAgentExperience enabled.")
+    add_definitions(-DMULTI_AGENT_EXPERIENCE)
+endif()
\ No newline at end of file
diff --git a/core/Authorization/acsdkAuthorization/src/AuthorizationManager.cpp b/core/Authorization/acsdkAuthorization/src/AuthorizationManager.cpp
index 12deeb41..4602f5c9 100644
--- a/core/Authorization/acsdkAuthorization/src/AuthorizationManager.cpp
+++ b/core/Authorization/acsdkAuthorization/src/AuthorizationManager.cpp
@@ -115,7 +115,7 @@ void AuthorizationManager::reportStateChange(
         return;
     }
 
-    m_executor.submit([this, state, authId, userId] { handleTransition(state, authId, userId); });
+    m_executor.execute([this, state, authId, userId] { handleTransition(state, authId, userId); });
 }
 
 void AuthorizationManager::setStateLocked(const avsCommon::sdkInterfaces::AuthObserverInterface::FullState& state) {
diff --git a/core/acsdkCore/include/acsdkCore/CoreComponent.h b/core/acsdkCore/include/acsdkCore/CoreComponent.h
index 63bd23f3..6415ca69 100644
--- a/core/acsdkCore/include/acsdkCore/CoreComponent.h
+++ b/core/acsdkCore/include/acsdkCore/CoreComponent.h
@@ -37,6 +37,7 @@
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
 #include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/ExternalFocusMediatorInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/Storage/MiscStorageInterface.h>
@@ -78,6 +79,7 @@ using CoreComponent = acsdkManufactory::Component<
     std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>,
     std::shared_ptr<capabilityAgents::alexa::AlexaInterfaceMessageSender>,
     std::shared_ptr<afml::interruptModel::InterruptModel>,
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExternalFocusMediatorInterface>>,
     acsdkManufactory::
         Annotated<avsCommon::sdkInterfaces::AudioFocusAnnotation, avsCommon::sdkInterfaces::FocusManagerInterface>,
     acsdkManufactory::
diff --git a/shared/acsdkCommunicationInterfaces/include/acsdkCommunicationInterfaces/CommunicationProperty.h b/shared/acsdkCommunicationInterfaces/include/acsdkCommunicationInterfaces/CommunicationProperty.h
index 9505bf67..04fe2ff7 100644
--- a/shared/acsdkCommunicationInterfaces/include/acsdkCommunicationInterfaces/CommunicationProperty.h
+++ b/shared/acsdkCommunicationInterfaces/include/acsdkCommunicationInterfaces/CommunicationProperty.h
@@ -45,7 +45,7 @@ public:
     bool setValue(T newValue) {
         std::unique_lock<std::mutex> lock(m_propertyMutex);
         m_value = newValue;
-        m_executor.submit([this, newValue]() { notifyOnCommunicationPropertyChange(m_name, newValue); });
+        m_executor.execute([this, newValue]() { notifyOnCommunicationPropertyChange(m_name, newValue); });
         return true;
     }
 
